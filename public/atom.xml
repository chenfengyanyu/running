<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jartto&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/ee1200dca3e1b26043739f4bd08bfc12</icon>
  <subtitle>Jartto 个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jartto.wang/"/>
  <updated>2023-03-19T06:40:05.143Z</updated>
  <id>http://jartto.wang/</id>
  
  <author>
    <name>Jartto</name>
    <email>jartto@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 新书上市一周年</title>
    <link href="http://jartto.wang/2023/03/19/docker-new-book-online/"/>
    <id>http://jartto.wang/2023/03/19/docker-new-book-online/</id>
    <published>2023-03-19T04:12:59.000Z</published>
    <updated>2023-03-19T06:40:05.143Z</updated>
    
    <content type="html"><![CDATA[<p>我的新书<a href="https://mp.weixin.qq.com/s/DKEyfeRiNjfrQSzGxvLUHw" target="_blank" rel="noopener">《<code>Docker</code> 实战派：容器入门七步法》</a>上市已经一周年了，在这个里程碑的时刻，感谢各位朋友的支持。希望今年能够持续「大麦」，拿下同类书籍 <code>Top1</code>!<br><a id="more"></a></p><p><video src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/book/video.mp4" controls="controls" width="100%" height>您的浏览器不支持播放该视频！</video><br><div class="alert info"><p>本书已入选『自学入门的编程书 TOP 榜』，<a href="https://item.jd.com/13699932.html#none" target="_blank" rel="noopener">京东</a>、<a href="http://product.dangdang.com/29388559.html" target="_blank" rel="noopener">当当</a>，热卖中！</p></div></p><h4 id="一、内容回顾"><a href="#一、内容回顾" class="headerlink" title="一、内容回顾"></a>一、内容回顾</h4><p>市场上不乏<code>Docker</code>技术相关的书籍，或围绕官方基础文档缺乏新意，或直入源码让新人望而却步。鲜有既满足读者入门需要，又结合企业实际案例的佳作。<br>《<code>Docker</code>实战派：容器入门七步法》正是看到了这一点，另辟蹊径，从读者角度出发，首次提出了「七步法」的概念。</p><div class="alert success"><p>何谓「七步法」？七是人们最容易记住的数字，也是人类瞬间记忆的极限，本书正是立意于此。</p></div><p>第一步，从具象的故事开始，开门见山、降低认知门槛。<br>第二步，通过「第一个<code>Docker</code>项目」，帮助读者快速上手。在读者建立起体系概念后；<br>第三步，直切核心原理，围绕<code>Docker</code>架构展开，由浅入深的讲解了<code>Docker</code>底层隔离机制、容器生命周期、网络与通讯、存储原理以及源码。深入剖析，知其然而知其所以然。<br>第四步，趁热打铁，围绕前后端项目，从全栈角度进行项目实战。<br>第五步，从<code>Docker</code>容器运维角度出发，进一步补充读者知识图谱，这也是初学者最容易忽视的内容。<br>第六步，步入高级教程，该部分重点围绕<code>Docker</code>技术最佳实践展开，提供了容器与进程、文件存储与备份、网络配置、镜像优化以及安全策略等内容，示例丰富，操作性十足。<br>第七步，全书内容升华。通过云原生持续交付模型、企业容器标准化及两个实际的企业级方案，将本书所有内容进行串联。</p><p>至此，七步完成。读者可以清晰的感受每一步带来的技术提升，稳扎稳打，从而完全将<code>Docker</code>技术融会贯通。</p><h4 id="二、本书亮点"><a href="#二、本书亮点" class="headerlink" title="二、本书亮点"></a>二、本书亮点</h4><p>《<code>Docker</code> 实战派：容器入门七步法》最大的亮点就是：趣味易懂，案例丰富，实操性强。<br>（1）<strong>趣味易懂</strong><br>书中较多的原理，剥除了<code>Docker</code>官方文档晦涩难懂的外衣，通过趣味的故事展开。如：通过「盖房子」的比方来理解<code>Docker</code>是什么，通过「别墅与胶囊旅馆」的例子来阐述容器与虚拟机的概念，通过「工厂和车间」来说明进程和线程等。读者无需记忆，就可轻松理解，这也正是本书想要传达的观点——技术并非晦涩难懂，而是缺乏技巧。<br>（2）<strong>案例丰富</strong><br>本书第二、四、五、六、七章都包含大量的示例。不管是“第一个<code>Docker</code>项目”还是项目实战、或者是「企业案例」都包含了大量的代码讲解。读者完全可以按照教程逐步实现，体验<code>Docker</code>编程的乐趣。<br>（3）<strong>实操性强</strong><br>值得一提的是，本书中案例均来自于实际的研发过程，为了让读者能够轻松掌握，去除了容器中包含的业务逻辑，保留了<code>Docker</code>容器最核心的架构，实操性强。熟练掌握书中的精彩案例，沉淀其所表现出来的方法论，相信读者一定能够在企业应用中灵活运用，事半功倍。</p><h4 id="三、精彩书评"><a href="#三、精彩书评" class="headerlink" title="三、精彩书评"></a>三、精彩书评</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/book/info.png" alt="新书推荐"></p><p>「毋庸讳言，现如今还不了解<code>Docker</code>就不是一个合格的开发者。<code>Docker</code>对<code>DevOps</code>的飞速发展具有重要作用。本书结合作者多年一线“大厂”技术实践的经验，既有前端开发者的视角，又有上下游的相关案例，为读者提供了一个完整的<code>DevOps</code>“地图”，可以作为一线开发人员的案头用书。」——<strong>高途集团大前端技术通道负责人 黄后锦</strong></p><p>「<code>Docker</code>作为一种开源的应用容器引擎正在被广泛使用。本书由浅入深地介绍了相关的知识点，将很多不容易理解的概念用生活中的例子生动、形象地表达了出来，对于各个阶段的学习者来说都非常友好。同时，本书从研发岗位的不同视角，介绍了<code>Docker</code>的实践方案，对相关开发者的日常工作具有一定的指导作用。」——<strong>字节跳动商业技术营销工程团队负责人 赵龙</strong></p><p>「云计算技术的普及，使企业和组织更聚焦于自身的核心业务。而云原生如同“集装箱改变世界”一样，通过标准化的方式来应对业务在打包、部署和管理等过程中遇到的各种挑战，从而帮助企业达到降本增效的目的。容器技术可以说是云原生技术体系结构的基础。而<code>Docker</code>则是容器技术落地的“先驱”，是非常重要的容器技术实现，在整个云原生技术体系中具有重要作用。本书通过一个故事让读者明白<code>Docker</code>是什么，之后通过一个项目带领读者快速上手实践，并帮助读者补充了解<code>Docker</code>的核心原理，而后从项目实践、持续集成与发布、<code>Docker</code>的高级应用、打造企业级应用等方面展开介绍。本书是帮助读者入门<code>Docker</code>的佳作。乐于见到有更多这样的图书来帮助更多有需求的人，帮助他们早日走上云原生的大舞台。」——<strong>阿里云边缘云原生技术负责人 周晶</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的新书&lt;a href=&quot;https://mp.weixin.qq.com/s/DKEyfeRiNjfrQSzGxvLUHw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《&lt;code&gt;Docker&lt;/code&gt; 实战派：容器入门七步法》&lt;/a&gt;上市已经一周年了，在这个里程碑的时刻，感谢各位朋友的支持。希望今年能够持续「大麦」，拿下同类书籍 &lt;code&gt;Top1&lt;/code&gt;!&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="docker" scheme="http://jartto.wang/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>30s 就可以掌握的 Nginx 片段</title>
    <link href="http://jartto.wang/2023/03/12/30-seconds-of-nginx/"/>
    <id>http://jartto.wang/2023/03/12/30-seconds-of-nginx/</id>
    <published>2023-03-12T12:56:47.000Z</published>
    <updated>2023-03-18T12:57:54.398Z</updated>
    
    <content type="html"><![CDATA[<p>作为一枚程序员，日常研发少不了上线部署工作。一旦走上“基建”的道路，你就会发现 <code>Nginx</code> 是你绕不开的一个坎。毫不夸张的说：<code>Nginx</code> 能顶半边天！<br><a id="more"></a><br>也许你会反驳，我们有专业的运维（ <code>OP</code> ）团队，不用操心。然而实际情况却是 <code>OP</code> 每天被繁重的工单占据着，你无时无刻不在排队。大公司如此，小公司更甚。因此，储备一些 <code>Nginx</code> 知识，一定会让你事半功倍。<br><div class="alert success"><p>本文总结了日常开发中高频出现的 15 个 Nginx 配置片段，因为短小，所以你只需 30 秒就可以掌握。</p></div></p><h4 id="一、跨域配置"><a href="#一、跨域配置" class="headerlink" title="一、跨域配置"></a>一、跨域配置</h4><p>由于浏览器的安全策略，前端处理跨域请求的概率极高，如下是开启跨域请求常规手段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$request_method</span> = OPTIONS ) &#123;</span><br><span class="line">    add_header <span class="string">"Access-Control-Allow-Origin"</span>  *;</span><br><span class="line">    add_header <span class="string">"Access-Control-Allow-Methods"</span> <span class="string">"GET, POST, OPTIONS, HEAD"</span>;</span><br><span class="line">    add_header <span class="string">"Access-Control-Allow-Headers"</span> <span class="string">"Authorization, Origin, X-Requested-With, Content-Type, Accept"</span>;</span><br><span class="line">    add_header <span class="string">'Access-Control-Max-Age'</span> 600;</span><br><span class="line">    <span class="built_in">return</span> 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、开启-GZip-压缩"><a href="#二、开启-GZip-压缩" class="headerlink" title="二、开启 GZip 压缩"></a>二、开启 GZip 压缩</h4><p>如果你希望压缩常规的文件类型，可以参考如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http </span><br><span class="line">&#123;</span><br><span class="line">  include       conf/mime.types;</span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_min_length  1000;</span><br><span class="line">  gzip_buffers     4 8k;   </span><br><span class="line">  gzip_http_version 1.1; </span><br><span class="line">  gzip_types       text/plain application/x-javascript text/css application/xml application/javascript application/json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GZip 涉及参数较多，还有 <code>gzip_comp_level</code>、<code>gzip_proxied</code>等，详情可以参考：<a href="https://www.jianshu.com/p/e0ff1e275e7f" target="_blank" rel="noopener">Nginx配置 - Gzip压缩</a></p><h4 id="三、跨域传递-Cookie"><a href="#三、跨域传递-Cookie" class="headerlink" title="三、跨域传递 Cookie"></a>三、跨域传递 Cookie</h4><p><code>Chrome 80</code>以后的版本，<code>Cookie</code>默认不可跨域，除非服务器在响应头里再设置 <code>same-site</code> 属性（<code>strict</code>，<code>lax</code>，<code>none</code>）。</p><ul><li><code>Strict</code>最为严格，完全禁止第三方<code>Cookie</code>，跨站点时，任何情况下都不会发送<code>Cookie</code>。换言之，只有当前网页的<code>URL</code>与请求目标一致，才会带上<code>Cookie</code>。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个<code>GitHub</code>链接，用户点击跳转就不会带有<code>GitHub</code>的<code>Cookie</code>，跳转过去总是未登陆状态。</li><li><p><code>None</code>，<code>Cookie</code>只能通过<code>HTTPS</code>协议发送。必须同时设置<code>Secure</code>属性（<code>Cookie</code>只能通过<code>HTTPS</code>协议发送），否则无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure></li><li><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方<code>Cookie</code>，但是导航到目标网址的<code>Get</code>请求除外。</p></li></ul><p>还有一种方式是使用<code>proxy_pass</code>反向代理。如果只是<code>Host</code>、端口转换，则<code>Cookie</code>不会丢失。再次访问时，浏览器会发送当前的<code>Cookie</code>。当然，路径变化了，则需要设置<code>Cookie</code>的路径转换。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    proxy_pass http://localhost:4000;</span><br><span class="line">    proxy_cookie_path /foo <span class="string">"/; SameSite=None; HTTPOnly; Secure"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="四、健康检查"><a href="#四、健康检查" class="headerlink" title="四、健康检查"></a>四、健康检查</h4><p><code>Nginx</code> 服务端会按照设定的间隔时间主动向后端的 <code>upstream_server</code> 发出检查请求来验证后端的各个 <code>upstream_server</code> 的状态。<br>如果得到某个服务器失败的返回超过一定次数，比如 3 次就会标记该服务器为异常，就不会将请求转发至该服务器。一般情况下后端服务器需要为这种健康检查专门提供一个低消耗的接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  <span class="comment"># 指定一个 upstream 负载均衡组，名称为 evalue</span></span><br><span class="line">  upstream evalue &#123;</span><br><span class="line">    <span class="comment"># 定义组内的节点服务，如果不加 weight 参数，默认就是 Round Robin ，加上了 weight 参数就是加权轮询</span></span><br><span class="line">    server 192.168.90.100:9999 weight=100;</span><br><span class="line">    server 192.168.90.101:9999 weight=100;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># interval=3000 检查间隔 3 秒 ， rise=3 连续成功3次认为服务健康 ， fall=5 连续失败 5 次认为服务不健康 ， timeout=3000 健康检查的超时时间为 3 秒 ， type=http  检查类型 http</span></span><br><span class="line">    check interval=3000 rise=3 fall=5 timeout=3000 <span class="built_in">type</span>=http;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># check_http_send 设定检查的行为：请求类型 url 请求协议 -&gt; HEAD /api/v1/health HTTP/1.0         </span></span><br><span class="line">    check_http_send <span class="string">"HEAD /api/v1/health HTTP/1.0\r\n\r\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设定认为返回正常的响应状态       </span></span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="五、泛域名解析"><a href="#五、泛域名解析" class="headerlink" title="五、泛域名解析"></a>五、泛域名解析</h4><p>要在 <code>Nginx</code> 中配置域名泛解析，可以使用通配符 <code>*</code> 来实现次级域名指向同一 <code>IP</code> 地址。如下是一个简单的 <code>Nginx</code> 配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name *.jartto.com;</span><br><span class="line">    root /var/www/jartto.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置将所有以 <code>.jartto.com</code> 结尾的域名都指向 <code>/var/www/jartto.com</code> 目录下的网站。如果要配置二级域名，可以使用以下的 <code>Nginx</code> 配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name *.sub.jartto.com;</span><br><span class="line">    root /var/www/sub.jartto.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置将所有以 <code>.sub.example.com</code> 结尾的二级域名都指向 <code>/var/www/sub.example.com</code> 目录下的网站。需要注意的是，在使用泛解析时，可能会导致一些安全问题。因此，建议仅在必要时使用泛解析，并且要对网站进行充分保护。</p><h4 id="六、使用-request-id-实现链路追踪"><a href="#六、使用-request-id-实现链路追踪" class="headerlink" title="六、使用 $request_id 实现链路追踪"></a>六、使用 $request_id 实现链路追踪</h4><p><code>Nginx</code>在<code>1.11.0</code>版本中就提供了内置变量<code>$request_id</code>，其原理就是生成 32 位的随机字符串，虽不能比拟 <code>UUID</code> 的概率，但 32 位的随机字符串的重复概率也是微不足道了，所以一般可视为 <code>UUID</code> 来使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /habo/gid &#123;</span><br><span class="line">        add_header Cache-Control no-store;</span><br><span class="line">        default_type application/javascript;</span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$unionId</span> <span class="variable">$cookie_GID</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$unionId</span> = <span class="string">""</span>) &#123;</span><br><span class="line">                <span class="built_in">set</span> <span class="variable">$unionId</span> <span class="variable">$request_id</span>;</span><br><span class="line">                add_header Set-Cookie <span class="string">"GID=<span class="variable">$&#123;unionId&#125;</span>;path=/habo/;max-age=<span class="variable">$&#123;GID_MAX_AGE&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> 200 <span class="string">"document.cookie='GID=<span class="variable">$&#123;unionId&#125;</span>;path=/;max-age=<span class="variable">$&#123;GID_MAX_AGE&#125;</span>'"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="七、限流配置"><a href="#七、限流配置" class="headerlink" title="七、限流配置"></a>七、限流配置</h4><div class="alert info"><p><code>Nginx</code>提供了两种限流方式：控制速率和控制并发连接数。</p></div><p>其中，控制速率是指限制单位时间内的请求次数，而控制并发连接数是指限制同时处理的请求数量。</p><p>下面是一个简单的<code>Nginx</code>限流配置示例，使用<code>leaky bucket</code>算法进行限流：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone <span class="variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述配置中，<code>limit_req_zone</code>用于定义一个名为<code>one</code>的共享内存区域，并将其与客户端<code>IP</code>地址相关联。这个共享内存区域最大占用<code>10MB</code>空间，并且允许每秒钟通过 1 个请求。然后，在<code>location</code>块中使用了<code>limit_req</code>指令来启用限流功能。这里设置<code>burst</code>为 5，表示当客户端在短时间内发送超过 1 个请求时，可以暂时容忍一定数量的请求超出限制。<br>需要注意的是，在实际应用中需要根据具体情况调整参数值以达到最佳效果。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_baggage_flow</span>  <span class="variable">$plimit</span> &#123;</span><br><span class="line"> <span class="string">"ptest"</span> <span class="variable">$server_name</span>;</span><br><span class="line"> default <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_zone <span class="variable">$plimit</span> zone=prelimit:10m rate=600r/s;</span><br><span class="line"> server &#123;</span><br><span class="line">  listen       443 ssl;</span><br><span class="line">  server_name   m.gaotu100.com;</span><br><span class="line">  limit_req zone=prelimit  nodelay;</span><br><span class="line">  limit_req_status 530;</span><br><span class="line"></span><br><span class="line">  location = /530.html &#123;</span><br><span class="line">      default_type application/json;</span><br><span class="line">      <span class="built_in">return</span> 200 <span class="string">'&#123;"status" : 530&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="八、History-二级路由刷新问题"><a href="#八、History-二级路由刷新问题" class="headerlink" title="八、History 二级路由刷新问题"></a>八、History 二级路由刷新问题</h4><p><code>vue-router+webpack</code>项目线上部署时单页项目路由，刷新页面出现 <code>404</code> 问题，一般需要配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">　　root html;</span><br><span class="line">　　try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @router;</span><br><span class="line">　　index index.html index.htm;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">location @router &#123;</span><br><span class="line">　　rewrite ^.*$ /index.html last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="九、Cookie-路由识别"><a href="#九、Cookie-路由识别" class="headerlink" title="九、Cookie 路由识别"></a>九、Cookie 路由识别</h4><p>最常见的场景就是灰度发布，<code>Nginx</code> 来识别来自前端的流量，从而进行转发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map $http_cookie $m_upstream &#123;</span><br><span class="line">    ~*baggage-version=isolute-feat-.*$ al-bj-sre-k8s-test-istio-gateway;</span><br><span class="line">    default test.jartto.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream al-bj-sre-k8s-test-istio-gateway &#123;</span><br><span class="line">    server 47.95.128.11:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="十、服务端开启图片转换"><a href="#十、服务端开启图片转换" class="headerlink" title="十、服务端开启图片转换"></a>十、服务端开启图片转换</h4><p>这里主要是设置 <code>WebP</code> 格式图片，如果你还不了解，请查看：<a href="http://jartto.wang/2020/05/02/webp-practice/"><code>WebP</code> 方案分析与实践</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map $http_accept $webp_suffix &#123;</span><br><span class="line">    default   &quot;&quot;;</span><br><span class="line">    &quot;~*webp&quot;  &quot;.webp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location  ~* ^/_nuxt/img/(.+\.png|jpe?g)$ &#123;</span><br><span class="line">    rewrite ^/_nuxt/img/(.+\.png|jpe?g)$ /$1 break;</span><br><span class="line">    root /apps/srv/instance/test-webp.gaotu100.com/.nuxt/dist/client/img/;</span><br><span class="line">    add_header Vary Accept;</span><br><span class="line">    try_files $uri$webp_suffix $uri =404;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十一、负载均衡"><a href="#十一、负载均衡" class="headerlink" title="十一、负载均衡"></a>十一、负载均衡</h4><p>负载均衡通常有四种算法：</p><ul><li>轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除；</li><li><code>weight</code>，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况；</li><li><code>ip_hash</code>，每个请求按访问 <code>IP</code> 的 <code>hash</code> 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 <code>session</code> 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的；</li><li><code>fair</code>（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 <code>nginx-upstream-fair</code>，使用前请先安装；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream jartto-server &#123;</span><br><span class="line">  # ip_hash;  # ip_hash 方式</span><br><span class="line">    # fair;   # fair 方式</span><br><span class="line">    server 127.0.0.1:8081;  # 负载均衡目的服务地址</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    server 127.0.0.1:8082 weight=10;  # weight 方式，不写默认为 1</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_pass http://jartto-server;</span><br><span class="line">      proxy_connect_timeout 10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="十二、配置-HTTPS"><a href="#十二、配置-HTTPS" class="headerlink" title="十二、配置 HTTPS"></a>十二、配置 HTTPS</h4><p>要在 <code>Nginx</code> 上配置 <code>HTTPS</code>，可以按照以下步骤操作：</p><ol><li>为 <code>Nginx</code> 安装 <code>SSL</code> 模块。 这可以通过使用 <code>--with-http_ssl_module</code> 选项编译 <code>Nginx</code> 或安装包含 <code>SSL</code> 模块的预构建包来完成。</li><li>从受信任的证书颁发机构<code>CA</code>为您的域获取<code>SSL</code>证书。 这可以通过购买证书或从<code>Let&#39;s Encrypt</code>获得免费证书来完成。</li><li><p>配置<code>Nginx</code>以使用<code>SSL</code>证书和密钥文件。这涉及将以下行添加到您的<code>Nginx</code>配置文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate /path/to/jartto.crt;</span><br><span class="line">ssl_certificate_key /path/to/jartto.key;</span><br></pre></td></tr></table></figure></li><li><p>如果需要，配置<code>Nginx</code>将<code>HTTP</code>请求重定向到<code>HTTPS</code>。 这可以使用服务器块来完成，该服务器块监听端口<code>80</code>并将所有请求重定向到端口<code>443</code>（默认 <code>HTTPS</code> 端口）。</p></li><li>重新启动<code>Nginx</code>以应用更改。</li></ol><p>下面是启用<code>HTTPS</code>并将<code>HTTP</code>请求重定向到<code>HTTPS</code>的<code>Nginx</code>配置文件示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name jartto.com www.jartto.com;</span><br><span class="line">    <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name jartto.com www.jartto.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/jartto.crt;</span><br><span class="line">    ssl_certificate_key /path/to/jartto.key;</span><br><span class="line">    <span class="comment"># Other SSL-related settings go here</span></span><br><span class="line">    <span class="comment"># Other server block settings go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上配置文件同时监听端口<code>80</code>和<code>443</code>，但仅在端口<code>443</code>上通过<code>HTTPS</code>提供内容。所有<code>HTTP</code>请求都使用第一个服务器块中的返回语句重定向到它们等效的<code>HTTPS URL</code>。</p><h4 id="十三、图片防盗链"><a href="#十三、图片防盗链" class="headerlink" title="十三、图片防盗链"></a>十三、图片防盗链</h4><p>如果你不想图片被外网随便引用，那么可以配置图片防盗链能力，配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;        </span><br><span class="line">  server_name  *.jartto.com;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 图片防盗链</span></span><br><span class="line">  location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">    valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  <span class="comment"># 只允许本机 IP 外链引用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">      <span class="built_in">return</span> 403;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="十四、配置多-Server"><a href="#十四、配置多-Server" class="headerlink" title="十四、配置多 Server"></a>十四、配置多 Server</h4><p>要在<code>Nginx</code>中配置多个服务器，可以在<code>Nginx</code>配置文件中定义多个服务器块。每个服务器块代表一个单独的虚拟服务器，可以监听不同的端口或<code>IP</code>地址，并提供不同的内容。下面是如何在<code>Nginx</code>中配置两个虚拟服务器的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.jartto.com;</span><br><span class="line">    root /var/www/jartto.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># other server configuration directives</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.another-jartto.com;</span><br><span class="line">    root /var/www/another-jartto.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># other server configuration directives</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述示例中，我们定义了两个监听端口<code>80</code>的虚拟服务器。第一个虚拟服务器配置为从目录<code>/var/www/jartto.com</code>为域<code>www.jartto.com</code>提供内容。第二个虚拟服务器配置为从目录<code>/var/www/another-jartto.com</code>为域<code>www.another-jartto.com</code>提供内容。每个服务器块都可以有自己的一组配置指令，例如<code>SSL</code>证书、访问日志、错误页面等等。 </p><div class="alert info"><p>通过在<code>Nginx</code>配置文件中定义多个服务器块，我们就可以在单个<code>Nginx</code>实例上托管多个网站或应用程序。</p></div><h4 id="十五、动态修改配置模块"><a href="#十五、动态修改配置模块" class="headerlink" title="十五、动态修改配置模块"></a>十五、动态修改配置模块</h4><p><code>ngx_dynamic_upstream</code> 是用于使用 <code>HTTP API</code> 动态操作上游的模块，例如 <code>ngx_http_upstream_conf</code>。如果你想动态修改<code>Nginx</code>配置信息，那么不妨试试如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">upstream backends &#123;</span><br><span class="line">    zone zone_for_backends 1m;</span><br><span class="line">    server 127.0.0.1:6001;</span><br><span class="line">    server 127.0.0.1:6002;</span><br><span class="line">    server 127.0.0.1:6003;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 6000;</span><br><span class="line"></span><br><span class="line">    location /dynamic &#123;</span><br><span class="line">      allow 127.0.0.1;</span><br><span class="line">      deny all;</span><br><span class="line">      dynamic_upstream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://backends;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;verbose=&quot;</span><br><span class="line">server 127.0.0.1:6001 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6002 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6003 weight=1 max_fails=1 fail_timeout=10;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一枚程序员，日常研发少不了上线部署工作。一旦走上“基建”的道路，你就会发现 &lt;code&gt;Nginx&lt;/code&gt; 是你绕不开的一个坎。毫不夸张的说：&lt;code&gt;Nginx&lt;/code&gt; 能顶半边天！&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="nginx" scheme="http://jartto.wang/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>了不起的 Istio</title>
    <link href="http://jartto.wang/2020/07/29/istio-1/"/>
    <id>http://jartto.wang/2020/07/29/istio-1/</id>
    <published>2020-07-28T22:44:51.000Z</published>
    <updated>2020-08-03T02:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多企业都会面临从单体应用向微服务架构的转型，也会衍生出更多的分布式场景需求。随着规模和复杂度的不断增长，如何才能更好的理解、高效的管理<strong>服务网格</strong>呢？</p><a id="more"></a><p>本节篇幅较长，我们主要围绕以下几点来展开：<br>1.什么是服务网格？<br>2.初识 <code>Istio</code><br>3.核心特性<br>4.流程架构<br>5.核心模块<br>6.<code>Envoy</code> 进阶<br>7.方案畅想</p><p>对许多公司来说，<code>Docker</code> 和 <code>Kubernetes</code> 这样的工具已经解决了部署问题，或者说几乎解决了。但他们还没有解决<strong>运行时</strong>的问题，这就是服务网格（<code>Service Mesh</code>）的由来。</p><h4 id="一、什么是服务网格？"><a href="#一、什么是服务网格？" class="headerlink" title="一、什么是服务网格？"></a>一、什么是服务网格？</h4><p>服务网格（<code>Service Mesh</code>）用来描述组成这些应用程序的微服务网络以及它们之间的交互。它是一个用于保证服务间安全、快速、可靠通信的网络代理组件，是随着<strong>微服务和云原生应用</strong>兴起而诞生的基础设施层。</p><p>它通常以轻量级网络代理的方式同应用部署在一起。比如 <code>Sidecar</code> 方式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/service-mesh.png" alt="Service Mesh"></p><p>我们对上图做个解释：<br><code>Service Mesh</code> 设计一般划分为两个模块，<strong>控制面</strong>和<strong>数据面</strong>。对于应用来说，所有流量都会经过数据面进行转发。顺利转发的前提：<strong>数据面需要知道转发的目标地址</strong>，目标地址本身是由一些业务逻辑来决定的(例如服务发现)。</p><p>所以自然而然地，我们可以推断<strong>控制面</strong>需要负责管理数据面能正常运行所需要的一些配置：</p><ul><li>需要知道某次请求转发去哪里：服务发现配置；</li><li>外部流量进入需要判断是否已经达到服务流量上限：限流配置；</li><li>依赖服务返回错误时，需要能够执行相应的熔断逻辑：熔断配置；</li></ul><p><code>Serivce Mesh</code> 可以看作是一个位于 <code>TCP/IP</code> 之上的网络模型，抽象了服务间可靠通信的机制。但与 <code>TCP</code> 不同，它是面向应用的，为应用提供了统一的可视化和控制。</p><p><strong>1.<code>Service Mesh</code> 具有如下优点：</strong></p><ul><li>屏蔽分布式系统通信的复杂性(负载均衡、服务发现、认证授权、监控追踪、流量控制等等)，服务只用关注业务逻辑；</li><li>真正的语言无关，服务可以用任何语言编写，只需和 <code>Service Mesh</code> 通信即可；</li><li>对应用透明，<code>Service Mesh</code> 组件可以单独升级；</li></ul><p><strong>2.<code>Service Mesh</code> 目前也面临一些挑战：</strong></p><ul><li><code>Service Mesh</code> 组件以代理模式计算并转发请求，一定程度上会降低通信系统性能，并增加系统资源开销；</li><li><code>Service Mesh</code> 组件接管了网络流量，因此服务的整体稳定性依赖于 <code>Service Mesh</code>，同时额外引入的大量 <code>Service Mesh</code> 服务实例的运维和管理也是一个挑战；</li></ul><div class="alert danger"><p>随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。</p></div><p><code>Service Mesh</code> 的需求包括服务发现、负载均衡、故障恢复、度量和监控等。<code>Service Mesh</code> 通常还有更复杂的运维需求，比如 <code>A/B</code> 测试、金丝雀发布、速率限制、访问控制和端到端认证。</p><p><code>Service Mesh</code>的出现，弥补了 <code>Kubernetes</code> 在微服务的连接、管理和监控方面的短板，为 <code>Kubernetes</code> 提供更好的应用和服务管理。因此，<code>Service Mesh</code> 的代表 <code>Istio</code> 一经推出，就被认为是可以和 <code>Kubernetes</code> 形成双剑合璧效果的微服务管理的利器，受到了业界的推崇。</p><p><code>Istio</code> 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案。<code>Istio</code> 主要采用一种一致的方式来保护、连接和监控微服务，降低了管理微服务部署的复杂性。</p><h4 id="二、初识-Istio"><a href="#二、初识-Istio" class="headerlink" title="二、初识 Istio"></a>二、初识 Istio</h4><p><code>Istio</code> 发音「意丝帝欧」，重音在<strong>意</strong>上。官方给出的 <code>Istio</code> 的总结，简单明了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Istio lets you connect, secure, control, and observe services.</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>连接、安全、控制和观测服务。</p></div><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/ingress-istio.png" alt="初识 Istio"></p><p>简单来说，<code>Istio</code> 针对现有的服务网格，提供一种简单的方式将连接、安全、控制和观测的模块，与应用程序或服务隔离开来，从而开发人员可以将更多的精力放在核心的业务逻辑上，以下是 <code>Istio</code> 的核心功能：</p><p>1.<code>HTTP</code>、<code>gRPC</code>、<code>WebSocket</code> 和 <code>TCP</code> 流量的自动负载均衡；<br>2.通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制；<br>3.可插入的策略层和配置 <code>API</code>，支持访问控制、速率限制和配额；<br>4.对出入集群入口和出口中所有流量的自动度量指标、日志记录和追踪；<br>5.通过强大的基于身份的验证和授权，在集群中实现安全的服务间通信；</p><p>从较高的层面来说，<code>Istio</code> 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 <code>API</code> 接口。</p><p><code>Istio</code> 多样化的特性使我们能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p><h4 id="三、核心特性"><a href="#三、核心特性" class="headerlink" title="三、核心特性"></a>三、核心特性</h4><p><code>Istio</code> 以统一的方式提供了许多<strong>跨服务网格</strong>的关键功能：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/intro.png" alt="官方介绍"></p><p><strong>1.流量管理</strong><br><code>Istio</code> 简单的规则配置和流量路由允许我们控制服务之间的流量和 <code>API</code> 调用过程。<code>Istio</code> 简化了服务级属性（如熔断器、超时和重试）的配置，并且让它轻而易举的执行重要的任务（如 <code>A/B</code> 测试、金丝雀发布和按流量百分比划分的分阶段发布）。</p><p>有了更好的对流量的可视性和开箱即用的故障恢复特性，我们就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮。</p><p><strong>2.安全</strong><br><div class="alert warning"><p><code>Istio</code> 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。</p></div></p><p><code>Istio</code> 提供了<strong>底层的安全通信通道</strong>，并为大规模的<strong>服务通信管理认证、授权和加密</strong>。有了 <code>Istio</code>，服务通信在默认情况下就是受保护的，可以在跨不同协议和运行时的情况下实施一致的策略，而所有这些都只需要很少甚至不需要修改应用程序。</p><p><code>Istio</code> 是独立于平台的，可以与 <code>Kubernetes</code>（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护 <code>Pod</code> 到 <code>Pod</code> 或者服务到服务之间的通信。</p><p><strong>3.可观察性</strong><br><code>Istio</code> 健壮的<strong>追踪、监控和日志特性</strong>让我们能够深入的<strong>了解服务网格部署</strong>。通过 <code>Istio</code> 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的。而它的定制 <code>Dashboard</code> 提供了对所有服务性能的可视化能力，并让我们看到它如何影响其他进程。</p><p><code>Istio</code> 的 <code>Mixer</code> 组件负责<strong>策略控制</strong>和<strong>遥测数据收集</strong>。它提供了后端抽象和中介，将一部分 <code>Istio</code>与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制。</p><p>所有这些特性都使我们能够更有效地设置、监控和加强服务的 <code>SLO</code>。当然，底线是我们可以快速有效地检测到并修复出现的问题。</p><p><strong>4.平台支持</strong><br><code>Istio</code> 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、<code>Kubernetes</code>、<code>Mesos</code> 等等。我们可以在 <code>Kubernetes</code> 或是装有 <code>Consul</code> 的 <code>Nomad</code> 环境上部署 <code>Istio</code>。</p><p><code>Istio</code> 目前支持：</p><ul><li><code>Kubernetes</code> 上的服务部署</li><li>基于 <code>Consul</code> 的服务注册</li><li>服务运行在独立的虚拟机上</li></ul><p><strong>5.整合和定制</strong><br><code>Istio</code> 的策略实施组件可以扩展和定制，与现有的 <code>ACL</code>、日志、监控、配额、审查等解决方案集成。</p><h4 id="四、流程架构"><a href="#四、流程架构" class="headerlink" title="四、流程架构"></a>四、流程架构</h4><p><code>Istio</code> 服务网格逻辑上分为<strong>数据平面</strong>（<code>Control Plane</code>）和<strong>控制平面</strong>（<code>Data Plane</code>），架构图如下所示：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/framework.png" alt="Istio 架构图"></p><p>1.<strong>数据平面<code>Data Plane</code></strong>由一组以 <code>Sidecar</code> 方式部署的智能代理 <code>Envoy</code> 组成。</p><p><code>Envoy</code> 被部署为 <code>Sidecar</code>，和对应服务在同一个 <code>Kubernetes pod</code> 中。这允许 <code>Istio</code> 将大量关于流量行为的信号作为属性提取出来，而这些属性又可以在 <code>Mixer</code> 中用于执行策略决策，并发送给监控系统，以提供整个网格行为的信息。</p><div class="alert success"><p>这些代理可以调节和控制微服务及 <code>Mixer</code> 之间所有的网络通信。</p></div><p>2.<strong>控制平面<code>Control Plane</code></strong>负责管理和配置代理来路由流量，此外配置 <code>Mixer</code> 以实施策略和收集遥测数据。主要包含如下几部分内容：</p><ul><li><code>Mixer</code>：策略和请求追踪；</li><li><code>Pilot</code>：提供服务发现功能，为智能路由（例如 <code>A/B</code> 测试、金丝雀部署等）和弹性（超时、重试、熔断器等）提供流量管理功能；</li><li><code>Citadel</code>：分发 <code>TLS</code> 证书到智能代理；</li><li><code>Sidecar injector</code>：可以允许向应用中无侵入的添加功能，避免为了满足第三方需求而添加额外的代码；</li></ul><h4 id="五、核心模块"><a href="#五、核心模块" class="headerlink" title="五、核心模块"></a>五、核心模块</h4><p>上文提到了很多技术名词，我们需要重点解释一下：</p><p>1.什么是 <code>Sidecar</code> 模式？<br><code>Sidecar</code> 是一种将应用功能从应用本身剥离出来作为单独进程的设计模式，可以允许向应用中无侵入的添加功能，避免为了满足第三方需求而添加额外的代码。</p><p>在软件架构中，<code>Sidecar</code> 附加到主应用，或者叫父应用上，以扩展、增强功能特性，同时 <code>Sidecar</code> 与主应用是<strong>松耦合</strong>的。</p><div class="alert info"><p><code>Sidecar</code> 是一种单节点多容器的应用设计形式，主张以额外的容器来扩展或增强主容器。</p></div><p>2.<code>Envoy</code> 的作用是什么？<br><code>Envoy</code> 是一个独立的进程，旨在与每个应用程序服务器一起运行。所有 <code>Envoy</code> 组成了一个透明的通信网格，其中每个应用程序发送和接收来自本地主机的消息，并且不需要知道网络拓扑。</p><p>与传统的服务通信服务的库方法相比，<strong>进程外架构</strong>有两个实质性好处：</p><ul><li><code>Envoy</code> 支持任何编程语言写的服务。只用部署一个 <code>Envoy</code> 就可以在 <code>Java</code>、<code>C++</code>、<code>Go</code>、<code>PHP</code>、<code>Python</code> 等服务间形成网格。</li><li>任何使用过大型面向服务的体系结构的人都知道，部署库升级可能会非常痛苦。<code>Envoy</code> 可以在整个基础设施中迅速部署和升级。</li></ul><div class="alert success"><p><code>Envoy</code> 以透明的方式弥合了面向服务的体系结构使用多个应用程序框架和语言的情况。</p></div><p>3.<code>Mixer</code><br><code>Mixer</code> 是一个独立于平台的组件，负责在服务网格上执行<strong>访问控制</strong>和<strong>使用策略</strong>，并从 <code>Envoy</code> 代理和其他服务收集遥测数据，代理提取请求级属性，发送到 <code>Mixer</code> 进行评估。有关属性提取和策略评估的更多信息，请参见 <code>Mixer</code> 配置。</p><p><code>Mixer</code> 中包括一个灵活的插件模型，使其能够接入到各种主机环境和基础设施后端，从这些细节中抽象出 <code>Envoy</code> 代理和 <code>Istio</code> 管理的服务。</p><p>4.<code>Pilot</code><br>控制面中负责流量管理的组件为 <code>Pilot</code>，它为 <code>Envoy Sidecar</code> 提供服务发现功能，为智能路由（例如 <code>A/B</code> 测试、金丝雀部署等）和弹性（超时、重试、熔断器等）提供流量管理功能。它将控制流量行为的高级路由规则转换为特定于 <code>Envoy</code> 的配置，并在运行时将它们传播到 <code>Sidecar</code>。</p><p>5.<code>Istio</code> 如何保证服务通信的安全？</p><ul><li><p><code>Istio</code> 以可扩缩的方式管理微服务间通信的<strong>身份验证、授权和加密</strong>。<code>Istio</code> 提供基础的安全通信渠道，使开发者可以专注于<strong>应用层级</strong>的安全。</p></li><li><p><code>Istio</code> 可以<strong>增强微服务及其通信</strong>（包括服务到服务和最终用户到服务的通信）的安全性，且不需要更改服务代码。</p><div class="alert info"><p>它为每个服务提供基于角色的强大身份机制，以实现跨集群、跨云端的互操作性。</p></div></li></ul><ul><li><p>如果我们结合使用 <code>Istio</code> 与 <code>Kubernetes</code>（或基础架构）网络政策，<code>Pod</code> 到 <code>Pod</code> 或服务到服务的通信在网络层和应用层都将安全无虞。<code>Istio</code> 以 <code>Google</code> 的<strong>深度防御策略为基础</strong>构建而成，以确保微服务通信的安全。</p><div class="alert success"><p>当我们在 <code>Google Cloud</code> 中使用 <code>Istio</code> 时，<code>Google</code> 的基础架构可让我们构建真正安全的应用部署。</p></div></li><li><p><code>Istio</code> 可确保服务通信在默认情况下是安全的，并且我们可以<strong>跨不同协议和运行时一致地实施安全政策</strong>，而只需对应用稍作调整，甚至无需调整。</p></li></ul><h4 id="六、Envoy-进阶"><a href="#六、Envoy-进阶" class="headerlink" title="六、Envoy 进阶"></a>六、Envoy 进阶</h4><p><code>Istio</code> 使用 <code>Envoy</code> 代理的扩展版本，<code>Envoy</code> 是以 <code>C++</code> 开发的高性能代理，用于<strong>调解服务网格中所有服务的所有入站和出站流量</strong>。</p><p><code>Envoy</code> 的许多内置功能被 <code>Istio</code> 发扬光大，例如：</p><ul><li>动态服务发现</li><li>负载均衡</li><li><code>TLS</code> 终止</li><li><code>HTTP2 &amp; gRPC</code> 代理</li><li>熔断器</li><li>健康检查、基于百分比流量拆分的灰度发布</li><li>故障注入</li><li>丰富的度量指标</li></ul><p><code>Envoy</code> 分为主线程、工作线程、文件刷新线程，其中主线程就是负责工作线程和文件刷新线程的管理和调度。而工作线程主要负责监听、过滤和转发，工作线程里面会包含一个监听器，如果收到一个请求之后会通过过滤链来进行数据过滤。前面两个都是非阻塞的，唯一一个阻塞的是这种 <code>IO</code> 操作的，会不断地把内存里面一些缓存进行落盘。</p><p>总结来说，我们可以围绕如下 5 方面：</p><p><strong>1.服务的动态注册和发现</strong><br><div class="alert info"><p><code>Envoy</code> 可以选择使用一组分层的动态配置 <code>API</code> 来进行集中管理。</p></div></p><p>这些层为 <code>Envoy</code> 提供了动态更新，后端群集的主机、后端群集本身、<code>HTTP</code> 路由、侦听套接字和通信加密。为了实现更简单的部署，后端主机发现可以通过 <code>DNS</code> 解析 (甚至完全跳过) 完成，层也可以替换为静态配置文件。</p><p><strong>2.健康检查</strong><br>构建 <code>Envoy</code> 网格的建议方法是将<strong>服务发现</strong>视为最终一致的过程。 <code>Envoy</code> 包括一个运行状况检查子系统，该子系统可以选择对上游服务集群执行主动运行状况检查。</p><p>然后，<code>Envoy</code> 使用服务发现和运行状况检查信息的联合来确定健康的负载均衡服务器。<code>Envoy</code> 还支持通过<strong>异常检测子系统</strong>进行被动运行状况检查。</p><p><strong>3.高级负载均衡</strong><br><div class="alert warning"><p>分布式系统中不同组件之间的负载平衡是一个复杂的问题。</p></div></p><p>由于 <code>Envoy</code> 是一个独立的代理而不是库，因此它能够在一个位置实现<strong>高级负载平衡</strong>技术，并使任何应用程序都可以访问。</p><p>目前 <code>Envoy</code> 包括支持自动重试、断路、通过外部速率限制服务限制全局速率、请求隐藏和异常值检测。未来计划为 <code>Request Racing</code> 提供支持。</p><p><strong>4.前端/边缘系统代理支持</strong><br>虽然 <code>Envoy</code> 主要是为<strong>服务通信系统而设计</strong>的，但对前端/边缘系统也是很有用的，如：可观测性、管理、相同的服务发现和负载平衡算法等。</p><p><code>Envoy</code> 包含足够的功能，使其可用作大多数 <code>Web</code> 应用服务用例的边缘代理。这包括作为 <code>TLS</code> 的终点、<code>HTTP/1.1</code> 和 <code>HTTP/2</code> 支持, 以及 <code>HTTP L7</code> 路由。</p><p><strong>5.最好的观察统计能力</strong><br><code>Envoy</code> 的首要目标是使<strong>网络透明</strong>。但是在网络级别和应用程序级都无法避免的容易出现问题。<code>Envoy</code> 包含了对所有子系统的强有力的统计支持。 <code>statsd</code> 和其他兼容的数据提供程序是当前支持的统计接收器，插入不同的统计接收器也并不困难。</p><div class="alert info"><p><code>Envoy</code> 可以通过管理端口查看统计信息，还支持通过第三方供应商进行分布式追踪。</p></div><p>更多详情请参考：<a href="https://www.jianshu.com/p/a6f7f46683e1?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">什么是 <code>Envoy</code> ?</a></p><h4 id="七、方案畅想"><a href="#七、方案畅想" class="headerlink" title="七、方案畅想"></a>七、方案畅想</h4><div class="alert success"><p>应用上面的原理，我们可以有很多具体的方案应用于日常开发。</p></div><p><strong>1.方案一</strong>：应用 <code>Istio</code> 改造微服务<br>模仿在线书店的一个分类，显示一本书的信息。 页面上会显示一本书的描述，书籍的细节（<code>ISBN</code>、页数等），以及关于这本书的一些评论。</p><p><strong>应用的端到端架构：</strong><code>Bookinfo</code> 应用中的几个微服务是由不同的语言编写的。 这些服务对 <code>Istio</code> 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 <code>reviews</code> 服务具有多个版本。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/before.svg" alt="Bookinfo 架构图"></p><p><strong>用 <code>Istio</code> 改造后架构如下：</strong>要在 <code>Istio</code> 中运行这一应用，无需对应用自身做出任何改变。我们只需要把 <code>Envoy Sidecar</code> 注入到每个服务之中。最终的部署结果将如下图所示：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/after.svg" alt="Istio 改造后架构图"></p><p>所有的微服务都和 <code>Envoy Sidecar</code> 集成在一起，被集成服务所有的<strong>出入流量</strong>都被 <code>Sidecar</code> 所劫持，这样就为外部控制准备了所需的 <code>Hook</code>，然后就可以利用 <code>Istio</code> 控制平面为应用提供服务路由、遥测数据收集以及策略实施等功能。</p><p>更多细节，请移步 <a href="https://istio.io/latest/zh/docs/examples/bookinfo/" target="_blank" rel="noopener">官网示例</a>。</p><p><strong>2.方案二</strong>：用 <code>Istio</code> 改造 <code>CI/CD</code> 流程<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/istio/practice.png" alt="Istio 架构图"></p><p>对上述流程图简单解释一下：</p><ul><li>通过 <code>Docker</code> 对代码进行容器化处理；</li><li>通过 <code>Gitlab</code> 托管代码；</li><li><code>Jenkins</code> 监听 <code>Gitlab</code> 下的代码，触发自动构建，并执行 <code>Kustomize</code> 文件；</li><li><code>Kustomize</code> 通过配置文件，设置了 <code>Istio</code> 的配置（染色识别、流量分发），并启动 <code>K8s</code> 部署应用；</li><li>最终我们通过 <code>Rancher</code> 来对多容器进行界面化管理；</li><li>打开浏览器进行访问；</li></ul><p>看到这里，相信你也了解了，我们实现了一个<strong>前端多容器化部署</strong>的案例。它有什么意义呢？</p><ul><li>首先，当然是环境隔离了，研发每人一个容器开发，互不干扰；</li><li>其次，我们可以做很多小流量、灰度发布等事情；</li><li>自动化部署，一站式的流程体验；</li></ul><p>如果你对容器化还不太了解，请先看看前面两篇文章：<br><a href="http://jartto.wang/2020/07/04/learn-docker/"><code>Docker</code> 边学边用</a><br><a href="http://jartto.wang/2020/07/15/start-k8s/">一文了解 <code>Kubernetes</code></a></p><p><code>Istio</code> 还是有很多可圈可点的地方，相信看到这里你也有了更全面的认识。如果你想深入了解，不妨仔细研究官方示例，并且在实际项目中不断打磨。</p><h4 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h4><p><a href="https://istio.io/latest/zh/docs/concepts/what-is-istio/" target="_blank" rel="noopener">1.<code>Istio</code> 官网</a><br><a href="https://www.jianshu.com/p/a6f7f46683e1?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">2.什么是 <code>Envoy</code></a><br><a href="https://www.jianshu.com/p/27a742e349f7" target="_blank" rel="noopener">3.微服务之 <code>Service Mesh</code></a><br><a href="https://zhuanlan.zhihu.com/p/61901608" target="_blank" rel="noopener">4.什么是 <code>Service Mesh</code></a><br><a href="https://www.kubernetes.org.cn/3575.html" target="_blank" rel="noopener">5.<code>Istio</code> 如何连接、管理和保护微服务 2.0？</a><br><a href="https://blog.csdn.net/joke59/article/details/106725749" target="_blank" rel="noopener">6.在 <code>MOSN</code> 中玩转 <code>dubbo-go</code></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多企业都会面临从单体应用向微服务架构的转型，也会衍生出更多的分布式场景需求。随着规模和复杂度的不断增长，如何才能更好的理解、高效的管理&lt;strong&gt;服务网格&lt;/strong&gt;呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="istio" scheme="http://jartto.wang/tags/istio/"/>
    
      <category term="k8s" scheme="http://jartto.wang/tags/k8s/"/>
    
      <category term="service mesh" scheme="http://jartto.wang/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>一文了解 Kubernetes</title>
    <link href="http://jartto.wang/2020/07/15/start-k8s/"/>
    <id>http://jartto.wang/2020/07/15/start-k8s/</id>
    <published>2020-07-14T22:12:04.000Z</published>
    <updated>2020-07-15T00:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jartto.wang/2020/07/04/learn-docker/">上一节</a>我们着重讲解了 <code>Docker</code>，其实遗留了一个大问题。<code>Docker</code> 虽好用，但面对强大的集群，成千上万的容器，突然感觉不香了。<br><a id="more"></a><br>这时候就需要我们的主角 <code>Kubernetes</code> 上场了，先来了解一下 <code>K8s</code> 的基本概念，后面再介绍实践，由浅入深步步为营。</p><p><strong>关于 <code>K8s</code> 的基本概念，我们将会围绕如下七点展开：</strong><br>1.<code>Docker</code> 的管理痛点<br>2.什么是 <code>K8s</code>？<br>3.云架构 &amp; 云原生<br>4.<code>K8s</code> 架构原理<br>5.<code>K8s</code> 核心组件<br>6.<code>K8s</code> 的服务注册与发现<br>7.关键问题</p><h4 id="一、Docker-的管理痛点"><a href="#一、Docker-的管理痛点" class="headerlink" title="一、Docker 的管理痛点"></a>一、Docker 的管理痛点</h4><p>如果想要将 <code>Docker</code> 应用于庞大的业务实现，是存在困难的<strong>编排</strong>、<strong>管理</strong>和<strong>调度</strong>问题。于是，我们迫切需要一套管理系统，对 <code>Docker</code> 及容器进行更高级更灵活的管理。</p><p><code>Kubernetes</code> 应运而生！<code>Kubernetes</code>，名词源于希腊语，意为「舵手」或「飞行员」。<code>Google</code> 在 <code>2014</code> 年开源了 <code>Kubernetes</code> 项目，建立在 <code>Google</code> 在大规模运行生产工作负载方面拥有十几年的经验的基础上，结合了社区中最好的想法和实践。</p><div class="alert info"><p>K8s 是 Kubernetes 的缩写，用 8 替代了 「ubernete」，下文我们将使用简称。</p></div><h4 id="二、什么是-K8s-？"><a href="#二、什么是-K8s-？" class="headerlink" title="二、什么是 K8s ？"></a>二、什么是 K8s ？</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/k8s/intro.png" alt="K8s 介绍"><br><code>K8s</code> 是一个可移植的、可扩展的开源平台，用于<strong>管理容器化的工作负载和服务，可促进声明式配置和自动化</strong>。<code>K8s</code> 拥有一个庞大且快速增长的生态系统。<code>K8s</code> 的服务、支持和工具广泛可用。</p><p>通过 <code>K8s</code> 我们可以：<br>1.快速部署应用<br>2.快速扩展应用<br>3.无缝对接新的应用功能<br>4.节省资源，优化硬件资源的使用</p><p><code>K8s</code> 有如下特点:<br>1.可移植: 支持公有云，私有云，混合云，多重云 <code>multi-cloud</code><br>2.可扩展: 模块化，插件化，可挂载，可组合<br>3.自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展</p><h4 id="三、云架构-amp-云原生"><a href="#三、云架构-amp-云原生" class="headerlink" title="三、云架构 &amp; 云原生"></a>三、云架构 &amp; 云原生</h4><p>1.云和 <code>K8s</code> 是什么关系<br>云就是使用容器构建的一套服务集群网络，云由很多的大量容器构成。<code>K8s</code> 就是用来管理云中的容器。</p><p>2.常见几类云架构</p><ul><li><code>On-Premises</code> (本地部署)</li><li><code>iaas</code>（基础设施即服务）<ul><li>用户：租用（购买|分配权限）云主机，用户不需要考虑网络，<code>DNS</code>，硬件环境方面的问题。</li><li>运营商：提供网络，存储，<code>DNS</code>，这样服务就叫做基础设施服务</li></ul></li><li><code>paas</code>（平台即服务）<ul><li><code>mysql/es/mq/...</code></li></ul></li><li><code>saas</code>（软件即服务）<ul><li>钉钉</li><li>财务管理</li></ul></li><li><code>serverless</code><ul><li>无服务，不需要服务器。站在用户的角度考虑问题，用户只需要使用云服务器即可，在云服务器所在的基础环境，软件环境都不需要用户关心。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/k8s/iaas.png" alt="常见云架构图示"></p><p>如果觉得不好理解，推荐阅读这篇文章：<a href="https://www.zhihu.com/question/21641778/answer/62523535" target="_blank" rel="noopener">如何通俗解释 IaaS、PaaS、SaaS 的区别</a></p><div class="alert info"><p>可以预见：未来服务开发都是 Serverless，企业都构建了自己的私有云环境，或者是使用公有云环境。</p></div><p>3.云原生<br>为了让应用程序（项目，服务软件）都运行在云上的解决方案，这样的方案叫做<strong>云原生</strong>。</p><p>云原生有如下特点：</p><ul><li>容器化，所有服务都必须部署在容器中</li><li>微服务，<code>Web</code> 服务架构式服务架构</li><li><code>CI/CD</code></li><li><code>DevOps</code></li></ul><h4 id="四、K8s-架构原理"><a href="#四、K8s-架构原理" class="headerlink" title="四、K8s 架构原理"></a>四、K8s 架构原理</h4><p>1.<code>K8s</code> 架构<br>概括来说 <code>K8s</code> 架构就是一个 <code>Master</code> 对应一群 <code>Node</code> 节点。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/k8s/k8s.png" alt="K8s 架构图示"></p><p>下面我们来逐一介绍 <code>K8s</code> 架构图中的 <code>Master</code> 和 <code>Node</code>。</p><p>2.<code>Master</code> 节点结构如下：</p><ul><li><code>apiserver</code> 即 <code>K8s</code> 网关，所有的指令请求都必须要经过 <code>apiserver</code>；</li><li><code>scheduler</code> 调度器，使用调度算法，把请求资源调度到某一个 <code>node</code> 节点；</li><li><code>controller</code> 控制器，维护 <code>K8s</code> 资源对象；</li><li><code>etcd</code> 存储资源对象；</li></ul><p>3.<code>Node</code>节点</p><ul><li><code>kubelet</code> 在每一个 <code>node</code> 节点都存在一份，在 <code>node</code> 节点上的资源操作指令由 <code>kubelet</code> 来执行；</li><li><code>kube-proxy</code> 代理服务，处理服务间负载均衡；</li><li><code>pod</code> 是 <code>k8s</code> 管理的基本单元（最小单元），<code>pod</code> 内部是容器，<code>k8s</code> 不直接管理容器，而是管理<code>pod</code>；</li><li><code>docker</code> 运行容器的基础环境，容器引擎；</li><li><code>fluentd</code> 日志收集服务；</li></ul><p>在介绍完 <code>K8s</code> 架构后，我们又引入了很多技术名词。不要着急，先有<strong>整体概念，再各个击破</strong>。请耐心<a href="http://jartto.wang/2020/07/15/start-k8s/">阅读下文</a>，相信你一定会有不一样的收获。</p><h4 id="五、K8s-核心组件"><a href="#五、K8s-核心组件" class="headerlink" title="五、K8s 核心组件"></a>五、K8s 核心组件</h4><p>1.<code>K8s</code> 组件<br><code>K8s</code> 是用来管理容器，但是不直接操作容器，最小操作单元是 <code>Pod</code> （间接管理容器）</p><ul><li>一个 <code>Master</code> 有一群 <code>Node</code> 节点与之对应</li><li><code>Master</code> 节点不存储容器，只负责调度、网管、控制器、资源对象存储</li><li>容器的存储在 <code>Node</code> 节点，容器是存储在 <code>Pod</code> 内部的）</li><li><code>Pod</code> 内部可以有一个容器，或者多个容器</li><li><code>Kubelet</code> 负责本地 <code>Pod</code> 的维护</li><li><code>Kube-proxy</code> 负责负载均衡，在多个 <code>Pod</code> 之间来做负载均衡</li></ul><p>2.<code>Pod</code> 是什么？</p><ul><li><code>pod</code> 也是一个容器，这个容器中装的是 <code>Docker</code> 创建的容器，<code>Pod</code> 用来封装容器的一个容器，<code>Pod</code> 是一个虚拟化分组；</li><li><code>Pod</code> 相当于独立主机，可以封装一个或者多个容器；</li></ul><div class="alert success"><p>Pod 有自己的 IP 地址、主机名，相当于一台独立沙箱环境。</p></div><p>3.<code>Pod</code> 到底用来干什么？<br>通常情况下，在服务部署时候，使用 <code>Pod</code> 来管理一组相关的服务。一个 <code>Pod</code> 中要么部署一个服务，要么部署一组有关系的服务。</p><div class="alert warning"><p>一组相关的服务是指：在链式调用的调用连路上的服务。</p></div><p>4.<code>Web</code> 服务集群如何实现？<br>实现服务集群：只需要复制多方 <code>Pod</code> 的副本即可，这也是 <code>K8s</code> 管理的先进之处，<code>K8s</code> 如果继续扩容，只需要控制 <code>Pod</code> 的数量即可，缩容道理类似。</p><p>5.<code>Pod</code> 底层网络，数据存储是如何进行的？</p><ul><li><code>Pod</code> 内部容器创建之前，必须先创建 <code>Pause</code> 容器；</li><li>服务容器之间访问 <code>localhost</code> ，相当于访问本地服务一样，性能非常高；</li></ul><p>6.<code>ReplicaSet</code> 副本控制器<br>控制 <code>Pod</code> 副本「服务集群」的数量，永远与预期设定的数量保持一致即可。当有 <code>Pod</code> 服务宕机时候，副本控制器将会立马重新创建一个新的 <code>Pod</code>，永远保证副本为设置数量。</p><p>副本控制器：标签选择器-选择维护一组相关的服务（它自己的服务）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector：</span><br><span class="line">    app = web</span><br><span class="line">    Release = stable</span><br></pre></td></tr></table></figure></p><ul><li>ReplicationController 副本控制器：单选</li><li>ReplicaSet 副本控制器：单选，复合选择</li></ul><div class="alert danger"><p>在新版的 <code>K8s</code> 中，建议使用 <code>ReplicaSet</code> 作为副本控制器，<code>ReplicationController</code> 不再使用了。</p></div><p>7.<code>Deployment</code> 部署对象</p><ul><li>服务部署结构模型</li><li>滚动更新</li></ul><p><code>ReplicaSet</code> 副本控制器控制 <code>Pod</code> 副本的数量。但是，项目的需求在不断迭代、不断的更新，项目版本将会不停的的发版。版本的变化，如何做到服务更新？</p><p>部署模型：</p><ul><li><code>ReplicaSet</code> 不支持滚动更新，<code>Deployment</code> 对象支持滚动更新，通常和 <code>ReplicaSet</code> 一起使用；</li><li><code>Deployment</code> 管理 <code>ReplicaSet</code>，<code>RS</code> 重新建立新的 <code>RS</code>，创建新的 <code>Pod</code>；</li></ul><p>8.<code>MySQL</code> 使用容器化部署，存在什么样的问题？</p><ul><li>容器是生命周期的，一旦宕机，数据丢失</li><li><code>Pod</code> 部署，<code>Pod</code> 有生命周期，数据丢失</li></ul><div class="alert danger"><p>对于 K8s 来说，不能使用 Deployment 部署<strong>有状态</strong>服务。</p></div><p>通常情况下，<code>Deployment</code> 被用来部署无状态服务，那么对于有状态服务的部署，使用 <code>StatefulSet</code> 进行有状态服务的部署。</p><p>什么是<strong>有状态服务</strong>？</p><ul><li>有实时的数据需要存储</li><li>有状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，如果集群网络无法使用</li></ul><p>什么是<strong>无状态服务</strong>？</p><ul><li>没有实时的数据需要存储</li><li>无状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，对集群服务没有任何影响</li></ul><p>9.<code>StatefulSet</code><br>为了解决有状态服务使用容器化部署的一个问题。</p><ul><li>部署模型</li><li>有状态服务</li></ul><p><code>StatefulSet</code> 保证 <code>Pod</code> 重新建立后，<code>Hostname</code> 不会发生变化，<code>Pod</code> 就可以通过 <code>Hostname</code> 来关联数据。</p><h4 id="六、K8s-的服务注册与发现"><a href="#六、K8s-的服务注册与发现" class="headerlink" title="六、K8s 的服务注册与发现"></a>六、K8s 的服务注册与发现</h4><p><strong>1.<code>Pod</code> 的结构是怎样的？</strong></p><ul><li><code>Pod</code> 相当于一个容器，<code>Pod</code> 有独立 <code>IP</code> 地址，也有自己的 <code>Hostname</code>，利用 <code>Namespace</code> 进行资源隔离，独立沙箱环境。</li><li><code>Pod</code> 内部封装的是容器，可以封装一个，或者多个容器（通常是一组相关的容器）</li></ul><p><strong>2.<code>Pod</code> 网络</strong></p><ul><li><code>Pod</code> 有自己独立的 <code>IP</code> 地址</li><li><code>Pod</code> 内部容器之间访问采用 <code>Localhost</code> 访问</li></ul><div class="alert info"><p>Pod 内部容器访问是 Localhost，Pod 之间的通信属于远程访问。</p></div><p><strong>3.<code>Pod</code> 是如何对外提供服务访问的？</strong><br><code>Pod</code> 是虚拟的资源对象（进程），没有对应实体（物理机，物理网卡）与之对应，无法直接对外提供服务访问。</p><p>那么该<strong>如何解决这个问题</strong>呢？<br><code>Pod</code> 如果想要对外提供服务，必须绑定物理机端口。也就是说在物理机上开启端口，让这个端口和 <code>Pod</code> 的端口进行映射，这样就可以通过物理机进行数据包的转发。</p><div class="alert success"><p>概括来说：先通过物理机 IP + Port 进行访问，再进行数据包转发。</p></div><p><strong>4.一组相关的 <code>Pod</code> 副本，如何实现访问负载均衡？</strong><br>我们先明确一个概念，<code>Pod</code> 是一个进程，是有<strong>生命周期</strong>的。宕机、版本更新，都会创建新的 <code>Pod</code>。这时候 <code>IP</code> 地址会发生变化，<code>Hostname</code> 会发生变化，使用 <code>Nginx</code> 做负载均衡就不太合适了。</p><p>所以我们需要依赖 <code>Service</code> 的能力。</p><p><strong>5.<code>Service</code> 如何实现负载均衡？</strong><br>简单来说，<code>Service</code> 资源对象包括如下三部分：</p><ul><li><code>Pod IP</code>：<code>Pod</code> 的 <code>IP</code> 地址</li><li><code>Node IP</code>：物理机 <code>IP</code> 地址</li><li><code>Cluster IP</code>：虚拟 <code>IP</code> ，是由 <code>K8s</code> 抽象出的 <code>Service</code> 对象，这个 <code>Service</code> 对象就是一个 <code>VIP</code> 的资源对象</li></ul><p><strong>6.<code>Service VIP</code> 更深入原理探讨</strong></p><ul><li><code>Service</code> 和 <code>Pod</code> 都是一个进程，<code>Service</code> 也不能对外网提供服务；</li><li><code>Service</code> 和 <code>Pod</code> 之间可以直接进行通信，它们的通信属于局域网通信；</li><li>把请求交给 <code>Service</code> 后，<code>Service</code> 使用 <code>iptable</code>，<code>ipvs</code> 做数据包的分发；</li></ul><p><strong>7.<code>Service</code> 对象是如何和 <code>Pod</code> 进行关联的？</strong></p><ul><li>不同的业务有不同的 <code>Service</code>；</li><li><code>Service</code> 和 <code>Pod</code> 通过标签选择器进行关联；  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector：</span><br><span class="line">    app=x 选择一组订单的服务 pod ，创建一个 service；</span><br><span class="line">    通过 endpoints 存放一组 pod ip；</span><br></pre></td></tr></table></figure></li></ul><p><code>Service</code> 通过标签选择器选择一组相关的副本，然后创建一个 <code>Service</code>。</p><p><strong>8.<code>Pod</code> 宕机、发布新的版本的时候，<code>Service</code> 如何发现 <code>Pod</code> 已经发生了变化？</strong><br>每个 <code>Pod</code> 中都有 <code>Kube-Proxy</code>，监听所有 <code>Pod</code>。如果发现 <code>Pod</code> 有变化，就动态更新（<code>etcd</code> 中存储）对应的 <code>IP</code> 映射关系。</p><h4 id="七、关键问题"><a href="#七、关键问题" class="headerlink" title="七、关键问题"></a>七、关键问题</h4><p><strong>1.企业使用 <code>K8s</code> 主要用来做什么？</strong></p><ul><li><p><strong>自动化运维平台</strong><br>创业型公司，中小型企业，使用 <code>K8s</code> 构建一套自动化运维平台，自动维护服务数量，保持服务永远和预期的数据保持一致性，让服务可以永远提供服务。这样最直接的好处就是降本增效。</p></li><li><p><strong>充分利用服务器资源</strong><br>互联网企业，有很多服务器资源「物理机」，为了充分利用服务器资源，使用 <code>K8s</code> 构建私有云环境，项目运行在云。<strong>这在大型互联网公司尤为重要</strong>。</p></li><li><p><strong>服务的无缝迁移</strong><br>项目开发中，产品需求不停的迭代，更新产品。这就意味着项目不停的发布新的版本，而 <code>K8s</code> 可以实现项目从开发到生产无缝迁移。</p></li></ul><p><strong>2.<code>K8s</code> 服务的负载均衡是如何实现的？</strong><br><code>Pod</code> 中的容器很可能因为各种原因发生故障而死掉。<code>Deployment</code> 等 <code>Controller</code> 会通过动态创建和销毁 <code>Pod</code> 来保证应用整体的健壮性。换句话说，<code>Pod</code> 是脆弱的，但应用是健壮的。每个 <code>Pod</code> 都有自己的 <code>IP</code> 地址。当 <code>controller</code> 用新 <code>Pod</code> 替代发生故障的 <code>Pod</code> 时，新 <code>Pod</code> 会分配到新的 <code>IP</code> 地址。</p><p>这样就产生了一个问题：如果一组 <code>Pod</code> 对外提供服务（比如 <code>HTTP</code>），它们的 <code>IP</code> 很有可能发生变化，那么客户端如何找到并访问这个服务呢？</p><p><code>K8s</code> 给出的解决方案是 <code>Service</code>。 <code>Kubernetes Service</code> 从逻辑上代表了一组 <code>Pod</code>，具体是哪些 <code>Pod</code> 则是由 <code>Label</code> 来挑选。</p><p><code>Service</code> 有自己 <code>IP</code>，而且这个 <code>IP</code> 是不变的。客户端只需要访问 <code>Service</code> 的 <code>IP</code>，<code>K8s</code> 则负责建立和维护 <code>Service</code> 与 <code>Pod</code> 的映射关系。无论后端 <code>Pod</code> 如何变化，对客户端不会有任何影响，因为 <code>Service</code> 没有变。</p><p><strong>3.无状态服务一般使用什么方式进行部署？</strong><br><code>Deployment</code> 为 <code>Pod</code> 和 <code>ReplicaSet</code> 提供了一个 声明式定义方法，通常被用来部署无状态服务。</p><p><code>Deployment</code> 的主要作用：<br>定义 <code>Deployment</code> 来创建 <code>Pod</code> 和 <code>ReplicaSet</code> 滚动升级和回滚应用扩容和索容暂停和继续。<code>Deployment</code>不仅仅可以滚动更新，而且可以进行回滚，如果发现升级到 <code>V2</code> 版本后，服务不可用，可以迅速回滚到 <code>V1</code> 版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://jartto.wang/2020/07/04/learn-docker/&quot;&gt;上一节&lt;/a&gt;我们着重讲解了 &lt;code&gt;Docker&lt;/code&gt;，其实遗留了一个大问题。&lt;code&gt;Docker&lt;/code&gt; 虽好用，但面对强大的集群，成千上万的容器，突然感觉不香了。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="docker" scheme="http://jartto.wang/tags/docker/"/>
    
      <category term="k8s" scheme="http://jartto.wang/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker 边学边用</title>
    <link href="http://jartto.wang/2020/07/04/learn-docker/"/>
    <id>http://jartto.wang/2020/07/04/learn-docker/</id>
    <published>2020-07-04T14:10:13.000Z</published>
    <updated>2020-07-09T23:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>富 <code>Web</code> 时代，应用变得越来越强大，与此同时也越来越复杂。集群部署、隔离环境、灰度发布以及动态扩容缺一不可，而容器化则成为中间的必要桥梁。<br><a id="more"></a><br>本节我们就来探索一下 <code>Docker</code> 的神秘世界，从零到一掌握 <code>Docker</code> 的基本原理与实践操作。别再守着前端那一亩三分地，是时候该开疆扩土了。</p><p>我们将会围绕下面几点展开：<br>1.讲个故事<br>2.虚拟机与容器<br>3.认识 <code>Docker</code><br>4.核心概念<br>5.安装 <code>Docker</code><br>6.快速开始<br>7.常规操作<br>8.最佳实践</p><h4 id="一、讲个故事"><a href="#一、讲个故事" class="headerlink" title="一、讲个故事"></a>一、讲个故事</h4><p>为了更好的理解 <code>Docker</code> 是什么，我们先来讲个<a href="https://my.oschina.net/jamesview/blog/2994112" target="_blank" rel="noopener">故事</a>：</p><p>我需要盖一个房子，于是我搬石头、砍木头、画图纸、盖房子。一顿操作，终于把这个房子盖好了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/store1.png" alt="盖房子"></p><p>结果，住了一段时间，心血来潮想搬到海边去。这时候按以往的办法，我只能去海边，再次搬石头、砍木头、画图纸、盖房子。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/store2.png" alt="重复盖房"></p><p>烦恼之际，跑来一个魔法师教会我一种魔法。这种魔法可以把我盖好的房子复制一份，做成「镜像」，放在我的背包里。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/store3.png" alt="黑魔法"></p><p>等我到了海边，就用这个「镜像」，复制一套房子，拎包入住。</p><p>是不是很神奇？对应到我们的项目中来，房子就是项目本身，镜像就是项目的复制，背包就是镜像仓库。如果要动态扩容，从仓库中取出项目镜像，随便复制就可以了。Build once，Run anywhere!</p><div class="alert info"><p>不用再关注版本、兼容、部署等问题，彻底解决了「上线即崩，无休止构建」的尴尬。</p></div><h4 id="二、虚拟机与容器"><a href="#二、虚拟机与容器" class="headerlink" title="二、虚拟机与容器"></a>二、虚拟机与容器</h4><p>开始之前，我们来做一些基础知识的储备：</p><p>1.<strong>虚拟机</strong>：虚拟化硬件<br>虚拟机 <code>Virtual Machine</code> 指通过软件模拟的<strong>具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</strong>。在实体计算机中能够完成的工作在虚拟机中都能够实现。</p><p>在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。<strong>每个虚拟机都有独立的 <code>CMOS</code>、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作</strong>。在容器技术之前，业界的网红是虚拟机。</p><p>虚拟机技术的代表，是 <code>VMWare</code> 和 <code>OpenStack</code>。更多请参看<a href="https://baike.baidu.com/item/虚拟机/104440?fr=aladdin" target="_blank" rel="noopener">百科虚拟机</a>。</p><p>2.<strong>容器</strong>：将操作系统层虚拟化，是一个标准的软件单元</p><ul><li>随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。</li><li>高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 <code>CPU</code> 和内存的使用率，进而更好地利用服务器的计算资源。</li><li>快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。</li></ul><p>3.<strong>区别与联系</strong></p><ul><li>虚拟机虽然可以隔离出很多「子电脑」，但占用空间更大，启动更慢。虚拟机软件可能还要花钱，例如<code>VMWare</code>；</li><li>容器技术不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境，类似「沙箱」；</li><li>运行空间，虚拟机一般要几 <code>GB</code> 到 几十 <code>GB</code> 的空间，而容器只需要 <code>MB</code> 级甚至 <code>KB</code> 级；</li></ul><p>我们来看一下对比数据：</p><table><thead><tr><th>特性</th><th style="text-align:center">虚拟机</th><th style="text-align:center">容器</th></tr></thead><tbody><tr><td>隔离级别</td><td style="text-align:center">操作系统级</td><td style="text-align:center">进程</td></tr><tr><td>隔离策略</td><td style="text-align:center"><a href="https://baike.baidu.com/item/hypervisor/3353492?fr=aladdin" target="_blank" rel="noopener">Hypervisor</a>（虚拟机监控器）</td><td style="text-align:center"><a href="https://baike.baidu.com/item/Cgroup/4988200?fr=aladdin" target="_blank" rel="noopener">Cgroups</a>（控制组群）</td></tr><tr><td>系统资源</td><td style="text-align:center">5 ～ 15%</td><td style="text-align:center">0 ～ 5%</td></tr><tr><td>启动时间</td><td style="text-align:center">分钟级</td><td style="text-align:center">秒级</td></tr><tr><td>镜像存储</td><td style="text-align:center">GB - TB</td><td style="text-align:center">KB - MB</td></tr><tr><td>集群规模</td><td style="text-align:center">上百</td><td style="text-align:center">上万</td></tr><tr><td>高可用策略</td><td style="text-align:center">备份、容灾、迁移</td><td style="text-align:center">弹性、负载、动态</td></tr></tbody></table><p>与虚拟机相比，容器更轻量且速度更快，因为它利用了 <code>Linux</code> 底层操作系统在隔离的环境中运行。虚拟机的 <code>Hypervisor</code> 创建了一个非常牢固的边界，以防止应用程序突破它，而容器的边界不那么强大。</p><p>物理机部署不能充分利用资源，造成资源浪费。虚拟机方式部署，虚拟机本身会占用大量资源，导致资源浪费，另外虚拟机性能也很差。而容器化部署比较灵活，且轻量级，性能较好。</p><div class="alert info"><p>虚拟机属于虚拟化技术，而 Docker 这样的容器技术，属于轻量级的虚拟化。</p></div><h4 id="三、认识-Docker"><a href="#三、认识-Docker" class="headerlink" title="三、认识 Docker"></a>三、认识 Docker</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/docker.png" alt="Docker"><br><strong>1.概念</strong><br><code>Docker</code> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p><code>Docker</code> 技术的<strong>三大核心概念</strong>，分别是：镜像 <code>Image</code>、容器 <code>Container</code>、仓库 <code>Repository</code>。</p><p><strong>2.<code>Docker</code> 轻量级的原因？</strong><br>相信你也会有这样的疑惑：为什么 <code>Docker</code> 启动快？如何做到和宿主机共享内核？</p><p>当我们请求 <code>Docker</code> 运行容器时，<code>Docker</code> 会在计算机上设置一个资源隔离的环境。然后将打包的应用程序和关联的文件复制到 <code>Namespace</code> 内的文件系统中，此时环境的配置就完成了。之后 <code>Docker</code> 会执行我们预先指定的命令，运行应用程序。</p><div class="alert warning"><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></div><h4 id="四、核心概念"><a href="#四、核心概念" class="headerlink" title="四、核心概念"></a>四、核心概念</h4><p>1.<code>Build, Ship and Run</code>（搭建、运输、运行）；</p><p>2.<code>Build once, Run anywhere</code>（一次搭建，处处运行）；</p><p>3.<code>Docker</code> 本身并不是容器，它是创建容器的工具，是应用容器引擎；</p><p>4.<code>Docker</code> 三大核心概念，分别是：镜像 <code>Image</code>，容器 <code>Container</code>、仓库 <code>Repository</code>；</p><p>5.<code>Docker</code> 技术使用 <code>Linux</code> 内核和内核功能（例如 <code>Cgroups</code> 和 <code>namespaces</code>）来分隔进程，以便各进程相互独立运行。</p><p>6.由于 <code>Namespace</code> 和 <code>Cgroups</code> 功能仅在 <code>Linux</code> 上可用，因此容器无法在其他操作系统上运行。那么 <code>Docker</code> 如何在 <code>macOS</code> 或 <code>Windows</code> 上运行？ <code>Docker</code> 实际上使用了一个技巧，并在非 <code>Linux</code> 操作系统上安装 <code>Linux</code> 虚拟机，然后在虚拟机内运行容器。</p><p>7.镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的<strong>运行时实例</strong>。</p><p>更多关于 <code>Docker</code> 的原理，可以查看<a href="http://dockone.io/article/8788" target="_blank" rel="noopener"> <code>Docker</code> 工作原理及容器化简易指南</a>，这里不再赘述。</p><h4 id="五、安装-Docker"><a href="#五、安装-Docker" class="headerlink" title="五、安装 Docker"></a>五、安装 Docker</h4><p><strong>1.命令行安装</strong><br><code>Homebrew</code> 的 <code>Cask</code> 已经支持 <code>Docker for Mac</code>，因此可以很方便的使用 <code>Homebrew Cask</code> 来进行安装，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure></p><p>更多安装方式，请查看官方文档：<a href="https://www.docker.com/get-started" target="_blank" rel="noopener">安装 <code>Docker</code></a></p><p><strong>2.查看版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></p><p><strong>3.配置镜像加速</strong><br>设置 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">Docker Engine</a> 写入配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;http://hub-mirror.c.163.com/&quot;,</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;:[],</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4.安装桌面端</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/first.png" alt="Docker 桌面端"><br>桌面端操作非常简单，先去<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">官网下载</a>。通过 <code>Docker</code> 桌面端，我们可以方便的操作：<br>1.clone：克隆一个项目<br>2.build：打包镜像<br>3.run：运行实例<br>4.share：共享镜像</p><p>好了，准备工作就绪，下面可以大展身手了！</p><h4 id="六、快速开始"><a href="#六、快速开始" class="headerlink" title="六、快速开始"></a>六、快速开始</h4><p>安装完 <code>Docker</code> 之后，我们先打个实际项目的镜像，边学边用。</p><p><strong>1.首先需要大致了解一下我们将会用到的 <code>11</code> 个命令</strong></p><table><thead><tr><th>命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>FROM</td><td style="text-align:left">基于哪个镜像来实现</td></tr><tr><td>MAINTAINER</td><td style="text-align:left">镜像创建者</td></tr><tr><td>ENV</td><td style="text-align:left">声明环境变量</td></tr><tr><td>RUN</td><td style="text-align:left">执行命令</td></tr><tr><td>ADD</td><td style="text-align:left">添加宿主机文件到容器里，有需要解压的文件会自动解压</td></tr><tr><td>COPY</td><td style="text-align:left">添加宿住机文件到容器里</td></tr><tr><td>WORKDIR</td><td style="text-align:left">工作目录</td></tr><tr><td>EXPOSE</td><td style="text-align:left">容器内应用可使用的端口</td></tr><tr><td>CMD</td><td style="text-align:left">容器启动后所执行的程序，如果执行 docker run 后面跟启动命令会被覆盖掉</td></tr><tr><td>ENTRYPOINT</td><td style="text-align:left">与 CMD 功能相同，但需 docker run 不会覆盖，如果需要覆盖可增加参数 -entrypoint 来覆盖</td></tr><tr><td>VOLUME</td><td style="text-align:left">数据卷，将宿主机的目录映射到容器中的目录</td></tr></tbody></table><p>2.<strong>新建项目</strong><br>为了快捷，我们直接使用<a href="https://cli.vuejs.org/guide/creating-a-project.html#vue-create" target="_blank" rel="noopener"><code>Vue</code> 脚手架</a>构建项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create docker-demo</span><br></pre></td></tr></table></figure></p><p>尝试启动一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn serve</span><br></pre></td></tr></table></figure></p><p>访问地址：<code>http://localhost:8080/</code>。项目就绪，我们接着为项目打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure></p><p>这时候，项目目录下的 <code>Dist</code> 就是我们要部署的静态资源了，我们继续下一步。</p><p><strong>需要注意</strong>：前端项目一般分两类，一类直接 <code>Nginx</code> 静态部署，一类需要启动 <code>Node</code> 服务。本节我们只考虑第一种。关于 <code>Node</code> 服务，<a href="#">下文</a>我会详细说明。</p><p>3.<strong>新建 <code>Dockerfile</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd docker-demo &amp;&amp; touch Dockerfile</span><br></pre></td></tr></table></figure></p><p>此时的项目目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── dist</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><p>可以看到我们已经在 <code>docker-demo</code> 目录下成功创建了 <code>Dockerfile</code> 文件。</p><p>4.<strong>准备 <code>Nginx</code> 镜像</strong><br>运行你的 <code>Docker</code> 桌面端，就会默认启动实例，我们在控制台拉取 <code>Nginx</code> 镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></p><p>控制台会出现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">8559a31e96f4: Pull complete</span><br><span class="line">8d69e59170f7: Pull complete</span><br><span class="line">3f9f1ec1d262: Pull complete</span><br><span class="line">d1f5ff4f210d: Pull complete</span><br><span class="line">1e22bfa8652e: Pull complete</span><br><span class="line">Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure></p><p>如果你出现这样的异常，请确认 <code>Docker</code> 实例是否正常运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure></p><p>镜像准备 <code>OK</code>，我们在根目录创建 <code>Nginx</code> 配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch default.conf</span><br></pre></td></tr></table></figure></p><p>写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line">    error_log  /var/log/nginx/error.log  error;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.<strong>配置镜像</strong><br>打开 <code>Dockerfile</code> ，写入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br><span class="line">COPY default.conf /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure></p><p>我们逐行解释一下代码：</p><ul><li><code>FROM nginx</code> 指定该镜像是基于 <code>nginx:latest</code> 镜像而构建的；</li><li><code>COPY dist/ /usr/share/nginx/html/</code> 命令的意思是将项目根目录下 <code>dist</code> 文件夹中的所有文件复制到镜像中 <code>/usr/share/nginx/html/</code> 目录下；</li><li><code>COPY default.conf /etc/nginx/conf.d/default.conf</code> 将 <code>default.conf</code> 复制到 <code>etc/nginx/conf.d/default.conf</code>，用本地的 <code>default.conf</code> 配置来替换 <code>Nginx</code> 镜像里的默认配置。</li></ul><p>6.<strong>构建镜像</strong><br><code>Docker</code> 通过 <code>build</code> 命令来构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t jartto-docker-demo .</span><br></pre></td></tr></table></figure></p><p>按照惯例，我们解释一下上述代码：</p><ul><li><code>-t</code> 参数给镜像命名 <code>jartto-docker-demo</code></li><li><code>.</code> 是基于当前目录的 <code>Dockerfile</code> 来构建镜像</li></ul><p>执行成功后，将会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  115.4MB</span><br><span class="line">Step 1/3 : FROM nginx</span><br><span class="line"> ---&gt; 2622e6cca7eb</span><br><span class="line">Step 2/3 : COPY dist/ /usr/share/nginx/html/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 82b31f98dce6</span><br><span class="line">Step 3/3 : COPY default.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"> ---&gt; 7df6efaf9592</span><br><span class="line">Successfully built 7df6efaf9592</span><br><span class="line">Successfully tagged jartto-docker-demo:latest</span><br></pre></td></tr></table></figure></p><p>镜像制作成功！我们来查看一下容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls | grep jartto-docker-demo</span><br></pre></td></tr></table></figure></p><p>可以看到，我们打出了一个 <code>133MB</code> 的项目镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jartto-docker-demo latest 7df6efaf9592 About a minute ago 133MB</span><br></pre></td></tr></table></figure></p><div class="alert warning"><p>镜像也有好坏之分，后续我们将介绍如何优化，这里可以先暂时忽略。</p></div><p>7.<strong>运行容器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:80 --name docker-vue jartto-docker-demo</span><br></pre></td></tr></table></figure></p><p>这里解释一下参数：</p><ul><li><code>-d</code> 设置容器在后台运行</li><li><code>-p</code> 表示端口映射，把本机的 <code>3000</code> 端口映射到 <code>container</code> 的 <code>80</code> 端口（这样外网就能通过本机的 <code>3000</code> 端口访问了</li><li><code>--name</code> 设置容器名 <code>docker-vue</code></li><li><code>jartto-docker-demo</code> 是我们上面构建的镜像名字</li></ul><p>补充一点：<br>在控制台，我们可以通过 <code>docker ps</code> 查看刚运行的 <code>Container</code> 的 <code>ID</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></p><p>控制台会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID IMAGE              COMMAND                  CREATED       STATUS PORTS  NAMES</span><br><span class="line">ab1375befb0b jartto-docker-demo &quot;/docker-entrypoint.…&quot;   8 minutes ago Up 7 minutes  0.0.0.0:3000-&gt;80/tcp  docker-vue</span><br></pre></td></tr></table></figure></p><p>如果你使用桌面端，那么打开 <code>Docker Dashboard</code> 就可以看到容器列表了，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/docker/desk.png" alt="Docker 桌面端"></p><p>8.<strong>访问项目</strong><br>因为我们映射了本机 <code>3000</code> 端口，所以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -i localhost:3000</span><br></pre></td></tr></table></figure></p><p>或者打开浏览器，访问：<code>localhost:3000</code></p><p>9.<strong>发布镜像</strong><br><div class="alert info"><p>如果你想为社区贡献力量，那么需要将镜像发布，方便其他开发者使用。</p></div></p><p>发布镜像需要如下步骤：</p><ul><li>登陆 <code>[dockerhub](https://hub.docker.com)</code>，注册账号；</li><li>命令行执行 <code>docker login</code>，之后输入我们的账号密码，进行登录；</li><li>推送镜像之前，需要打一个 <code>Tag</code>，执行 <code>docker tag &lt;image&gt; &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</code></li></ul><p>全流程结束，以后我们要使用，再也不需要「搬石头、砍木头、画图纸、盖房子」了，拎包入住。<strong>这也是 <code>docker</code> 独特魅力所在。</strong></p><h4 id="七、常规操作"><a href="#七、常规操作" class="headerlink" title="七、常规操作"></a>七、常规操作</h4><p>到这里，恭喜你已经完成了 <code>Docker</code> 的入门项目！如果还想继续深入，不妨接着往下看看。</p><p><strong>1.参数使用</strong></p><ul><li><p><code>FROM</code></p><ul><li>指定基础镜像，所有构建的镜像都必须有一个基础镜像，且 <code>FROM</code> 命令必须是 <code>Dockerfile</code> 的第一个命令</li><li><code>FROM &lt;image&gt; [AS &lt;name&gt;]</code> 指定从一个镜像构建起一个新的镜像名字</li><li><code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code>  指定镜像的版本 <code>Tag</code></li><li>示例：<code>FROM mysql:5.0  AS database</code></li></ul></li><li><p><code>MAINTAINER</code></p><ul><li>镜像维护人的信息</li><li><code>MAINTAINER  &lt;name&gt;</code></li><li>示例：<code>MAINTAINER  Jartto  Jartto@qq.com</code></li></ul></li><li><p><code>RUN</code></p><ul><li>构建镜像时要执行的命令</li><li><code>RUN &lt;command&gt;</code></li><li>示例：<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li></ul></li><li><p><code>ADD</code></p><ul><li>将本地的文件添加复制到容器中去，压缩包会解压，可以访问网络上的文件，会自动下载</li><li><code>ADD &lt;src&gt;  &lt;dest&gt;</code></li><li>示例：<code>ADD  *.js  /app</code> 添加 <code>js</code> 文件到容器中的 <code>app</code> 目录下</li></ul></li><li><code>COPY</code><ul><li>功能和 <code>ADD</code> 一样，只是复制，不会解压或者下载文件</li></ul></li><li><code>CMD</code><ul><li>启动容器后执行的命令，和 <code>RUN</code> 不一样，<code>RUN</code> 是在构建镜像是要运行的命令</li><li>当使用 <code>docker run</code> 运行容器的时候，这个可以在命令行被覆盖</li><li>示例：<code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li></ul></li><li><p><code>ENTRYPOINT</code></p><ul><li>也是执行命令，和 <code>CMD</code> 一样，只是这个命令不会被命令行覆盖</li><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li><li>示例：<code>ENTRYPOINT [&quot;donnet&quot;, &quot;myapp.dll&quot;]</code></li></ul></li><li><p><code>LABEL</code>：为镜像添加元数据，<code>key-value</code> 形式</p><ul><li><code>LABEL &lt;key&gt;=&lt;value&gt;  &lt;key&gt;=&lt;value&gt; ...</code> </li><li>示例：<code>LABEL version=&quot;1.0&quot;  description=&quot;这是一个web应用&quot;</code></li></ul></li><li><p><code>ENV</code>：设置环境变量，有些容器运行时会需要某些环境变量</p><ul><li><code>ENV  &lt;key&gt;  &lt;value&gt;</code> 一次设置一个环境变量</li><li><code>ENV  &lt;key&gt;=&lt;value&gt;  &lt;key&gt;=&lt;value&gt;  &lt;key&gt;=&lt;value&gt;</code> 设置多个环境变量</li><li>示例：<code>ENV  JAVA_HOME  /usr/java1.8/</code></li></ul></li><li><p><code>EXPOSE</code>：暴露对外的端口（容器内部程序的端口，虽然会和宿主机的一样，但是其实是两个端口）</p><ul><li><code>EXPOSE &lt;port&gt;</code></li><li>示例：<code>EXPOSE  80</code></li><li>容器运行时，需要用 <code>-p</code> 映射外部端口才能访问到容器内的端口</li></ul></li><li><code>VOLUME</code>：指定数据持久化的目录，官方语言叫做挂载<ul><li><code>VOLUME  /var/log</code> 指定容器中需要被挂载的目录，会把这个目录映射到宿主机的一个随机目录上，实现数据的持久化和同步。</li><li><code>VOLUME  [&quot;/var/log&quot;,&quot;/var/test&quot;.....]</code> 指定容器中多个需要被挂载的目录，会把这些目录映射到宿主机的多个随机目录上，实现数据的持久化和同步</li><li><code>VOLUME  /var/data  var/log</code> 指定容器中的 <code>var/log</code> 目录挂载到宿主机上的 <code>/var/data</code> 目录，这种形式可以手动指定宿主机上的目录</li></ul></li><li><code>WORKDIR</code>：设置工作目录，设置之后 ，<code>RUN、CMD、COPY、ADD</code> 的工作目录都会同步变更<ul><li><code>WORKDIR &lt;path&gt;</code></li><li>示例：<code>WORKDIR  /app/test</code></li></ul></li><li><code>USER</code>：指定运行命令时所使用的用户，为了安全和权限起见，根据要执行的命令选择不同用户<ul><li><code>USER  &lt;user&gt;:[&lt;group&gt;]</code></li><li>示例：<code>USER  test</code></li></ul></li><li><code>ARG</code>：设置构建镜像是要传递的参数<ul><li><code>ARG  &lt;name&gt;[=&lt;value&gt;]</code></li><li><code>ARG  name=sss</code></li></ul></li></ul><p>更多操作，请移步<a href="https://docs.docker.com" target="_blank" rel="noopener">官方使用文档</a>。</p><h4 id="八、最佳实践"><a href="#八、最佳实践" class="headerlink" title="八、最佳实践"></a>八、最佳实践</h4><p>在掌握 <code>Docker</code> 常规操作之后，我们很容易就可以打出自己想要的项目镜像。然而不同的操作打出的镜像也是千差万别。</p><div class="alert warning"><p>究竟是什么原因导致镜像差异，我们不妨继续探索。</p></div><p>以下是在应用 <code>Docker</code> 过程中整理的<strong>最佳实践</strong>，请尽量遵循如下准则：</p><p>1.<code>Require</code> 明确：需要什么镜像<br>2.步骤精简：变化较少的 <code>Step</code> 优先<br>3.版本明确：镜像命名明确<br>4.说明文档：整个镜像打包步骤可以重现</p><p>推荐如下两篇文章：<br><a href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/" target="_blank" rel="noopener">Intro Guide to Dockerfile Best Practices</a><br><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></p><h4 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h4><p>容器化技术必将是云时代不可或缺的技能之一，而 <code>Docker</code> 只是沧海一粟。随之而来的还有集群容器管理 <code>K8s</code>、<code>Service Mesh</code> 、<code>Istio</code> 等技术。打开 <code>Docker</code> 的大门，不断<strong>抽丝剥茧，逐层深入</strong>，你将感受到容器化的无穷魅力。</p><p>赶快打开技能边界，为你的前端技术赋能吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;富 &lt;code&gt;Web&lt;/code&gt; 时代，应用变得越来越强大，与此同时也越来越复杂。集群部署、隔离环境、灰度发布以及动态扩容缺一不可，而容器化则成为中间的必要桥梁。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="docker" scheme="http://jartto.wang/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>将博客搬至 CSDN</title>
    <link href="http://jartto.wang/2020/05/25/blog-to-csdn/"/>
    <id>http://jartto.wang/2020/05/25/blog-to-csdn/</id>
    <published>2020-05-25T07:33:44.000Z</published>
    <updated>2020-06-20T14:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好的服务小伙伴，本博客将同步至 <code>CSDN</code>，欢迎大家关注账号：<code>Jartto</code>。本站点内容均属原创，如有需求，请联系本人。<br><a id="more"></a><br>本站点依旧同步更新，欢迎持续关注，一起探索前端领域精彩内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更好的服务小伙伴，本博客将同步至 &lt;code&gt;CSDN&lt;/code&gt;，欢迎大家关注账号：&lt;code&gt;Jartto&lt;/code&gt;。本站点内容均属原创，如有需求，请联系本人。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="csdn" scheme="http://jartto.wang/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>WebP 方案分析与实践</title>
    <link href="http://jartto.wang/2020/05/02/webp-practice/"/>
    <id>http://jartto.wang/2020/05/02/webp-practice/</id>
    <published>2020-05-02T10:22:43.000Z</published>
    <updated>2020-06-21T22:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于网站来说，图片始终扮演着重要角色。图片大小直接影响网站速度、流量、运营成本以及用户体验。因此，减少图片大小成为网站优化最重要的一个环节。<br><a id="more"></a><br>如果你对优化还不甚了解，推荐阅读如下文章：<br>1.<a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a><br>2.<a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化工具</a><br>3.<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">CSS 渲染原理以及优化策略</a><br>4.<a href="http://jartto.wang/2020/03/15/about-web-fmp/">网站性能指标 - FMP</a><br>5.<a href="http://jartto.wang/2020/03/29/web-tti/">聚焦 Web 性能指标 TTI</a><br>6.<a href="http://jartto.wang/2020/04/05/about-wrk/">Web「性能测试」知多少？</a></p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>当我们在做网站性能优化的时候，减少图片大小，意味着减少了网络传输，提升了网站加载速度，而这部分也是性价比最高的。</p><p>我们可以通过压缩图片来减少体积，但压缩比例一直是前端开发和设计师争执的焦点。压缩比例大的话，可以有效减少图片体积，对页面加载有利，但是却损失了像素，是设计师无法容忍的。</p><p>在这种矛盾的场景下，我们既要最大程度的压缩图片又要保持足够的清晰，<code>WebP</code> 便应运而生。<br><div class="alert danger"><p>值得注意的是：WebP 并不是新技术，而是受限于兼容性而未全面普及。</p></div></p><h4 id="二、目标与意义"><a href="#二、目标与意义" class="headerlink" title="二、目标与意义"></a>二、目标与意义</h4><p>1.时间成本<br>我们先来看一组数据对比图，如果你做过 <code>Gif</code> 动图，你肯定知道下面这样的处理意义有多大：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/sample.png" alt="WebP 时间对比"></p><div class="alert success"><p>在肉眼无法识别差异的前提下，图片大小减少了 88%。</p></div><p>2.带宽成本</p><ul><li><code>YouTube</code> 的视频略缩图采用 <code>WebP</code> 格式后，网页加载速度提升了 <code>10%</code>；</li><li>谷歌的 <code>Chrome</code> 网上应用商店采用 <code>WebP</code> 格式图片后，每天可以节省几 <code>TB</code> 的带宽，页面平均加载时间大约减少 <code>1/3</code>；</li><li><code>Google+</code> 移动应用采用 <code>WebP</code> 图片格式后，每天节省了 <code>50TB</code> 数据存储空间。</li></ul><p>目前 <code>Google</code>、<code>Facebook</code>、阿里、京东的等国内外互联网公司广泛应用了 <code>WebP</code>，超过 <code>70%</code> 的浏览器已经支持 <code>WebP</code>。</p><h4 id="三、什么是-WebP-？"><a href="#三、什么是-WebP-？" class="headerlink" title="三、什么是 WebP ？"></a>三、什么是 WebP ？</h4><div class="alert info"><p>WebP 格式，谷歌开发的一种旨在加快图片加载速度的图片格式。</p></div><p>优势在于它具有<strong>更优的图像数据压缩算法</strong>，在拥有肉眼无法识别差异的图像质量前提下，带来<strong>更小的图片体积</strong>，同时具备了无损和有损的压缩模式、<code>Alpha</code> 透明以及动画的特性，在 <code>JPEG</code> 和 <code>PNG</code> 上的转化效果都非常优秀、稳定和统一。</p><p>在尝试一些技术前，我们必须要充分了解他的<strong>兼容性</strong>，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/caniuse.png" alt="WebP 兼容性"></p><p>可以看出来，绝大多数浏览器已经有了较好的支持。当然，除了 <code>Safari</code> 和 <code>IE</code>！我们来看看浏览器市场占有率吧：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/chrome.png" alt="浏览器市场占有率"></p><div class="alert warning"><p>Safari 和 Foxmail 也在进行支持 WebP 的测试。</p></div><h4 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h4><p><code>WebP</code> 看起来不错，那么它究竟适合什么样的场景呢？不着急，我们先来看下面的图例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/sence.png" alt="WebP 使用场景"></p><p>从上面我们可以看出，适合 <code>WebP</code> 场景的站点不外乎如下几种场景：<br>1.<strong>网站图片比重大</strong><br>如果你的网站 <code>80%</code> 甚至更多依赖图片资源，那么请使用 <code>WebP</code>，资源成本可以较少 <code>50%</code> 以上。</p><p>2.<strong>细节要求不高</strong><br>图片起到占位目的，不需要毛孔级别，那么请大胆使用！</p><p>3.<strong>流量运营推广</strong><br>运营推广都是抢占先机，我们不但要和竞品比拼用户，更要快速响应，提高转化率。</p><p>4.<strong>视频首图</strong><br>视频内容形式的网站，资源存储必是一大难题。如何做到稳准狠，速度必不可少，大量的视频占位图也便成为了重中之重。</p><h4 id="五、实践方案"><a href="#五、实践方案" class="headerlink" title="五、实践方案"></a>五、实践方案</h4><p>相信到这里，你已经对 <code>WebP</code> 有了足够的了解，快来看看实际项目中我们是如何使用的吧～</p><p><strong>方式一：<code>HTML5 Picture</code></strong><br><code>Picture</code> 元素允许我们在不同的设备上显示不同的图片，一般用于响应式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span> <span class="attr">srcset</span>=<span class="string">"images/jartto.webp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/jartto.jpg"</span> <span class="attr">alt</span>=<span class="string">“jartto’s</span> <span class="attr">demo</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>Picture</code> 算是最简单易行的方案了，但是需要注意以下两点：<br>1.兼容性，<code>IE</code> 不支持，可以查看<a href="https://caniuse.com/#search=picture" target="_blank" rel="noopener">Picutre Element</a>；<br>2.老项目迁移成本较大，需要改动每一个 <code>IMG</code> 资源，请尽可能封装成组件；</p><p><strong>方式二：<code>Webpack + Nginx</code></strong><br>此方案在 <code>Webpack</code> 打包过程生成了 <code>.webp</code> 格式的图片，通过 <code>Nginx</code> 检测浏览器 <code>Accept</code> 是否包含 <code>image/webp</code> 而进行动态转发。<br><div class="alert info"><p>完整格式：accept: image/webp,image/apng,image/<em>,</em>/*;q=0.8</p></div></p><p>1.项目引入 <code>Webpack</code> 插件 <code>imagemin-webp-webpack-plugin</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const ImageminWebpWebpackPlugin = require(&apos;imagemin-webp-webpack-plugin’);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">            new ImageminWebpWebpackPlugin(&#123;</span><br><span class="line">                config: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.(jpe?g|png)$/,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            quality: 60,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                overrideExtension: false,</span><br><span class="line">                detailedLogs: true,</span><br><span class="line">                strict: false</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><p>2.<code>Nginx</code> 配置<br>检测 <code>Accept</code> 头中是否含有 <code>WebP</code> 字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_accept</span> <span class="variable">$webp_suffix</span> &#123;</span><br><span class="line">    default   <span class="string">""</span>;</span><br><span class="line">    <span class="string">"~*webp"</span>  <span class="string">".webp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果浏览器支持 <code>WebP</code> 格式，那么我们就将 <code>.png</code> 或者 <code>.jpg</code> 格式图片转发到 <code>.webp</code> 格式下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location  ~* ^/_nuxt/img/(.+\.png|jpe?g)$ &#123;</span><br><span class="line">    rewrite ^/_nuxt/img/(.+\.png|jpe?g)$ /<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    root /apps/srv/instance/<span class="built_in">test</span>-webp.jartto.wang/.nuxt/dist/client/img/;</span><br><span class="line">    add_header Vary Accept;</span><br><span class="line">    try_files <span class="variable">$uri</span><span class="variable">$webp_suffix</span> <span class="variable">$uri</span> =404;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置完 <code>Nginx</code> 转发规则后，记得 <code>Reload Nginx</code>。刷新浏览器，这时候浏览器中的图片 <code>Type</code> 类型已经变成了 <code>WebP</code> 格式。</p><p><strong>方式三：服务端 <code>Nginx PageSpeed</code> 模块</strong><br><code>Google</code> 开发的 <code>PageSpeed</code> 模块有一个功能，会自动将图像转换成 <code>WebP</code> 格式或者是浏览器所支持的其它格式。<br><div class="alert info"><p>安装 Nginx 模块请查看文档：<a href="https://www.modpagespeed.com/doc/build_ngx_pagespeed_from_source#dependencies" target="_blank" rel="noopener">Build ngx_pagespeed From Source</a></p></div></p><p>安装成功之后，需要在 <code>Nginx Config</code> 中添加如下内容：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pagespeed</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">pagespeed</span> FileCachePath <span class="string">"/var/cache/ngx_pagespeed/"</span>;</span><br><span class="line"><span class="comment"># pagespeed RewriteLevel OptimizeForBandwidth;</span></span><br><span class="line"><span class="attribute">pagespeed</span> XHeaderValue <span class="string">"Powered By Jartto"</span>;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_gif_to_png;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_png_to_jpeg;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_jpeg_to_webp;</span><br><span class="line"><span class="attribute">pagespeed</span> ImageRecompressionQuality <span class="number">10</span>;</span><br><span class="line"><span class="comment"># pagespeed EnableFilters convert_jpeg_to_progressive;</span></span><br><span class="line"><span class="comment"># pagespeed EnableFilters inline_images;</span></span><br><span class="line"></span><br><span class="line">location ~ "\.pagespeed\.([a-z]\.)?[a-z]&#123;2&#125;\.[^.]&#123;10&#125;\.[^.]+" &#123;</span><br><span class="line"><span class="attribute">add_header</span> <span class="string">""</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ "^/pagespeed_static/"</span> &#123; &#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ "^/ngx_pagespeed_beacon$"</span> &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>看起来此方案是最佳选择，既没有前端代码侵入，也不需要各种嗅探，服务端一个模块就搞定了。需要注意的是，当我们享受便利的同时，<strong>一定要明确具体的原理，多维度思考</strong>。</p><p>既然在服务端完成 <code>WebP</code> 格式的转化，那么一定要注意此操作对服务器的性能损耗。我们不妨试一下，通过 <code>Wrk</code> 对服务器施压，看一下服务器的并发性能。</p><p>具体的压测过程就不细说了，感兴趣的童鞋可以查看：<a href="http://jartto.wang/2020/04/05/about-wrk/">Web 性能测试</a>。我们直接上结论：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/nginx.png" alt="Nginx CPU"></p><p><strong>相比转码，相同 <code>QPS</code> 下 <code>Nginx</code> 对 <code>CPU</code> 的使用上升了 <code>70%</code>，页面提升时间在毫秒量级，性价比不高</strong>。</p><p><strong>方式四：<code>Nginx + Lua（OpenResty）</code></strong><br>先来科普一下：<code>OpenResty</code> 是一个强大的 <code>Web</code> 应用服务器，<code>Web</code> 开发人员可以使用 <code>Lua</code> 脚本语言调动 <code>Nginx</code> 支持的各种 <code>C</code> 以及 <code>Lua</code> 模块，更主要的是在性能方面，<code>OpenResty</code> 可以快速构造出足以胜任 <code>10K</code> 以上并发连接响应的超高性能 <code>Web</code> 应用系统。</p><p><code>Lua</code> 是一种轻量小巧的脚本语言，用标准 <code>C</code> 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>1.编写 <code>Lua</code> 脚本</strong><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">file_exists</span><span class="params">(name)</span></span></span><br><span class="line">   <span class="keyword">local</span> f=<span class="built_in">io</span>.<span class="built_in">open</span>(name,<span class="string">"r"</span>)</span><br><span class="line">   <span class="keyword">if</span> f~=<span class="literal">nil</span> <span class="keyword">then</span> <span class="built_in">io</span>.<span class="built_in">close</span>(f) <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> newFile = ngx.var.request_filename;</span><br><span class="line"><span class="keyword">local</span> originalFile = newFile:<span class="built_in">sub</span>(<span class="number">1</span>, #newFile - <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> file_exists(originalFile) <span class="keyword">then</span></span><br><span class="line">  ngx.<span class="built_in">exit</span>(<span class="number">404</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">"cwebp -q 75 "</span> .. originalFile  .. <span class="string">" -o "</span> .. newFile);</span><br><span class="line"><span class="keyword">if</span> file_exists(newFile) <span class="keyword">then</span></span><br><span class="line">    ngx.exec(ngx.var.uri)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>不考虑学习成本的话，<code>Nginx + Lua</code> 将会是最好的选择。</p><p><strong>2.配置 <code>Nginx</code> 文件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http 中加入，lua 脚本的搜索路径</span></span><br><span class="line">lua_package_path <span class="string">"/usr/local/openresty/nginx/conf/jartto/?.lua;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># server 中配置 location</span></span><br><span class="line">location /images &#123;</span><br><span class="line">  expires 365d;</span><br><span class="line">  <span class="comment"># 如果不存在，则通过 @webp 进行内部重定向</span></span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @webp; </span><br><span class="line">&#125;</span><br><span class="line">location @webp&#123;</span><br><span class="line">  <span class="comment"># 图片访问地址</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$uri</span> ~ <span class="string">"/([a-zA-Z0-9-_]+)\.(png|jpg|gif)\.webp"</span>) &#123; </span><br><span class="line">    <span class="comment"># 查找执行的 lua 脚本</span></span><br><span class="line">    content_by_lua_file <span class="string">"/usr/local/nginx/conf/jartto/webp.lua"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>补充：浏览器嗅探（阿里云 <code>OSS</code> 方式）</strong><br>1.本地嗅探：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check_webp_feature:</span></span><br><span class="line"><span class="comment">// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class="line"><span class="comment">// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_webp_feature</span>(<span class="params">feature, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> kTestImages = &#123;</span><br><span class="line">        lossy: <span class="string">"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"</span>,</span><br><span class="line">        lossless: <span class="string">"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=="</span>,</span><br><span class="line">        alpha: <span class="string">"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=="</span>,</span><br><span class="line">        animation: <span class="string">"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = (img.width &gt; <span class="number">0</span>) &amp;&amp; (img.height &gt; <span class="number">0</span>);</span><br><span class="line">        callback(feature, result);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(feature, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="string">`data:image/webp;base64<span class="subst">$&#123;kTestImages[feature]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.调用方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jartto's Demo</span></span><br><span class="line">check_webp_feature(<span class="string">'lossy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">feature, isSupported</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSupported) &#123;</span><br><span class="line">        <span class="comment">// webp is supported, you can cache the result here if you want</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>请注意，图像加载是非阻塞且异步的。 这意味着依赖于 WebP 支持的任何代码最好都应放在回调函数中。</p></div><h4 id="六、部署模型"><a href="#六、部署模型" class="headerlink" title="六、部署模型"></a>六、部署模型</h4><p>服务端部署模型需要简单了解一下，这样我们就可以根据不同的实际情况从上述<a href="http://jartto.wang/2020/05/02/webp-practice/">四种方案</a>中进行选择了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/server.png" alt="Server"></p><p>注意，如果你需要对 <code>Nginx</code> 进行配置，请不要操作 <code>Load Balancer</code> 层，尽量在应用服务器层操作。</p><h4 id="七、技术揭秘"><a href="#七、技术揭秘" class="headerlink" title="七、技术揭秘"></a>七、技术揭秘</h4><p>听起来很酷，那么 <code>WebP</code> 究竟使用了什么很魔法，我们来揭秘一下：              </p><p><strong>1.分块 <code>MacroBlocking</code></strong><br>将图片划分成多个宏块 <code>Macro Blocks</code>，典型的宏块由一个 <code>16×16</code> 的亮度像素 <code>luma pixel</code> 块和两个 <code>8×8</code> 的色度像素 <code>chroma pixel</code> 块组成。<br><div class="alert success"><p>分块越小，预测越准，需要记录的信息也越多。</p></div><br>一般来说，细节越丰富的地方，分块越细，即使用 <code>4×4</code> 分块预测。细节相对不丰富的地方使用 <code>16×16</code> 分块。</p><p><strong>2.帧内预测</strong><br><code>WebP</code> 有损压缩使用了帧内预测编码，这一技术也被用于 <code>VP8</code> 视频编码中的关键帧压缩。</p><p><code>VP8</code> 有四种常见的帧内预测模型：</p><ul><li><code>H_PRED(horizontal prediction)</code>：像素块中每一行使用其左边一列 <code>Col L</code> 的数据填充；</li><li><code>V_PRED(vertical prediction)</code>：像素块中每一列使用其上边一行 <code>Row A</code> 的数据填充；</li><li><code>DC_PRED(DC prediction)</code>：像素块中每个单元使用 <code>Row A</code> 和 <code>Col L</code> 的所有像素的平均值填充；</li><li><code>TM_PRED(TrueMotion prediction)</code>：混合式，接近真实数据；</li></ul><p>使用哪种分块预测模式是动态决定的。<br><div class="alert info"><p>编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。</p></div></p><p><strong>3.算法编码</strong><br><code>WebP</code> 使用 <code>Arithmetic entropy encoding</code>，该算法相比 <code>JPEG</code> 上使用的 <code>Huffman encoding</code>，在压缩表现上更出色。</p><p>深入研究，请移步：<br>1.<a href="https://developers.google.com/speed/webp/docs/compression?hl=zh_cn" target="_blank" rel="noopener">Compression Techniques</a><br>2.<a href="https://www.jianshu.com/p/7fb720ec57cd" target="_blank" rel="noopener">WebP 有损压缩的编码过程</a></p><h4 id="八、4种常见压缩格式"><a href="#八、4种常见压缩格式" class="headerlink" title="八、4种常见压缩格式"></a>八、4种常见压缩格式</h4><ol><li><p><code>Lossy</code><br>有损压缩基于 <code>VP8</code> 关键帧编码。 <code>VP8</code> 是 一种视频压缩格式，是 <code>VP6</code> 和 <code>VP7</code> 格式的后继格式。</p></li><li><p><code>Lossless</code><br>无损压缩格式由 <code>WebP</code> 团队开发。</p></li><li><p>Alpha<br><code>8</code> 位 <code>Alpha</code> 通道对于图形图像很有用。 <code>Alpha</code> 通道可与有损 <code>RGB</code> 一起使用，该功能目前无法在任何其他格式下使用。</p></li><li><p>Animation<br>它支持真彩色动画图像。</p></li></ol><div class="alert warning"><p>24 位色被称为真彩色，它可以达到人眼分辨的极限，发色数是 1677 万多色，也就是 2 的 24 次方。</p></div><h4 id="九、WebP-方案-ROI"><a href="#九、WebP-方案-ROI" class="headerlink" title="九、WebP 方案 ROI"></a>九、WebP 方案 ROI</h4><p>一般在做技术选型的过程中，我们都要评估引入技术的收益，这也就是我们常说的 <code>ROI</code>。那么如果你决定要使用 <code>WebP</code>，以下的数据可能会对你产生帮助：<br>1.优化后，网站资源大小从 <code>2.6MB</code> 减少到 <code>1.5MB</code>；<br>2.图片大小减少到原来的 <code>1/8</code>；<br>3.同一时间服务器请求数增加 <code>335%</code>，请求时长减少 <code>75%</code>；<br>4.<code>Lighthouse Performance</code> 评分 <code>97</code>，<code>FCP</code>，<code>FMP</code>大概在 <code>0.5-0.7s</code>（和其他优化有关）；           </p><div class="alert danger"><p>网站数据可能不尽相同，以上数据仅供参考。</p></div><h4 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h4><p><a href="http://jartto.wang/2020/05/02/webp-practice/">上文</a> 我们从 <code>WebP</code> 背景展开，介绍了它的兼容性、应用场景，以及 4 种实践方案，同时也提到了浏览器如何嗅探 <code>WebP</code> 格式。后半部分主要从原理出发，了解 <code>WebP</code> 格式的算法细节以及压缩格式，由浅入深，逐层剖析。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于网站来说，图片始终扮演着重要角色。图片大小直接影响网站速度、流量、运营成本以及用户体验。因此，减少图片大小成为网站优化最重要的一个环节。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="webp" scheme="http://jartto.wang/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>Web「性能测试」知多少？</title>
    <link href="http://jartto.wang/2020/04/05/about-wrk/"/>
    <id>http://jartto.wang/2020/04/05/about-wrk/</id>
    <published>2020-04-05T13:44:12.000Z</published>
    <updated>2020-04-06T15:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>身为前端的你，是否会有这样的烦恼：随着访问用户的成倍增加，站点变得越来越脆弱。任何的访问过慢或崩溃都将是一场灾难。<br><a id="more"></a><br>这就对我们工程师提出了更高的要求，要保障网站的「可访问性」和「稳定性」都维持在一个较高水平。那么，是时候了解了解 <code>Web</code> 性能测试了！</p><h4 id="一、情景再现"><a href="#一、情景再现" class="headerlink" title="一、情景再现"></a>一、情景再现</h4><p>有一个大型推广活动来了，类似与抢火车票、淘宝双十一，你能否回答 <code>Boss</code> 的如下问题？<br>1.我们的网站是否能扛住如此的高并发？<br>2.服务器单机 <code>QPS</code> 是多少？<br>3.如果站点扛不住，扩容的话，需要几台？<br>…</p><p>一连串的问题，如果你招架不住，不妨仔细<a href="http://jartto.wang/2020/04/05/about-wrk/">阅读本文</a>。</p><h4 id="二、什么是性能测试？"><a href="#二、什么是性能测试？" class="headerlink" title="二、什么是性能测试？"></a>二、什么是性能测试？</h4><p>要回答上面的问题，需要我们有一些知识储备。不着急，循序渐进，各个击破。<br><div class="alert success"><p>一般来说「性能测试」包括压力测试、负载测试、容量测试三种主要测试类型。</p></div></p><p><strong>1.压力测试 <code>StressTest</code></strong><br>压力测试可以测试网站在某个特定的持续的压力下运行的稳定性。</p><p><strong>2.负载测试 <code>LoadTest</code></strong><br>负载测试是为了检验系统在给定负载下是否能达到预期性能指标。</p><p><strong>3.容量测试 <code>CapabilityTest</code></strong><br>容量测试针对数据库而言，是在数据库中有较大数量的数据记录情况下对系统进行的测试。</p><p>内容比较多，为了专注聚焦，我们本节主要来看一下压力测试。</p><h4 id="三、压力测试"><a href="#三、压力测试" class="headerlink" title="三、压力测试"></a>三、压力测试</h4><p>压力测试是通过不断向被测系统施加压力，测试系统在压力情况下的性能表现。主要考察当前软硬件环境下系统所能承受的最大负荷并帮助开发人员找出系统瓶颈所在。我们可以模拟巨大的流量请求以查看应用程序在峰值使用情况以及服务器状况。</p><div class="alert info"><p>有效的压力测试将应用以下这些关键条件：重复，并发，量级，随机变化。</p></div><p><strong>需要注意的是</strong>：压力测试并不会报告是什么导致了问题。它只会报告这有了问题，例如：查询页面在并发 1000 个用户使用时变慢下来，但它不会显示什么导致了变慢。</p><p>捕获到的性能统计数据例如 <code>CPU</code> 和内存使用量只是强调了潜在的问题区域，但并不会指出实际的根源在应用程序的什么地方。</p><p>更多的概念可以查看：<a href="https://blog.csdn.net/weixin_40296254/article/details/80247111" target="_blank" rel="noopener">为什么要进行压力测试?</a>。</p><h4 id="四、核心指标"><a href="#四、核心指标" class="headerlink" title="四、核心指标"></a>四、核心指标</h4><p>了解了上述压力测试之后，我们先不着急进行网站压测，补充几个可以让你事半功倍的核心指标：</p><p>1.什么是 <code>TPS</code> ？<br>即 <code>Transactions Per Second</code> 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。</p><div class="alert warning"><p>一个事务可能对应多个请求，这与数据库的事务操作极其相似。</p></div><p>2.什么是 <code>QPS</code> ？<br><code>Queries Per Second</code> 的缩写，每秒能处理查询数目，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p><strong>需要注意的是</strong>：虽然名义上是查询的意思，但实际上，现在习惯于对单一接口服务的处理能力用 <code>QPS</code> 进行表述（即使它并不是查询操作）。</p><p>3.什么是 <code>RT</code> ？<br>响应时间，处理一次请求所需要的平均处理时间。我们一般会关注 <code>90th</code> 请求的的处理时间，因为可能因网络情况出现极端情况，长尾数据会对我们产生干扰。</p><p>4.系统 <code>CPU</code> 利用率<br>如果系统的 <code>CPU</code> 使用率已经很高，说明我们的系统是个计算度很复杂的系统，这时候如果 <code>QPS</code> 已经上不去了，就需要赶紧扩容，通过增加机器分担计算的方式来提高系统的吞吐量。</p><p>5.系统内存<br>如果 <code>CPU</code> 使用率一般，但是系统的 <code>QPS</code> 上不去，说明我们的机器并没有忙于计算，而是受到其他资源的限制，如内存、<code>I/O</code>。这时候首先看下内存是不是已经不够了，如果内存不够了，那就赶紧扩容了。</p><h4 id="五、QPS-如何计算？"><a href="#五、QPS-如何计算？" class="headerlink" title="五、QPS 如何计算？"></a>五、QPS 如何计算？</h4><p><code>QPS</code> 并没有准确的计算公式，但是实际压测中我们完全可以按照如下模型进行估算：<br><div class="alert info"><p>原理：每天 80% 的访问集中在 20% 的时间里，这 20% 时间叫做「峰值时间」。</p></div></p><p>公式：( 总 <code>PV</code> 数 <em> <code>80%</code> ) / ( 每天秒数 </em> <code>20%</code> ) = 峰值时间每秒请求数(<code>QPS</code>)<br>机器：峰值时间每秒 <code>QPS</code> / 单台机器的 <code>QPS</code> = 需要的机器</p><p>问：每天 <code>300w PV</code> 的在单台机器上，这台机器需要多少 <code>QPS</code>？<br>答：<code>( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</code></p><p>问：如果一台机器的 <code>QPS</code> 是 <code>58</code> ，需要几台机器来支持？<br>答：<code>139 / 58 = 3</code></p><p>具体的计算公式可以参考这篇文章：<a href="#">峰值 <code>QPS</code> 和机器计算公式</a>。</p><h4 id="六、推荐工具"><a href="#六、推荐工具" class="headerlink" title="六、推荐工具"></a>六、推荐工具</h4><p><a href="https://www.zhihu.com/question/21861449" target="_blank" rel="noopener">压测工具</a>有很多，<code>JMeter</code>，<code>LoadRunner</code>，<code>WebLoad</code>，<code>NeoLoad</code>，<code>Loadster</code>，<code>TcpCopy</code>，<code>AB</code>，<code>WebBench</code> 等等，恐怕一时间无法说完。但是论起上手能力，就要说说我们的主角 <code>wrk</code> 了。</p><p><a href="https://github.com/wg/wrk" target="_blank" rel="noopener"><code>wrk</code></a> 是一款针对 <code>Http</code> 协议的基准测试工具，它能够在单机多核 <code>CPU</code> 的条件下，使用系统自带的高性能 <code>I/O</code> 机制，如 <code>Epoll</code>，<code>Kqueue</code> 等，通过多线程和事件模式，对目标机器产生大量的负载。</p><p>有多容易，我们不妨试试看？</p><p>1.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk.git  </span><br><span class="line">cd wrk  </span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>注意使用 <code>./wrk</code> 命令启动。</p><p>2.基本使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t12 -c400 -d30s http://127.0.0.1:8080/jartto</span><br></pre></td></tr></table></figure></p><p>参数说明：<br><code>-c</code>：<code>HTTP</code> 连接数，每一个线程处理 <code>N</code> = 连接数/线程数<br><code>-d</code>：持续时间，<code>2s</code>，<code>2m</code>，<code>2h</code><br><code>-t</code>：总的线程数<br><code>-s</code>：脚本，可以是 <code>Lua</code> 脚本<br><code>-H</code>：增加 <code>HTTP header</code>，例如：<code>User-Agent: jartto</code><br><code>--latency</code>：输出时间统计的细节<br><code>--timeout</code>：超时时间</p><p>3.输出<br>上面我们使用 <code>12</code> 线程，保持打开 <code>400</code> 个 <code>Http</code> 连接，执行 <code>30s</code>。脚本运行完毕会输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Running 30s <span class="built_in">test</span> @ http://127.0.0.1:8080/jartto</span><br><span class="line">  12 threads and 400 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   635.91us    0.89ms  12.92ms   93.69%</span><br><span class="line">    Req/Sec    56.20k     8.07k   62.00k    86.54%</span><br><span class="line">  22464657 requests <span class="keyword">in</span> 30.00s, 17.76GB <span class="built_in">read</span></span><br><span class="line">Requests/sec: 748868.53</span><br><span class="line">Transfer/sec:    606.33MB</span><br></pre></td></tr></table></figure></p><p>输出说明：<br><code>Latency</code>：响应时间<br><code>Req/Sec</code>：每个线程每秒钟的完成的请求数<br><code>Avg</code>：平均<br><code>Max</code>：最大<br><code>Stdev</code>：标准差<br><code>+/- Stdev</code>： 正负一个标准差占比</p><div class="alert danger"><p>标准差大说明样本离散程度高，系统性能波动大。</p></div><p>在压测过程中，一般线程数不宜过多，<code>CPU</code> 核数的 <code>2-4</code> 倍就可以了。 太多反而因为线程切换过多造成效率降低， 因为 <code>wrk</code> 不是使用每个连接一个线程的模型， 而是通过异步网络 <code>I/O</code> 提升并发量。</p><p>所以网络通信不会阻塞线程执行，这也是 <code>wrk</code> 可以用很少的线程模拟大量网路连接的原因。</p><h4 id="七、高级定制"><a href="#七、高级定制" class="headerlink" title="七、高级定制"></a>七、高级定制</h4><p>到这里，相信文章开头提出的问题，你已经可以很好的回答了。我们不妨继续升级，来一些高级定制。可能很多童鞋注意到了上面文档中提到的 <code>-s</code> 参数了，我们先看看官方文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An optional LuaJIT script can perform HTTP request generation, response processing, </span><br><span class="line">and custom reporting.</span><br></pre></td></tr></table></figure></p><p><code>LuaJIT</code> 脚本可以执行 <code>HTTP</code> 请求生成，响应处理和自定义报告。这里是 <code>Lua</code> 的一些<a href="https://github.com/wg/wrk/tree/master/scripts" target="_blank" rel="noopener">案例</a>。鉴于篇幅过长，本节我们先了解到这里，精彩部分我们就留到<a href="#">下一篇</a>继续探讨吧！</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p><!-- `wrk` 中执行 `HTTP` 请求的时候，调用 `Lua` 分为 `3` 个阶段，`setup`，`running`，`done`，每个 `wrk` 线程中都有独立的脚本环境。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身为前端的你，是否会有这样的烦恼：随着访问用户的成倍增加，站点变得越来越脆弱。任何的访问过慢或崩溃都将是一场灾难。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="wrk" scheme="http://jartto.wang/tags/wrk/"/>
    
  </entry>
  
  <entry>
    <title>网站性能指标 - FMP</title>
    <link href="http://jartto.wang/2020/03/30/about-web-fmp/"/>
    <id>http://jartto.wang/2020/03/30/about-web-fmp/</id>
    <published>2020-03-30T03:13:15.000Z</published>
    <updated>2020-03-30T03:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端童鞋来说，优化是一个永恒的话题。上线并不是网站开发的终点，如何吸引用户、提升用户体验，应该成为我们 <code>F2E</code> 的追求目标。<br><a id="more"></a><br>如果你对优化还不了解，建议先阅读如下两篇文章：</p><ol><li><a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a></li><li><a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化，这些工具你一定用得着</a></li></ol><p>当然，衡量网站性能的指标有很多，今天我们就来看一个「令人费解而又头疼」的指标 - <code>FMP</code>。</p><div class="alert success"><p><code>First Meaningful Paint</code> 是指页面的首要内容出现在屏幕上的时间。</p></div><h4 id="一、FMP-之怪现象"><a href="#一、FMP-之怪现象" class="headerlink" title="一、FMP 之怪现象"></a>一、FMP 之怪现象</h4><p>目前尚无标准化的 <code>FMP</code> 定义，因此也没有性能条目类型。 部分原因在于很难以通用的方式确定「有效」对于所有页面意味着什么。但是，一般来说，在单个页面或单个应用中，最好是将 <code>FMP</code> 视为主角元素呈现在屏幕上的时刻。</p><p>所以，我们经常会面临这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/lighthouse.png" alt="Lighthouse 评分"><br><code>FCP</code> 在可接受范围，但是 <code>FMP</code> 却完全失控。</p><p>也可能是这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp1.png" alt="Performance FMP"></p><p>或许还有这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp2.png" alt="Performance FMP"></p><p>为什么结构类似的站点，<code>FMP</code> 加载却千差万别。要了解 <code>FMP</code> 我们需要知道它的计算规则，下面让我们一层层抽丝剥茧。</p><h4 id="二、刨根问底"><a href="#二、刨根问底" class="headerlink" title="二、刨根问底"></a>二、刨根问底</h4><p>究竟是什么导致 <code>FMP</code> 的时机差距如此之大？或许我们可以从 <code>FMP</code> 定义来说起。</p><p><code>When FMP and FCP are the same time in seconds, they share the same identical score. If FMP is slower than FCP, say when there&#39;s iframe content loading, then the FMP score will be lower than the FCP score.</code></p><p>什么意思呢，我们先来看一张官方图片：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp.png" alt="FMP 评分规则"></p><p>如果 <code>FCP</code> 是 <code>1.5s</code>，<code>FMP</code> 是 <code>3s</code>，那么 <code>FCP</code> 分数将会是 <code>99</code>，但是 <code>FMP</code> 分数将是 <code>75</code>。</p><p>除了上述影响外，我们还需要关注 <code>Lighthouse V3</code> 的记分规则：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/score.png" alt="记分规则"></p><p>虽然 <code>FMP</code> 权重仅为 <code>1</code> ，很遗憾，因为如上规则的存在，我们站点无法到达满分💯。</p><div class="alert info"><p>确定页面上最关键的主角元素之后，我们应确保初始脚本加载仅包含渲染这些元素并使其可交互所需的代码。</p></div><p>相关源码：<br><a href="https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/audits/metrics/first-meaningful-paint.js" target="_blank" rel="noopener">Lighthouse FMP 源码</a><br><a href="https://medium.com/@aswin_s/score-a-perfect-100-in-lighthouse-audits-part-1-3199163037" target="_blank" rel="noopener">Score a perfect 100 in Lighthouse audits</a></p><h4 id="三、重要结论"><a href="#三、重要结论" class="headerlink" title="三、重要结论"></a>三、重要结论</h4><p>了解了相关计算规则之后，我们继续来剖析 <code>FMP</code>。对于不同的站点，首要内容是不同的，例如：</p><ul><li>对于博客文章：「大标题」 + 「首屏文字」是首要内容；</li><li>对于百度或者 <code>Google</code> 的搜索结果页：「首屏的结果」就是首要内容；</li><li>对于淘宝等购物网站来说，图片会极为重要，因此它是首要内容；</li></ul><div class="alert danger"><p>需要注意的是，通常首要内容是不包括 Headers 和导航条的。</p></div><p>为了方便理解，我们用一个简单的公式表示：「首次有效绘制 = 具有最大布局变化的绘制」。</p><p>很好，此刻我们不用纠结「首次有效渲染」了，转而去了解「最大布局变化的绘制」。基于 <code>Chromium</code> 的实现，这个绘制是使用 <code>LayoutAnalyzer</code> 进行计算的，它会收集所有的布局变化，当布局发生最大变化时得出时间。</p><p>具有最大布局变化的绘制如何计算呢？<br>1.侦听页面元素的变化；<br>2.遍历每次新增的元素，并计算这些元素的得分总；<br>3.如果元素可见，得分为 <code>1 * weight</code>，如果元素不可见，得分为 <code>0</code>；</p><p>还是很抽象，我们继续探索 <code>LayoutAnalyzer</code>，在源码中得到如下公式：<br><div class="alert info"><p>布局显著性 = 添加的对象数目 / max(1, 页面高度 / 屏幕高度)</p></div></p><p>这下清晰了，既然可以算出来，那么优化 <code>FMP</code> 指日可待。从上面可以看出来「布局显著性」是通过添加对象数目与页面高度来计算的。似乎对象数目成了解决问题的关键节点。</p><p>我们继续探索，如何去找到对象数目呢？很简单，打开 <code>Chrome DevTool</code>，切到 <code>Layout</code> 面板。如果你还不会使用 <code>Layout</code> 面板，可以先看看<a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化工具</a>。</p><p>这里就不展开了，直接上图，看看红框部分：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/layout.png" alt="Layout Objects"></p><p>惊不惊喜，我们精简 <code>DOM</code> 似乎可以将公式中分子变小，或者让页面高度大于屏幕高度。到这里，所有谜团都解开了，优化 <code>FMP</code> 也就变得毫无挑战了。</p><p>相关源码：<br><a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/layout/layout_analyzer.h?type=cs&amp;q=LayoutAnalyzer&amp;sq=package:chromium&amp;g=0&amp;l=76" target="_blank" rel="noopener">LayoutAnalyzer 源码</a><br><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/trace-event-reading" target="_blank" rel="noopener">Tracing Results</a><br><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/trace-event-reading" target="_blank" rel="noopener">Understanding about:tracing results</a></p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>我们从扑簌迷离的 <code>FMP</code> 表象一层层找到了 <code>Lighthouse</code> 的记分规则，又从 <code>Tracing Results</code> 中得知最大布局变化的计算规则，因此转向 <code>LayoutAnalyzer</code> 源码研究，最终找到 <code>Layout Objects</code>，从而解决了问题。虽然波折，但结局令人舒适。</p><p>最后，再啰嗦一下，以下结论对理解 <code>FMP</code> 很重要：</p><ul><li>对于博客文章：「大标题」 + 「首屏文字」是首要内容；</li><li>对于百度或者 <code>Google</code> 的搜索结果页：「首屏的结果」就是首要内容；</li><li>对于淘宝等购物网站来说，图片会极为重要，因此它是首要内容；</li></ul><p>如果你觉得还是过于复杂，不妨去试试 <code>SSR</code> 吧，<code>FMP</code> 将不再是烦恼。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于前端童鞋来说，优化是一个永恒的话题。上线并不是网站开发的终点，如何吸引用户、提升用户体验，应该成为我们 &lt;code&gt;F2E&lt;/code&gt; 的追求目标。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="lighthouse" scheme="http://jartto.wang/tags/lighthouse/"/>
    
      <category term="fmp" scheme="http://jartto.wang/tags/fmp/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>聚焦 Web 性能指标 TTI</title>
    <link href="http://jartto.wang/2020/03/29/web-tti/"/>
    <id>http://jartto.wang/2020/03/29/web-tti/</id>
    <published>2020-03-29T14:23:53.000Z</published>
    <updated>2020-03-30T03:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你经常做网站优化，可能会陷入一个性能指标的泥潭即「面向指标优化」。真正的用户体验从来不是指标决定，相反它应该最真实的反映用户行为。<br><a id="more"></a><br>所以本节我们就来研究 <code>TTI(Time to Interactive)</code>，话题展开之前，我们先来了解一些背景知识。</p><h4 id="一、RAIL-模型"><a href="#一、RAIL-模型" class="headerlink" title="一、RAIL 模型"></a>一、RAIL 模型</h4><p><code>RAIL</code> 是一种以用户为中心的性能模型。每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/rail.png" alt="RAIL 性能模型"></p><p>1.响应：输入延迟时间（从点按到绘制）小于 100 毫秒。<br>用户点按按钮（例如打开导航）。</p><p>2.动画：每个帧的工作（从 JS 到绘制）完成时间小于 16 毫秒。<br>用户滚动页面，拖动手指（例如，打开菜单）或看到动画。 拖动时，应用的响应与手指位置有关（例如，拉动刷新、滑动轮播）。 此指标仅适用于拖动的持续阶段，不适用于开始阶段。</p><p>3.空闲：主线程 JS 工作分成不大于 50 毫秒的块。<br>用户没有与页面交互，但主线程应足够用于处理下一个用户输入。</p><p>4.加载：页面可以在 1000 毫秒内就绪。<br>用户加载页面并看到关键路径内容。</p><div class="alert info"><p>如果要提升网站用户体验，RAIL 是个不错的评估模型。</p></div><h4 id="二、解读-TTI（页面可交互时间）"><a href="#二、解读-TTI（页面可交互时间）" class="headerlink" title="二、解读 TTI（页面可交互时间）"></a>二、解读 TTI（页面可交互时间）</h4><p><code>TTI</code> 指的是应用既在视觉上都已渲染出了，可以响应用户的输入了。要了解 <code>TTI</code>，我们需要知道它的计算规则，先来看下面这张图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/tti.png" alt="TTI"></p><p>在<a href="https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/preview#" target="_blank" rel="noopener">官方文档</a>中找到了如下描述：<br><code>First Idle is the first early sign of time where the main thread has come at rest and the browser has completed a First Meaningful Paint.</code></p><p><code>Time to Interactive is after First Meaningful Paint. The browser’s main thread has been at rest for at least 5 seconds and there are no long tasks that will prevent immediate response to user input.</code></p><p>我们可以简单的理解一下：<br>1.<code>First Idle</code> 是主线程处于静止状态且浏览器已完成 <code>First Meanfulful Paint</code> 的第一个早期迹象；<br>2.<code>TTI</code> 在 <code>FMP</code> 之后，浏览器主线程静止至少 <code>5s</code>，并且没有可以阻断用户交互响应的「长任务」。</p><p>如果你对 <code>FMP</code> 还不了解，不妨先看看这篇文章：<a href="http://jartto.wang/2020/03/15/about-web-fmp/">网站性能指标 - <code>FMP</code></a>。除此之外，第二条中提到的「长任务」又是什么呢？</p><h4 id="三、Long-Task（长任务）"><a href="#三、Long-Task（长任务）" class="headerlink" title="三、Long Task（长任务）"></a>三、Long Task（长任务）</h4><p>对于「长任务」，我们通过如下图示说明：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/longtask.png" alt="长任务"></p><div class="alert info"><p>对于用户而言，任务耗时较长表现为滞后或卡顿，而这也是目前网页不良体验的主要根源。</p></div><p>如何测量 <code>Long Task</code>？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jartto's Demo</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span><br><span class="line">    <span class="comment">// TODO...</span></span><br><span class="line">    <span class="built_in">console</span>.log(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.observe(&#123;<span class="attr">entryTypes</span>: [<span class="string">'longtask'</span>]&#125;);</span><br></pre></td></tr></table></figure></p><p>控制台输出结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"self"</span>,</span><br><span class="line">  <span class="string">"entryType"</span>: <span class="string">"longtask"</span>,</span><br><span class="line">  <span class="string">"startTime"</span>: <span class="number">315009.59500001045</span>,</span><br><span class="line">  <span class="string">"duration"</span>: <span class="number">99.9899999878835</span>,</span><br><span class="line">  <span class="string">"attribution"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">      <span class="string">"entryType"</span>: <span class="string">"taskattribution"</span>,</span><br><span class="line">      <span class="string">"startTime"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"containerType"</span>: <span class="string">"window"</span>,</span><br><span class="line">      <span class="string">"containerSrc"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"containerId"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"containerName"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Long Tasks API</code> 可以将任何耗时超过 <code>50</code> 毫秒的任务标示为可能存在问题，并向应用开发者显示这些任务。 选择 <code>50</code> 毫秒的时间是为了让应用满足在 <code>100</code> 毫秒内响应用户输入的 <code>RAIL</code> 指导原则。</p><p>实际开发过程中，我们可以通过一个 <code>hack</code> 来检查页面中「长任务」的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detect long tasks hack</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">detectLongFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastFrameTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentFrameTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (currentFrameTime - lastFrameTime &gt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="comment">// Report long frame here...</span></span><br><span class="line">        &#125;</span><br><span class="line">        detectLongFrame(currentFrameTime);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h4 id="四、如何计算-TTI？"><a href="#四、如何计算-TTI？" class="headerlink" title="四、如何计算 TTI？"></a>四、如何计算 TTI？</h4><p>在计算之前，我们先来看一下 <code>Timing API</code>：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/timing.png" alt="Timing API"></p><p><code>Google</code> 官方文档中有一段描述：<br><code>Note: Lower Bounding FirstInteractive at DOMContentLoadedEndDOMContentLoadedEnd is the point where all the DOMContentLoaded listeners finish executing. It is very rare for critical event listeners of a webpage to be installed before this point. Some of the firstInteractive definitions we experimented with fired too early for a small number of sites, because the definitions only looked at long tasks and network activity (and not at, say, how many event listeners are installed), and sometimes when there are no long tasks in the first 5-10 seconds of loading we fire FirstInteractive at FMP, when the sites are often not ready yet to handle user inputs. We found that if we take max(DOMContentLoadedEnd, firstInteractive) as the final firstInteractive value, the values returned to reasonable region. Waiting for DOMContentLoadedEnd to declare FirstInteractive is sensible, so all the definitions introduced below lower bound firstInteractive at DOMContentLoadedEnd.</code></p><p>所以，我们可以通过 <code>domContentLoadedEventEnd</code> 来粗略的进行估算：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面可交互时间 </span></span><br><span class="line">TTI: domContentLoadedEventEnd - navigationStart,</span><br></pre></td></tr></table></figure></p><div class="alert info"><p><a href="https://w3c.github.io/navigation-timing/#dom-performancenavigationtiming-domcontentloadedeventend" target="_blank" rel="noopener">domContentLoadedEventEnd</a>：文档的 DOMContentLoaded 事件的结束时间。</p></div><p><code>The domContentLoadedEventEnd attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately after the current document&#39;s DOMContentLoaded event completes.</code></p><p>如果你觉得上述计算过于复杂，可以通过 <code>Google</code> 实验室提供的 <code>Polyfill</code> 来获取。</p><h4 id="五、TTI-指标监控"><a href="#五、TTI-指标监控" class="headerlink" title="五、TTI 指标监控"></a>五、TTI 指标监控</h4><p>我们可以通过 <a href="https://github.com/GoogleChromeLabs/tti-polyfill" target="_blank" rel="noopener"><code>Google TTI Polyfill</code></a>来对 <code>TTI</code> 进行监测。<br>1.安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install tti-polyfill</span><br></pre></td></tr></table></figure></p><p>2.使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ttiPolyfill <span class="keyword">from</span> <span class="string">'./path/to/tti-polyfill.js'</span>;</span><br><span class="line">ttiPolyfill.getFirstConsistentlyInteractive(opts).then(<span class="function">(<span class="params">tti</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Use `tti` value in some way.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>很简单，就不细说了。推荐几篇 <code>TTI</code> 相关文章：<br><a href="https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/preview#" target="_blank" rel="noopener">First Interactive and Consistently Interactive</a><br><a href="https://web.dev/user-centric-performance-metrics/#tracking_tti" target="_blank" rel="noopener">User-centric performance metrics</a><br><a href="https://calibreapp.com/blog/time-to-interactive" target="_blank" rel="noopener">Focusing on the Human-Centric Metrics</a></p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你经常做网站优化，可能会陷入一个性能指标的泥潭即「面向指标优化」。真正的用户体验从来不是指标决定，相反它应该最真实的反映用户行为。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="tti" scheme="http://jartto.wang/tags/tti/"/>
    
  </entry>
  
  <entry>
    <title>破局：技术视野与规划</title>
    <link href="http://jartto.wang/2020/03/08/breaking-the-game/"/>
    <id>http://jartto.wang/2020/03/08/breaking-the-game/</id>
    <published>2020-03-08T10:32:43.000Z</published>
    <updated>2020-03-09T15:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>有幸参加了 <code>51CTO</code> 的技术峰会，一天满满的干货，感觉收益颇多。于是将重点内容整理总结，分享给大家。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/title.png" alt="PPT"><br>分享标题为<strong>《破局：技术视野与规划》</strong>，主要围绕峰会内容展开，中间夹杂一些个人见解与思考。</p><div class="alert warning"><p>下文多图预警，建议小伙伴们 Wi-Fi 阅读。</p></div><h4 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/contents.png" alt="目录"></p><p>我们将从以下四方面来展开说明：<br>1.<code>2019 CTO</code> 发展报告<br>2.技术团队模型<br>3.技术视野<br>4.技能发展与规划</p><h4 id="二、2019-CTO-发展报告-2019-CTO-Development-Report"><a href="#二、2019-CTO-发展报告-2019-CTO-Development-Report" class="headerlink" title="二、2019 CTO 发展报告 - 2019 CTO Development Report"></a>二、2019 CTO 发展报告 - 2019 CTO Development Report</h4><p>峰会开场就拿出了一份调查报告，主要围绕四方面：<br>1.<strong>宏观环境</strong><br>2017-2019 年，下行经济环境市场缺口在收缩。向「公司管理驱动」和「科技创新驱动」转变。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/macro.png" alt="宏观经济"></p><p>从图中我们可以看出来，下行经济环境下市场缺口正在收缩。难道 <code>CTO</code> 要面临失业吗？不着急，我们接着往下看。</p><p>2.<strong>机遇与挑战</strong><br>以「业务为中心」的延伸，向上是对商业战略的思考，向下是对技术管理、技术交付的落实。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/opportunities.png" alt="机遇与挑战"></p><p>3.<strong>胜任力</strong><br>既懂得战略、又懂得组织管理、又懂得企业内部运营机制的技术负责人。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/capability.png" alt="胜任力"></p><p>我们可以看出：对 <code>CTO</code> 的胜任力要求，越来越趋向于一个既懂得战略、又懂得组织管理、又懂得企业内部运营机制的技术负责人。</p><div class="alert info"><p>所以，并不是需求变少，而是对高精尖人才的要求越来越高。</p></div><p>4.<strong>投资人视角</strong><br>产业革命造就了帝国的崛起，前三次工业革命大家耳熟能详，那么第四次工业革命到底是什么？希望我们中有人可以来定义第四次工业革命～<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/investor.png" alt="投资人视角"></p><p>下图列举了一些未来 10 年投资的一些方向，抓住机会，理财从现在开始。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/investor2.png" alt="投资领域"></p><h4 id="三、技术团队模型-Technical-team-model"><a href="#三、技术团队模型-Technical-team-model" class="headerlink" title="三、技术团队模型 - Technical team model"></a>三、技术团队模型 - Technical team model</h4><p>本节，我们将从技术团队模型来说：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team.png" alt="技术团队"></p><div class="alert info"><p>内容来自 4 位 CTO 的总结，我们集百家之长。</p></div><p>1.<strong>技术团队 <code>ROI</code>：领导的角度</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team-roi.png" alt="领导的角度"></p><p>不管问题如何回答，我们只有一个核心观点：<strong>对于公司来说，所有的事情都是赚钱相关的</strong>。</p><p>2.<strong>技术团队 <code>ROI</code>：下属的角度</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team2.png" alt="下属的角度"></p><p>下属想法很淳朴，甚至很无辜。</p><p>3.<strong>技术团队 <code>ROI</code></strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team3.png" alt="技术团队 ROI"></p><p>4.<strong>BSC 模型</strong><br>总结来说就是：以前瞻性和战略性为基础的平衡计分卡。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team4.png" alt="BSC 模型"></p><p>我们简单补充一下：<br>平衡计分卡(<code>The Balanced ScoreCard</code>，简称 <code>BSC</code>），就是根据企业组织的战略要求而精心设计的指标体系。平衡计分卡是一种绩效管理的工具。</p><p>它将企业战略目标逐层分解转化为各种具体的相互平衡的绩效考核指标体系，并对这些指标的实现状况进行不同时段的考核，从而为企业战略目标的完成建立起可靠的执行基础。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team5.png" alt="BSC 模型"></p><p>平衡计分卡中有一些条目是很难解释清楚或者是衡量出来的。财务指标当然不是问题，而非财务指标往往很难去建立起来。确定绩效的衡量指标往往比想象的更难。</p><p>我们来概括一下重点：</p><ul><li>全局战略思维(像 CEO 一样思考)</li><li>持续提升技术驱动业务创新与增长，赋能企业可持续发展</li><li>善用管理、效能与技术工具</li></ul><p>5.<strong>大型科技团队的管理</strong><br><div class="alert success"><p>大型科技团队中最重要的五部分：使命和定位，绩效管理，团队文化，技术决策，执行力。</p></div></p><p>这里收集了大型科技公司的组织架构，很有意思：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/management.png" alt="大型科技团队的管理"></p><p>大概解释一下：</p><ul><li>亚马逊等级森严且有序；</li><li>谷歌结构清晰，产品和部门之间却相互交错且混乱；</li><li><code>Facebook</code> 架构分散，就像一张散开的网络；</li><li>微软内部各自占山为王，军阀作风深入骨髓；</li><li>苹果一个人说了算，而那个人路人皆知；</li><li>庞大的甲骨文，臃肿的法务部显然要比工程部门更加重要；</li></ul><p>这里推荐一本书，《信任五层波浪》：自我信任，关系信任，组织信任，市场信任，社会信任。</p><p>6.<strong><code>ToB</code> 形态下的技术挑战</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/2b.png" alt="ToB"></p><p>双活架构体系：<br>两个数据中心是对等的、不分主从、并可同时部署业务，可极大的提高资源的利用率和系统的工作效率、性能，双活是觉得备用数据中心只做备份太浪费了，所以让主备两个数据中心都同时承担用户的业务，此时，主备两个数据中心互为备份，并且进行实时备份。</p><p>一般来说，主数据中心的负载可能会多一些，比如分担 60~70% 的业务，备数据中心只分担 40%~30% 的业务。</p><h4 id="四、技术视野-Technical-perspective"><a href="#四、技术视野-Technical-perspective" class="headerlink" title="四、技术视野 - Technical perspective"></a>四、技术视野 - Technical perspective</h4><p>关于技术视野，峰会上提到了几个概念，下面我们来逐一解释。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/perspective.png" alt="技术视野"></p><p>1.<strong><code>5G</code> 时代</strong><br><code>5G</code> 时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构 <code>Monolithic</code> 变成微服务架构<code>Microservices</code>，相当于一个全能型变成N个专能型。</p><div class="alert success"><p>每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p></div><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/5g.png" alt="5G"></p><p><code>5G</code> 的特点概括来说：高数据速率、减少延迟、节省能源、降低成本、提高系统容量和大规模设备连接。</p><p>2.<strong>工程效能</strong><br>很多大厂都专门设立了这个部门，主要职责包括：需求治理、质量分析，量化管理，代码构建、代码搜索，开发测试、自动化、发布、舆情监控等。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/effective.png" alt="工程效能"></p><p>3.<strong>红蓝军对抗</strong><br>类似于军事领域的红蓝军对抗，网络安全中，红蓝军对抗则是一方扮演黑客「蓝军」，一方扮演防御者「红军」。红蓝军对抗的目的就是用来评估企业安全性，有助于找出企业安全中最脆弱的环节，提升企业安全能力的建设。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/confrontation.png" alt="红蓝军对抗"></p><p>4.<strong>数字化转型</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/digital.png" alt="数字化转型"></p><p>这里不得不说说什么是「数字领导力」，在我们正在经历的这场数字革命中，透明化、网络化、公开化和分享成为领导力文化的核心。</p><p>数字经济时代，数字化领导力是企业战略地使用数字资产达成商业目的的能力。对企业而言，清晰的数字化战略和强有力的数字化领导者将对该目标的实现起到关键作用。</p><h4 id="五、技能发展与规划-Skill-development-and-planning"><a href="#五、技能发展与规划-Skill-development-and-planning" class="headerlink" title="五、技能发展与规划 - Skill development and planning"></a>五、技能发展与规划 - Skill development and planning</h4><p>1.<strong>进化路径</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/plan.png" alt="进化路径"></p><p>2.<strong>具备能力</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/ability.png" alt="数字化转型"></p><p>3.<strong>提升途径</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/ascent.png" alt="数字化转型"></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>好了，以上就是我分享的主要内容，感兴趣的童鞋欢迎深入交流。如果你需要 <code>PPT</code> ，可以去这里<a href="https://pan.baidu.com/s/1nNha7JtZCOo1GfxuOx_aeg" target="_blank" rel="noopener">下载</a>（提取码: <code>i6ud</code>）。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸参加了 &lt;code&gt;51CTO&lt;/code&gt; 的技术峰会，一天满满的干货，感觉收益颇多。于是将重点内容整理总结，分享给大家。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="技术视野" scheme="http://jartto.wang/tags/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/"/>
    
      <category term="规划" scheme="http://jartto.wang/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>极简弹幕方案</title>
    <link href="http://jartto.wang/2020/02/16/web-barrager/"/>
    <id>http://jartto.wang/2020/02/16/web-barrager/</id>
    <published>2020-02-16T15:58:47.000Z</published>
    <updated>2020-02-22T14:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>重大的活动现场一般离不开 <code>PPT</code> 演示，可是如何有效和现场互动呢？这时候弹幕必不可少，静态的 <code>PPT</code> 就略显乏力。有没有一种好的方案可以二者兼得呢？<br><a id="more"></a><br><div class="alert info"><p>如何才能使 <code>PPT</code> 具有交互性，这是一个值得思考的问题！</p></div></p><p>可能很多童鞋想到了，如果使用「网页 <code>PPT</code>」 ，岂不是完美解决了这个问题。本节我们就来提供一种思路，用「<code>PPT</code> + 发射器 + <code>Socket</code>」 实现「极简弹幕方案」。</p><p><strong>关于「网页 <code>PPT</code>」，可以查看我之前的文章「<a href="http://jartto.wang/2019/04/15/amusing-ppt/">酷炫的 <code>HTML5</code> 网页 <code>PPT</code></a>」一探究竟。</strong></p><h4 id="一、效果演示"><a href="#一、效果演示" class="headerlink" title="一、效果演示"></a>一、效果演示</h4><p>我们先通过一个简单的视屏演示一下效果：</p><video src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/barrager/demo.mp4" controls="controls" width="100%" height>您的浏览器不支持播放该视频！</video><p>相关代码：<a href="#">Demo 地址</a></p><h4 id="二、方案概括"><a href="#二、方案概括" class="headerlink" title="二、方案概括"></a>二、方案概括</h4><div class="alert info"><p>看完上面的演示，是不是迫不及待想知道答案，下面我们来逐步拆分。</p></div><p>先来看看代码结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── mobile</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── public</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── yarn.lock</span><br><span class="line">├── package.json</span><br><span class="line">├── ppt</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── extras</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   └── temp</span><br><span class="line">├── server</span><br><span class="line">│   ├── app.js</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package-lock.json</span><br><span class="line">│   └── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>我们主要关注以下三个目录：</p></div><p>1.<code>ppt</code><br>使用 <code>impressjs</code> 构建的项目，<code>PPT</code> 演讲「主屏」，主要演示内容区域，同时接收「服务端」推送弹幕信息。</p><p>2.<code>mobile</code><br>移动端，下文称作「发射器」，主要用作现场用户互动向主屏发送弹幕消息。通过 <code>Create React App</code> 生成，技术栈是：<code>React + Antd</code>。</p><p>3.<code>server</code><br>服务端，主要接受用户弹幕，同时广报到主屏，使用 <code>Socket</code> 实现。</p><div class="alert success"><p>启动方式：</p></div><p>1.进入 server 目录，启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></p><p>此时会启动一个本机 IP 地址的服务。</p><p>2.进入 ppt 目录，使用 http-server 启动站点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server</span><br></pre></td></tr></table></figure></p><p>注意：接口地址需要替换成本机 IP 地址。</p><p>3.进入 mobile 目录，启动发射器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure></p><p>注意：请求接口需要使用本机 IP 地址。</p><p><a href="https://github.com/chenfengyanyu/barrager-ppt-demo" target="_blank" rel="noopener">Demo</a> 比较简单，主要展示主流程，如果细节过程有问题，欢迎一起探讨。</p><h4 id="三、主屏细节（核心代码）"><a href="#三、主屏细节（核心代码）" class="headerlink" title="三、主屏细节（核心代码）"></a>三、主屏细节（核心代码）</h4><p>主屏是主要演示版面，我们需要像下面这样作出 <code>PPT</code>，这里我们做了三个页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span> <span class="attr">class</span>=<span class="string">"jartto"</span> <span class="attr">data-transition-duration</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cover"</span> <span class="attr">class</span>=<span class="string">"step slide title"</span> <span class="attr">data-x</span>=<span class="string">"1000"</span> <span class="attr">data-y</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"temp/img/qrcode.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"award"</span> <span class="attr">class</span>=<span class="string">"step slide"</span> <span class="attr">data-x</span>=<span class="string">"2000"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请开始你的表演～<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"change"</span> <span class="attr">class</span>=<span class="string">"step slide"</span> <span class="attr">data-x</span>=<span class="string">"2000"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span> <span class="attr">data-scale</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>切换 PPT<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"thank"</span> <span class="attr">class</span>=<span class="string">"step slide"</span>  <span class="attr">data-rel-x</span>=<span class="string">"0"</span> <span class="attr">data-rel-y</span>=<span class="string">"3000"</span> <span class="attr">data-rotate</span>=<span class="string">"90"</span> <span class="attr">data-scale</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/thanks.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><div class="alert warning"><p>每个 div 就是一页 ppt，里面可以随意排版，data-x 控制位置，data-scale 控制缩放，data-rotate 控制旋转。</p></div><p>更多 <code>API</code> 文档，请参考如下文档：<br>1.<a href="http://jartto.wang/2019/04/15/amusing-ppt/">酷炫的 <code>HTML5</code> 网页 <code>PPT</code></a><br>2.<a href="https://github.com/impress/impress.js" target="_blank" rel="noopener">文档地址</a></p><h4 id="四、实现弹幕"><a href="#四、实现弹幕" class="headerlink" title="四、实现弹幕"></a>四、实现弹幕</h4><p>为了更好的理解弹幕，我们来实现一个简版：<br>1.定义弹幕结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto_demo"</span>&gt;</span>我是弹幕<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.定义移动动画<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> barrager&#123;</span><br><span class="line">   <span class="selector-tag">from</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateX</span>(0);</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">to</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translate3d</span>(-100%, 0, 0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>注意，使用 translate3d 可以开启 GPU 硬件加速，会比 translateX 更流畅一些。</p></div><p>关于硬件加速，可以关注我之前写的一篇文章：<a href="http://jartto.wang/2017/09/29/expand-on-performance-composite/">详谈层合成（composite）</a></p><p>3.使用动画<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jartto_demo</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">animation</span>: barrager <span class="number">5s</span> linear <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，我们通过三步实现了一个简单的弹幕动画。那么问题来了，弹幕都是随机位置，随机速度，随机颜色出现在屏幕上的，这个该如何实现呢？</p><p>4.随机弹幕出现位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> window_height = $(<span class="built_in">window</span>).height() - <span class="number">150</span>;</span><br><span class="line">bottom = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * window_height + <span class="number">40</span>);</span><br><span class="line">code = code.replace(<span class="string">"   bottom:&#123;bottom&#125;, //距离底部高度,单位px,默认随机 \n"</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><p>5.随机弹幕颜色<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">2</span> &lt;&lt; <span class="number">23</span>)).toString(<span class="number">16</span>)&#125;</span>`</span>; </span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// #6e8360</span></span><br></pre></td></tr></table></figure></p><div class="alert info"><p>好了，大功告成，我们顺手加上 Socket 事件监听。</p></div><p>6.事件监听<br>为了拿到用户发送过来的弹幕，我们需要做一个事件监听（接收服务端数据）：<br>首先，引入 <code>socket.io.js</code> 文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://&#123;jartto.ip&#125;/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'http://&#123;jartto.ip&#125;'</span>);</span><br><span class="line">socket.on(<span class="string">'server-push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'news message &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>, data.message);</span><br><span class="line">    run(data.message); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们监听到 <code>server-push</code> 事件的时候，<code>run</code> 函数就会初始化弹幕方法，随机生成一条弹幕，在屏幕滑过。</p><h4 id="五、发射器细节（核心代码）"><a href="#五、发射器细节（核心代码）" class="headerlink" title="五、发射器细节（核心代码）"></a>五、发射器细节（核心代码）</h4><p>发射器就非常简单了，我们使用 <code>Create React App</code> 初始化项目，在 <code>src/app.js</code> 中写入一个表单(这里以 <code>React</code> 为例，<code>Vue</code> 也是大同小异）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"app-box"</span>&gt;</span><br><span class="line">    &lt;div className=<span class="string">"form-box"</span>&gt;</span><br><span class="line">        &lt;Form.Item &#123;...formItemLayout&#125; label=<span class="string">""</span>&gt;</span><br><span class="line">        &#123;getFieldDecorator(<span class="string">'msg'</span>, &#123;</span><br><span class="line">            rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                required: <span class="literal">true</span>,</span><br><span class="line">                message: <span class="string">'请输入内容'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;)(<span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">"large"</span> <span class="attr">placeholder</span>=<span class="string">"发送消息，嗨起来～"</span> /&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line">        &lt;Form.Item &#123;...formTailLayout&#125; &gt;</span><br><span class="line">        &lt;Button className="btns"  shape="round" icon="close" size="large" onClick=&#123;this.cancle&#125;&gt;取消&lt;/Button&gt;</span><br><span class="line">        &lt;Button   type="primary" shape="round" icon="check" size="large" onClick=&#123;this.check&#125;&gt;发送&lt;/Button&gt;</span><br><span class="line">        &lt;/Form.Item&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>用户在输入框输入消息，向我们的服务器发送请求，很简单，就不赘述了。效果图可以参考下面：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/barrager/show.png" alt="Demo 效果图"></p><div class="alert warning"><p>请注意，此处为了演示效果，我将三端同框了。</p></div><h4 id="六、服务端细节（核心代码）"><a href="#六、服务端细节（核心代码）" class="headerlink" title="六、服务端细节（核心代码）"></a>六、服务端细节（核心代码）</h4><p>服务端比较简单，使用 <code>Express</code> 初始化一个 <code>Node</code> 项目，向 <code>app.js</code> 写入如下内容：<br>1.启动 <code>Socket</code> 服务：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">  bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>),</span><br><span class="line">  socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>),</span><br><span class="line">  fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">4000</span>;</span><br><span class="line"><span class="keyword">const</span> io = socket(app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`start on port <span class="subst">$&#123;PORT&#125;</span>`</span>)));</span><br></pre></td></tr></table></figure></p><p>2.监听 <code>Socket</code> 连接，接收用户发送数据，将数据写入本地 <code>JSON</code> 文件，并广播到 <code>server-push</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, sockets =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功！'</span>);</span><br><span class="line">  app.post(<span class="string">'/api/send'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(req.body);</span></span><br><span class="line">    <span class="keyword">let</span> info = <span class="built_in">JSON</span>.stringify(req.body.msg);</span><br><span class="line"></span><br><span class="line">    fs.writeFile(<span class="string">'./data/jartto.json'</span>, <span class="string">`<span class="subst">$&#123;info&#125;</span>,\n`</span>,</span><br><span class="line">    &#123;<span class="attr">flag</span>:<span class="string">'a'</span>,<span class="attr">encoding</span>:<span class="string">'utf-8'</span>,<span class="attr">mode</span>:<span class="string">'0666'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入失败'</span>);</span><br><span class="line">        res.status(<span class="number">500</span>).send(<span class="string">'Error'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sockets.broadcast.emit(<span class="string">'server-push'</span>, &#123; <span class="attr">message</span>: req.body.msg &#125;);</span><br><span class="line">        res.status(<span class="number">200</span>).send(<span class="string">'Done'</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">     &#125;) </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  sockets.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User Disconnected'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>3.当然，我们也可以存入数据库做持久化，以下演示存入 <code>MySQL</code> 核心代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, sockets =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功！'</span>);</span><br><span class="line">  app.post(<span class="string">'/api/send'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;ua, msg&#125; = req.body.msg;</span><br><span class="line">    req.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, cnt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> query = cnt.add(<span class="string">'INSERT INTO (ua, msg)'</span>, &#123;ua, msg&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"Error inserting : %s "</span>,err );</span><br><span class="line">          <span class="keyword">return</span> next(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sockets.broadcast.emit(<span class="string">'server-push'</span>, &#123; <span class="attr">message</span>: req.body.msg &#125;);</span><br><span class="line">        res.status(<span class="number">200</span>).send(<span class="string">'Done'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  sockets.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User Disconnected'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>4.启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></p><p>我们的服务端就启动起来了，访问地址是你的主机 <code>IP</code> 和 <code>4000</code> 端口。</p><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><p><a href="http://jartto.wang/2020/02/16/web-barrager/">本文</a>我们从零到一搭建了一个完整的弹幕方案，涉及到三部分：主屏，发射器和服务端，旨在为小伙伴们提供一套极简的设计思路。通过 <code>Demo</code> 我们可以简单的串联一个全栈项目，做更多有趣的事情。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重大的活动现场一般离不开 &lt;code&gt;PPT&lt;/code&gt; 演示，可是如何有效和现场互动呢？这时候弹幕必不可少，静态的 &lt;code&gt;PPT&lt;/code&gt; 就略显乏力。有没有一种好的方案可以二者兼得呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="barrager" scheme="http://jartto.wang/tags/barrager/"/>
    
  </entry>
  
  <entry>
    <title>GitBook 和它有趣的插件</title>
    <link href="http://jartto.wang/2020/02/02/about-gitbook/"/>
    <id>http://jartto.wang/2020/02/02/about-gitbook/</id>
    <published>2020-02-02T07:20:03.000Z</published>
    <updated>2020-02-02T12:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多童鞋在日常开发中都会有「说明文档」、「学习笔记」和「个人博客」的需求，那么最经济简洁的方式莫过于 <code>GitBook</code> 方案了，<code>10</code> 分钟学习，永久使用。<br><a id="more"></a><br>本文将简单介绍 <code>GitBook</code> 的使用方式以及最佳插件搭配方案，快来运行一个与众不同而且免费托管的个人站点吧！</p><h4 id="一、安装与使用"><a href="#一、安装与使用" class="headerlink" title="一、安装与使用"></a>一、安装与使用</h4><p>1.<strong>安装 <code>GitBook</code> 插件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure></p><p>2.<strong>查看安装版本</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V</span><br></pre></td></tr></table></figure></p><p>控制台会输出如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jartto</span></span><br><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></p><p>3.<strong>初始化</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立项目：</span></span><br><span class="line">mkdir jartto-gitbook-demo</span><br><span class="line"><span class="comment"># 进入目录：</span></span><br><span class="line"><span class="built_in">cd</span> jartto-gitbook-demo</span><br><span class="line"><span class="comment"># 初始化：</span></span><br><span class="line">gitbook init</span><br></pre></td></tr></table></figure></p><p>此时，<code>jartto-gitbook-demo</code> 目录下会自动生成如下文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">└── SUMMARY.md</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure></p><p>4.<strong>启动</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure></p><p>5.<strong>访问站点</strong>：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo.png" alt="网站预览"></p><div class="alert success"><p>恭喜你，到这一步我们已经完成了基本版本。</p></div><p>更详细的操作，请查看如下文档：</p><ul><li><a href="https://www.gitbook.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">Github 地址</a></li><li><a href="https://docs.gitbook.com/resources/gitbook-legacy/v2-differences#plugins" target="_blank" rel="noopener">帮助文档</a></li></ul><h4 id="二、重点说明"><a href="#二、重点说明" class="headerlink" title="二、重点说明"></a>二、重点说明</h4><p>1.<strong>目录结构</strong><br>当我们运行 <code>gitbook serve</code> 后，<code>jartto-gitbook-demo</code> 目录下会生成一个 <code>_book</code> 文件夹：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── SUMMARY.md</span><br><span class="line">└── _book</span><br><span class="line">    ├── gitbook</span><br><span class="line">    ├── index.html</span><br><span class="line">    └── search_index.json</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure></p><p>2.<strong>关于 <code>README.md</code></strong><br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Introduction</span></span><br></pre></td></tr></table></figure></p><p>说明文档，大家应该都不陌生，就不赘述了。</p><p>3.<strong>关于 <code>SUMMARY.md</code></strong><br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Summary</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Introduction</span>](<span class="link">README.md</span>)</span><br></pre></td></tr></table></figure></p><p><code>SUMMARY.md</code> 其实就是书的章节目录，我们不妨稍作修改：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Jartto-GitBook-Demo</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">一、概要</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="code">    * [1.示例](README.md)</span></span><br><span class="line"><span class="code">    * [2.说明](README.md)</span></span><br><span class="line"><span class="code">    * [3.文档](README.md)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">二、高级</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="code">    * [1.配置](README.md)</span></span><br><span class="line"><span class="code">    * [2.插件](README.md)</span></span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo0.png" alt="演示目录"></p><h4 id="三、补充文档"><a href="#三、补充文档" class="headerlink" title="三、补充文档"></a>三、补充文档</h4><p>当然，<code>GitBook</code> 的远比我们想象的强大，我们还可以通过 <code>gitbook help</code> 来查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">build [book] [output]       build a book</span><br><span class="line">        --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line">        --format                Format to build to (Default is website; Values are website, json, ebook)</span><br><span class="line">        --[no-]timing           Print timing debug information (Default is <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">serve [book] [output]       serve the book as a website <span class="keyword">for</span> testing</span><br><span class="line">    --port                  Port <span class="keyword">for</span> server to listen on (Default is 4000)</span><br><span class="line">    --lrport                Port <span class="keyword">for</span> livereload server to listen on (Default is 35729)</span><br><span class="line">    --[no-]watch            Enable file watcher and live reloading (Default is <span class="literal">true</span>)</span><br><span class="line">    --[no-]live             Enable live reloading (Default is <span class="literal">true</span>)</span><br><span class="line">    --[no-]open             Enable opening book <span class="keyword">in</span> browser (Default is <span class="literal">false</span>)</span><br><span class="line">    --browser               Specify browser <span class="keyword">for</span> opening book (Default is )</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line">    --format                Format to build to (Default is website; Values are website, json, ebook)</span><br><span class="line"></span><br><span class="line">install [book]              install all plugins dependencies</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">parse [book]                parse and <span class="built_in">print</span> debug information about a book</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">init [book]                 setup and create files <span class="keyword">for</span> chapters</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">pdf [book] [output]         build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">epub [book] [output]        build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">mobi [book] [output]        build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br></pre></td></tr></table></figure></p><h4 id="四、有趣插件"><a href="#四、有趣插件" class="headerlink" title="四、有趣插件"></a>四、有趣插件</h4><p>了解上面的操作，使用 <code>GitBook</code> 已经没有任何障碍了。</p><div class="alert info"><p>如果你还想做一些个性化的操作，不妨继续深入。</p></div><p>要安装插架，需要我们有配置文件 <code>book.json</code>，我们可以在根目录下创建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch book.json</span><br></pre></td></tr></table></figure></p><p>写入基本配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Jartto-GitBook-Demo"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Jartto-GitBook-Demo"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"sphard"</span>,</span><br><span class="line">    <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">    <span class="attr">"root"</span>: <span class="string">"."</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"donate"</span>,</span><br><span class="line">        <span class="string">"github-buttons@2.1.0"</span>,</span><br><span class="line">        <span class="string">"edit-link"</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"donate"</span>: &#123;</span><br><span class="line">            <span class="attr">"wechat"</span>: <span class="string">"http://jartto.wang/images/wechatpay.jpg"</span>,</span><br><span class="line">            <span class="attr">"alipay"</span>: <span class="string">"http://jartto.wang/images/alipay.jpg"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"button"</span>: <span class="string">"打赏"</span>,</span><br><span class="line">            <span class="attr">"alipayText"</span>: <span class="string">"支付宝打赏"</span>,</span><br><span class="line">            <span class="attr">"wechatText"</span>: <span class="string">"微信打赏"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"github-buttons"</span>: &#123;</span><br><span class="line">            <span class="attr">"repo"</span>: <span class="string">"jartto/gitbook"</span>,</span><br><span class="line">            <span class="attr">"types"</span>: [</span><br><span class="line">                <span class="string">"star"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"size"</span>: <span class="string">"small"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"edit-link"</span>: &#123;</span><br><span class="line">            <span class="attr">"base"</span>: <span class="string">"https://github.com/jartto/gitbook/master"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Edit This Page"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插件安装通用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-plugin-[插件名]</span><br></pre></td></tr></table></figure></p><p>例如：我们要安装 <code>flexible-alerts</code> 信息框插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-plugin-flexible-alerts</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/plugin.png" alt="信息框插件"></p><p>还有很多可用插件，具体如下：</p><ol><li>信息框(<code>flexible-alerts</code>)</li><li>阅读统计（<code>pageview-count</code>）</li><li>侧边栏宽度可调节（<code>splitter</code>）</li><li>页脚版权（<code>page-copyright</code>）</li><li>打赏功能（<code>donate</code>）</li><li>分享当前页面（<code>sharing-plus</code>）</li><li>修改标题栏图标（<code>custom-favicon</code>）</li><li>复选框（<code>todo</code>）</li><li>显示图片名称（<code>image-captions</code>）</li><li>目录折叠（<code>toggle-chapters</code>）</li><li>分章节展示（<code>multipart</code>）</li><li>插入 <code>Logo</code>（<code>insert-logo</code>）</li><li><code>Google</code> 分析（<code>ga</code>）</li><li>返回顶部（<code>back-to-top-button</code>）</li><li>代码添加行号和复制按钮（<code>code</code>）</li><li>高级搜索，支持中文（<code>search-pro</code>）</li><li>添加 <code>Github</code> 图标（<code>github</code>）<br>…</li></ol><p>需要注意的是：<br><code>GitBook</code> 默认带有 <code>5</code> 个插件：</p><ul><li><code>highlight</code></li><li><code>search</code></li><li><code>sharing</code></li><li><code>fontsettings</code></li><li><code>livereload</code></li></ul><p>如果要去除自带的插件，可以在插件名称前面加 <code>-</code>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;:[</span><br><span class="line">    &quot;-search&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>小技巧：<code>NPM</code> 中搜索关键字 <a href="https://www.npmjs.com/search?q=gitbook-plugin" target="_blank" rel="noopener"><code>GitBook-Plugin</code></a>，发现更多插件。</p><h4 id="五、效果展示"><a href="#五、效果展示" class="headerlink" title="五、效果展示"></a>五、效果展示</h4><p>1.<code>GitBook</code> 扩展：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/gitbook1.png" alt="扩展 GitBook"></p><p>2.示例一：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo1.png" alt="示例一"></p><p>3.示例二：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo2.png" alt="示例二"></p><p>4.示例三：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo3.png" alt="示例三"></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p><a href="http://jartto.wang/2020/02/02/about-gitbook/">上文</a>介绍了 <code>GitBook</code> 的基本使用和一些实用插件，构建在线文档变得轻而易举。加上 <code>Github</code> 免费的托管平台，我们就可以干更多有趣的事情了。快输出你的 <code>HTML</code>、<code>PDF</code>、<code>eBook</code> 技术文档吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多童鞋在日常开发中都会有「说明文档」、「学习笔记」和「个人博客」的需求，那么最经济简洁的方式莫过于 &lt;code&gt;GitBook&lt;/code&gt; 方案了，&lt;code&gt;10&lt;/code&gt; 分钟学习，永久使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="gitbook" scheme="http://jartto.wang/tags/gitbook/"/>
    
      <category term="plugin" scheme="http://jartto.wang/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>系统负载看不懂？</title>
    <link href="http://jartto.wang/2020/01/20/system-load/"/>
    <id>http://jartto.wang/2020/01/20/system-load/</id>
    <published>2020-01-20T02:54:40.000Z</published>
    <updated>2020-01-20T08:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web 开发会经历「开发-上线-部署」三个过程，部署之后站点的运行状态如何却鲜有关注。如果我们要估算网站能承受多大的并发，你可能需要真正了解系统负载。<br><a id="more"></a></p><h4 id="一、先看场景"><a href="#一、先看场景" class="headerlink" title="一、先看场景"></a>一、先看场景</h4><p>1.服务器状态（<code>Linux</code> 服务器通过 <code>Top</code> 命令查看）<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/linux/system-load.png" alt="服务器状态"></p><p>2.数据监控<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/linux/load-avg.png" alt="平均负载"></p><p>上面是两个典型应用场景，我们可以直接在服务器查看系统负载。当然，也可以获取数据本地可视化显示。听起来不错，可是问题来了：</p><p>Q1：<code>load average</code>: 0.03, 0.12, 0.07 是什么？<br>Q2：为什么同时监控 1 分钟，5 分钟，15 分钟？</p><p>如果你对此有疑问，不妨继续阅读。</p><h4 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h4><div class="alert info"><p>为了便于理解，我们从「一个比喻」，「两个概念」和「三个边界」来说明。</p></div><p>1.<strong>一个比喻</strong><br>我们可以把 <code>CPU</code> 比喻成一条马路，进程任务就是马路上飞驰的汽车，<code>Load</code> 则表示马路的拥挤程度。</p><p>2.<strong>两个概念</strong><br>系统负载（System Load）：<br>系统 <code>CPU</code> 繁忙程度的度量，即有多少进程在等待被 <code>CPU</code> 调度（进程等待队列的长度）。</p><p>平均负载（Load Average）：<br>一段时间内系统的平均负载，这个一段时间一般取 1 分钟、5 分钟、15 分钟。</p><p>3.<strong>三个边界</strong><br>Load = 0，路上一辆车也没有；<br>Load = 0.7，一大半路上有车；<br>Load = 1，所有路段都有车，基本饱和状态，但是道路仍然能够通行；</p><p>阮一峰老师<a href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">理解 Linux 系统负荷</a>中举的这个例子很形象：</p><ul><li>系统负荷为 1.7，意味着车辆太多了，桥已经被占满了（100%），后面等着上桥的车辆为路面车辆的 70%。</li><li>系统负荷 2.0，意味着等待上桥的车辆与桥面的车辆一样多；</li><li>系统负荷 3.0，意味着等待上桥的车辆是桥面车辆的 2 倍。</li></ul><p>总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。</p><div class="alert success"><p>道路的通行能力，就是 <code>CPU</code> 的最大工作量；道路上的车辆，就是一个个等待 <code>CPU</code> 处理的进程（<code>Process</code>）。</p></div><h4 id="三、多核负载如何计算？"><a href="#三、多核负载如何计算？" class="headerlink" title="三、多核负载如何计算？"></a>三、多核负载如何计算？</h4><p>上文我们不管是路还是桥的例子，都是默认电脑只有一个 <code>CPU</code>，那如果多 <code>CPU</code>，情况又是如何呢？</p><div class="alert success"><p>很简单，<code>2</code> 个 <code>CPU</code>，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍。</p></div><p><code>2</code> 个 <code>CPU</code> 表明系统负载可以达到 <code>2.0</code>，此时每个 <code>CPU</code> 都达到 <code>100%</code> 的工作量。如果你的服务器是 <code>4</code> 核 <code>CPU</code>，那么系统负载极限就是 <code>4.0</code>。</p><h4 id="四、答题时间"><a href="#四、答题时间" class="headerlink" title="四、答题时间"></a>四、答题时间</h4><p>到这里，相信我们的 <code>Q1</code> 问题已经解决了。我们重点来看 <code>Q2</code>：为什么同时监控 <code>1</code> 分钟，<code>5</code> 分钟，<code>15</code> 分钟？</p><p><a href="https://www.w3cschool.cn/architectroad/architectroad-loadaverage.html" target="_blank" rel="noopener">一分钟理解负载 LoadAverage </a> 中有很好的解释：</p><ul><li>Load &lt; 0.7时：系统很闲，马路上没什么车，要考虑多部署一些服务</li><li>0.7 &lt; Load &lt; 1时：系统状态不错，马路可以轻松应对</li><li>Load == 1时：系统马上要处理不多来了，赶紧找一下原因</li><li>Load &gt; 5时：马路已经非常繁忙了，进入马路的每辆汽车都要无法很快的运行</li></ul><p>那么如果按照 1 分钟来评估系统负载，会被系统短暂的抖动所影响。</p><div class="alert success"><p>所以 1 分钟更多是作为一个参考度量，综合 5 分钟和 10 分钟使监控指标更加准确。</p></div><p>1 分钟 Load &gt; 5，5 分钟 Load &lt; 1，15 分钟 Load &lt; 1<br>短期内繁忙，中长期空闲，初步判断是一个「抖动」或者是「拥塞前兆」</p><p>1 分钟 Load &gt; 5，5 分钟 Load &gt; 1，15 分钟 Load &lt; 1<br>短期内繁忙，中期内紧张，很可能是一个「拥塞的开始」</p><p>1 分钟 Load &gt; 5，5 分钟 Load &gt; 5，15 分钟 Load &gt; 5<br>短中长期都繁忙，系统「正在拥塞」</p><p>1 分钟 Load &lt; 1，5 分钟 Load &gt; 1，15 分钟 Load &gt; 5：<br>短期内空闲，中长期繁忙，不用紧张，系统「拥塞正在好转」</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 开发会经历「开发-上线-部署」三个过程，部署之后站点的运行状态如何却鲜有关注。如果我们要估算网站能承受多大的并发，你可能需要真正了解系统负载。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="linux" scheme="http://jartto.wang/tags/linux/"/>
    
      <category term="load" scheme="http://jartto.wang/tags/load/"/>
    
      <category term="system" scheme="http://jartto.wang/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>人工智能时代，Web 前端能做什么？</title>
    <link href="http://jartto.wang/2020/01/01/web-ai/"/>
    <id>http://jartto.wang/2020/01/01/web-ai/</id>
    <published>2020-01-01T14:07:24.000Z</published>
    <updated>2020-01-05T15:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个项目，通过爬虫去抓取页面快照，然后对页面兼容性进行全面测试。但是遇到一个问题，抓取到海量页面之后，难道还要人工去分析吗？<br><a id="more"></a><br>类似的场景并不会少，是否可以让机器去帮我们实现，最终输出一个可靠报告？答案是肯定的，快照生成后，我们可以对大量快照进行分析，结合 OpenCV 跨平台计算机视觉库，实现图像处理和计算机视觉方面的数据分析，最终输出结果。</p><div class="alert success"><p>我们总会找到一些合适的场景用机器来代替人，而 AI 正是这个支点。</p></div><p>AI 如果是这个时代的契机，那么作为 Web 前端，在这人工智能时代，我们能做什么？</p><h4 id="一、什么是人工智能？"><a href="#一、什么是人工智能？" class="headerlink" title="一、什么是人工智能？"></a>一、什么是人工智能？</h4><p>人工智能（Artificial Intelligence），英文缩写为 AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p><p>1.计算机科学<br>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。</p><p>2.智慧「容器」<br>人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的「容器」。</p><p>3.信息加工<br>人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>4.研究目标<br>人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，总的说来，人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。</p><h4 id="二、有哪些场景会涉及到-AI？"><a href="#二、有哪些场景会涉及到-AI？" class="headerlink" title="二、有哪些场景会涉及到 AI？"></a>二、有哪些场景会涉及到 AI？</h4><p>如果要列举一下有哪些场景会用到 AI，我想可能不仅仅是如下这些：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/ai.png" alt="ai"></p><p>机器视觉，指纹识别，人脸识别，人脸对比，手势检测，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程，物体检测，视频跟踪等。</p><div class="alert info"><p>人工智能就其本质而言，是对人的思维的信息过程的模拟。</p></div><p>对于人的思维模拟可以从两条道路进行，<br>1.结构模拟，仿照人脑的结构机制，制造出「类人脑」的机器；<br>2.是功能模拟，暂时撇开人脑的内部结构，而从其功能过程进行模拟。<br>现代电子计算机的产生便是对人脑思维功能的模拟，是对人脑思维的信息过程的模拟。</p><h4 id="三、弱人工智能，强人工智能"><a href="#三、弱人工智能，强人工智能" class="headerlink" title="三、弱人工智能，强人工智能"></a>三、弱人工智能，强人工智能</h4><p>弱人工智能如今不断地迅猛发展，尤其是 2008 年经济危机后，美日欧希望借机器人等实现再工业化，工业机器人以比以往任何时候更快的速度发展，更加带动了弱人工智能和相关领域产业的不断突破，很多必须用人来做的工作如今已经能用机器人实现。</p><div class="alert danger"><p>强人工智能则暂时处于瓶颈，还需要科学家们和人类的努力。</p></div><p>人工智能是依赖机器学习的，<strong>数据和算法是机器学习的核心</strong>，而数据更为重要。按照解决问题的能力，我们可以把人工智能，分成两类：</p><ul><li>强人工智能：拥有自我意识，具备解决通用问题的能力</li><li>弱人工智能：没有自我意识，具备解决特定问题的能力</li></ul><p>目前，我们能看到的人工智能，几乎都是弱人工智能，在解决特定问题的能力上，超越了人类。</p><h4 id="四、AI-如何影响前端"><a href="#四、AI-如何影响前端" class="headerlink" title="四、AI 如何影响前端"></a>四、AI 如何影响前端</h4><p>1.数据可视化，依赖 <code>D3.js</code>，<code>ECharts</code>，<code>WebGL</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/kael.png" alt="kael"></p><p>2.模型可视化<br>用可视化的手段去解释模型，辅助算法同学调参。最简单的一个应用前端同学肯定非常熟悉，我们来看下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/dev.png" alt="chrome-dev"></p><p>是的，曲线函数和曲率我们很难记住，但是有相应的工具，会让一些<strong>数据和计算变得简单易懂</strong>。</p><p>3.相关技术<br>提到人工智能，和前端密切相关的几个 <code>JS</code> 类库有：</p><ul><li>tensorflow.js<br>基于 <code>tensorflow.js Node</code> 的 <code>tvnet</code> 算法，可以提取视频中的稠密光流。</li><li>deeplearning.js</li><li>kera.js</li></ul><p>高性能计算：</p><ul><li>asm.js</li><li>WebAssembly</li><li>GPU</li><li>Opencv，前端做 CV 算法，物体跟踪、图像处理、特征检测等等</li></ul><p>大家可能发现一个问题，一般的 <code>tensorflow</code> 模型动辄几百兆，在前端怎么跑呢？这就不得不提到 <code>MobileNet</code>，这是针对于移动端模型提出的神经网络架构，能极大地减少模型参数量，同理也能用到浏览器端上。</p><p>更多细节可以查看该文章：<a href="https://www.jianshu.com/p/e5f997713a4b" target="_blank" rel="noopener">前端与人工智能</a>，介绍非常到位。</p><h4 id="五、如何做？"><a href="#五、如何做？" class="headerlink" title="五、如何做？"></a>五、如何做？</h4><p>既然前端和人工智能有如此多的交集，那么我们该从何做起呢？不要着急，我们先来看一个完整的人工智能项目包含哪些内容。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/aiweb.png" alt="aiweb"></p><p>上图中，可以看到一个完整的人工智能项目是由：算法，数据，工程三部分构成。</p><p>工程部分我们可以理解为「大前端」，主要包含 5 部分：</p><ol><li>人机交互</li><li>数据可视化</li><li>产品 Web</li><li>算法执行</li><li>模型训练</li></ol><h4 id="六、简单应用"><a href="#六、简单应用" class="headerlink" title="六、简单应用"></a>六、简单应用</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/face.png" alt="pic"><br>1.<code>Tranck.js</code><br>就是纯浏览器的图像算法库，通过 <code>JS</code> 计算来执行算法逻辑</p><p>2.<code>regl-cnn</code><br>浏览器端的数字识别类库，与 <code>track.js</code> 不同的是，它利用浏览器的 <code>WebGL</code> 才操作 <code>GPU</code>，实现了 <code>CNN</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/cnn.gif" alt="cnn"></p><p>3.<code>ConvNetJS</code><br>浏览器端做深度学习算法训练的工具，<a href="https://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="noopener">官网地址</a></p><p>4.<code>Amazon Rekognition</code><br>基于同样由 <code>Amazon</code> 计算机视觉科学家开发的成熟且高度可扩展的深度学习技术，每天能够分析数十亿张 <code>Prime Photos</code> 图像。</p><p>5.对比学习：<code>Keras</code> 搭建 <code>CNN</code>，<code>RNN</code> 等常用神经网络</p><p>6.机器学习：<a href="https://github.com/wepe/MachineLearning" target="_blank" rel="noopener">MachineLearning</a></p><p>更多内容可以查看：<br>1.<a href="http://www.bslxx.com/m/view.php?aid=1922" target="_blank" rel="noopener">浏览器里运行的人工智能</a><br>2.<a href="https://yq.aliyun.com/articles/153198?t=t1" target="_blank" rel="noopener">前端在人工智能时代能做些什么</a></p><h4 id="七、深度学习"><a href="#七、深度学习" class="headerlink" title="七、深度学习"></a>七、深度学习</h4><p>深度学习，是英文 <code>Deep Learning</code> 的直译。它是实现机器学习的其中一种方式。机器学习还包含其它实现方案。</p><p>深度学习里，用到了人工神经网络，这是一个用计算机模拟大脑神经元运作模式的算法。同时，这个人工神经网络的隐藏层数量还必须足够多，才能构成深度神经网络。然后喂之以大量的训练数据，就是深度学习了。</p><p>换一个角度，如果隐藏层数量不多，而是每个隐藏层里包含的神经元数量很多，在形态上，它就是一个往宽度发展的神经网络结构。这时，可能就叫广度学习了。</p><div class="alert success"><p>目前，深度学习还是主流，它的训练效率，优于广度学习。</p></div><p>我们可以体验腾讯的一个深度学习案例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/ml.png" alt="pic"></p><p>更多有趣应用：<br>1.<a href="https://www.jianshu.com/p/1b33e432ba0e" target="_blank" rel="noopener"><code>TensorFlowJS</code> 学习</a><br>2.如何利用 <code>TensorFlow.js</code> 部署简单的 <a href="https://baijiahao.baidu.com/s?id=1606694239390920783&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener"><code>AI</code> 版「你画我猜」图像识别应用</a></p><h4 id="八、明确几个概念"><a href="#八、明确几个概念" class="headerlink" title="八、明确几个概念"></a>八、明确几个概念</h4><p>机器学习对我们来说确实陌生，所以一定要从明确一些常用的概念，这样才能提升学习的兴趣。我们来说一些可能会涉及到的内容（我也是正在摸索，目前就知道这些，逃～）</p><p>1.<strong>精确率</strong><br>是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。</p><p>2.<strong>召回率</strong><br>是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了</p><p>3.<strong>监督学习</strong><br>监督学习涉及到标注数据，计算机可以使用所提供的数据来识别新的样本。<br>监督学习的两种主要类型是分类和回归。在分类中，训练的机器将把一组数据分成特定的类。</p><p>4.<strong>无监督学习</strong><br>在无监督学习中，数据是未标注的。由于现实中，大多数的数据都是未标注的，因此这些算法特别有用。<br>无监督学习分为聚类和降维。</p><p>5.<strong>强化学习</strong><br>强化学习使用机器的历史和经验来做出决策。强化学习的经典应用是游戏。与监督和无监督学习相反，强化学习不注重提供「正确」的答案或输出。</p><h4 id="九、机器学习算法有哪些？"><a href="#九、机器学习算法有哪些？" class="headerlink" title="九、机器学习算法有哪些？"></a>九、机器学习算法有哪些？</h4><p>提到机器学习，大家肯定都会自然联想到需要很强的<strong>算法功底</strong>。没错，确实如此，所以我们需要对算法有一些了解。</p><p>那么<a href="https://www.cnblogs.com/xiyushimei/p/7874019.html" target="_blank" rel="noopener">机器学习</a>主要涉及到哪几类算法呢，我们来看看：</p><ul><li>模式识别</li><li>计算机视觉</li><li>数据挖掘</li><li>统计学习</li><li>语音识别</li><li>自然语言处理</li></ul><h4 id="九、机器学习涉及学科"><a href="#九、机器学习涉及学科" class="headerlink" title="九、机器学习涉及学科"></a>九、机器学习涉及学科</h4><div class="alert info"><p>主要围绕在这几方面：线性代数、微积分、概率和统计。</p></div><p>线性代数概念Top 3：</p><ol><li>矩阵运算</li><li>特征值/特征向量</li><li>向量空间和范数</li></ol><p>微积分概念Top 3：</p><ol><li>偏导数</li><li>向量值函数</li><li>方向梯度</li></ol><p>统计概念Top 3：</p><ol><li>贝叶斯定理</li><li>组合学</li><li>抽样方法</li></ol><h4 id="十、计算机视觉"><a href="#十、计算机视觉" class="headerlink" title="十、计算机视觉"></a>十、计算机视觉</h4><p><code>OpenCV</code> 是一个基于 <code>BSD</code> 许可（开源）发行的跨平台计算机视觉库，可以运行在 <code>Linux</code>、<code>Windows</code>、<code>Android</code> 和 <code>Mac OS</code> 操作系统上。</p><p>它轻量级而且高效——由一系列 <code>C</code> 函数和少量 <code>C++</code> 类构成，同时提供了 <code>Python</code>、<code>Ruby</code>、<code>MATLAB</code> 等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。</p><p>应用领域：<br>1、人机互动<br>2、物体识别<br>3、图像分割<br>4、人脸识别<br>5、动作识别<br>6、运动跟踪<br>7、机器人<br>8、运动分析<br>9、机器视觉<br>10、结构分析<br>11、汽车安全驾驶</p><p><code>OpenCV</code> 的应用领域非常广泛，包括图像拼接、图像降噪、产品质检、人机交互、人脸识别、动作识别、动作跟踪、无人驾驶等。</p><p><code>OpenCV</code> 还提供了机器学习模块，你可以使用正态贝叶斯、K最近邻、支持向量机、决策树、随机森林、人工神经网络等机器学习算法。</p><p>这里推荐几个相关学习网站：<br>1.<a href="https://opencv.org" target="_blank" rel="noopener">官网</a><br>2.<a href="http://c.biancheng.net/opencv/" target="_blank" rel="noopener">OpenCV教程</a><br>3.<a href="https://www.cnblogs.com/wangyaning/p/7854046.html" target="_blank" rel="noopener">图像对比</a></p><h4 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h4><p><code>AI</code> 涉及到很多的领域，并不是我们三言两语就能够说的明白。要真正的应用起来，还有很多的路要走。我相信，随着技术的发展，更多的场景将接入 <code>AI</code>，而 <code>Web</code> 则是其中的一个重要环节。加上 <code>Web</code> 跨平台特性，以及「算法-数据-工程」的驱动，未来在该领域一定会大放异彩。</p><p>很喜欢这句话：AI makes life better. FE makes AI better.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个项目，通过爬虫去抓取页面快照，然后对页面兼容性进行全面测试。但是遇到一个问题，抓取到海量页面之后，难道还要人工去分析吗？&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="ai" scheme="http://jartto.wang/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>CSS 渲染原理以及优化策略</title>
    <link href="http://jartto.wang/2019/10/23/css-theory-and-optimization/"/>
    <id>http://jartto.wang/2019/10/23/css-theory-and-optimization/</id>
    <published>2019-10-23T13:04:53.000Z</published>
    <updated>2019-11-07T08:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。<br><a id="more"></a><br>我们先来看看这张排行榜：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/rank.png" alt="Rank"></p><div class="alert info"><p>既然 CSS 这么重要，那么我们花点时间来研究相关原理也就物有所值了。</p></div><p>本节我们就来说说 CSS <strong>渲染以及优化</strong>相关的内容，主要围绕以下几点，由浅入深，了解来龙去脉：</p><p>1.浏览器构成<br>2.渲染引擎<br>3.CSS 特性<br>4.CSS 语法解析过程<br>5.CSS 选择器执行顺序<br>6.高效的 ComputedStyle<br>7.CSS 书写顺序对性能有影响吗<br>8.优化策略</p><h4 id="一、浏览器构成"><a href="#一、浏览器构成" class="headerlink" title="一、浏览器构成"></a>一、浏览器构成</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/browser.png" alt="Browser"></p><ul><li><p>User Interface：<br>用户界面，包括浏览器中可见的地址输入框、浏览器前进返回按钮、书签，历史记录等用户可操作的功能选项。</p></li><li><p>Browser engine：<br>浏览器引擎，可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据，是浏览器各个部分之间相互通信的核心。</p></li><li><p>Rendering engine：<br>渲染引擎，解析 DOM 文档和 CSS 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。</p></li><li><p>Networking：<br>网络功能模块，是浏览器开启网络线程发送请求以及下载资源的模块。</p></li><li><p>JavaScript Interpreter：<br>JS 引擎，解释和执行 JS 脚本部分，例如 V8 引擎。</p></li><li><p>UI Backend：<br>UI 后端则是用于绘制基本的浏览器窗口内控件，比如组合选择框、按钮、输入框等。</p></li><li><p>Data Persistence：<br>数据持久化存储，涉及 Cookie、LocalStorage 等一些客户端存储技术，可以通过浏览器引擎提供的 API 进行调用。</p></li></ul><!-- ![Render](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render.png) --><h4 id="二、渲染引擎"><a href="#二、渲染引擎" class="headerlink" title="二、渲染引擎"></a>二、渲染引擎</h4><p>渲染引擎，解析 <code>DOM</code> 文档和 <code>CSS</code> 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render2.png" alt="Render2"></p><p>上图中，我们需要关注两条主线：<br>其一，<code>HTML Parser</code> 生成的 <code>DOM</code> 树；<br>其二，<code>CSS Parser</code> 生成的 <code>Style Rules</code> ；</p><p>在这之后，<code>DOM</code> 树与 <code>Style Rules</code> 会生成一个新的对象，也就是我们常说的 <code>Render Tree</code> 渲染树，结合 <code>Layout</code> 绘制在屏幕上，从而展现出来。</p><h4 id="三、CSS-特性"><a href="#三、CSS-特性" class="headerlink" title="三、CSS 特性"></a>三、CSS 特性</h4><p>1.<strong>优先级</strong>：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/specificity1.png" alt="specificity1"><br>!important &gt; 行内样式（权重1000） &gt; ID 选择器（权重 100） &gt; 类选择器（权重 10） &gt; 标签（权重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><p>示例代码一：<a href="https://jsfiddle.net/a5xtdoq7/1/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/1/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>: yellow;&#125;</span><br></pre></td></tr></table></figure></p><p>猜一猜，文本会显示什么颜色？当你知道 「<code>ID</code> 选择器 &gt; 类选择器 」的时候，答案不言自明。</p><p>升级一下：<a href="https://jsfiddle.net/a5xtdoq7/3/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/3/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>: blue;&#125;</span><br></pre></td></tr></table></figure></p><p>这里就考查到了规则「类选择器 &gt; 继承」，<code>ID</code> 对文本来说是继承过来的属性，所以优先级不如直接作用在元素上面的类选择器。</p><p>2.<strong>继承性</strong></p><ul><li>继承得到的样式的优先级是最低的，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值；</li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级；</li></ul><p>有哪些属性是可以<a href="https://m.html.cn/qa/css3/12784.html" target="_blank" rel="noopener">继承</a>的呢，我们简单分一下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.font-family,font-size,font-weight 等 f 开头的 CSS 样式；</span><br><span class="line">2.text-align,text-indent 等 t 开头的样式；</span><br><span class="line">3.color；</span><br></pre></td></tr></table></figure></p><p>详细的规则，请看下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/inherent.png" alt="inherent"></p><p>示例代码二：<a href="https://jsfiddle.net/a5xtdoq7/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则定义如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red<span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-tag">ol</span> &#123; <span class="attribute">color </span>: green; &#125;</span><br></pre></td></tr></table></figure></p><p>增加了 <code>!important</code> ，猜一猜，文本显示什么颜色？</p><p>3.<strong>层叠性</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/specificity2.png" alt="specificity2"><br>层叠就是浏览器对多个样式来源进行叠加，最终确定结果的过程。<code>CSS</code> 之所以有「层叠」的概念，是因为有多个样式来源。</p><p><code>CSS</code> 层叠性是指 <code>CSS</code> 样式在针对同一元素配置同一属性时，<strong>依据层叠规则（权重）来处理冲突</strong>，选择应用权重高的 <code>CSS</code> 选择器所指定的属性，一般也被描述为权重高的覆盖权重低的，因此也称作层叠。</p><p>示例代码三：<a href="https://jsfiddle.net/a5xtdoq7/2/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/2/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"two one"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;<span class="attribute">color</span>: blue;&#125;</span><br></pre></td></tr></table></figure></p><p>如果两个类选择器同时作用呢，究竟以谁为准？这里我们要考虑样式表中两个类选择器的先后顺序，后面的会覆盖前面的，所以文本当然显示蓝色了。</p><p>升级代码：<a href="https://jsfiddle.net/a5xtdoq7/6/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/6/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: yellow; &#125;</span><br></pre></td></tr></table></figure></p><p>这个比较直接，算一下权重，谁大听谁的。</p><p>继续升级：<a href="https://jsfiddle.net/a5xtdoq7/7/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/7/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> <span class="selector-class">.two</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-id">#box3</span> &#123; <span class="attribute">color </span>: yellow; &#125;</span><br><span class="line"><span class="selector-id">#box1</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: blue; &#125;</span><br></pre></td></tr></table></figure></p><p>权重：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 2 1</span><br><span class="line">0 1 0 1</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure></p><p>验证一下：<a href="https://jsfiddle.net/a5xtdoq7/9/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/9/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> <span class="selector-class">.two</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red; &#125;</span><br><span class="line"><span class="selector-id">#box1</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: blue; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-class">.three</span> &#123; <span class="attribute">color </span>: green; &#125;</span><br></pre></td></tr></table></figure></p><p>权重：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 2 1</span><br><span class="line">0 1 0 1</span><br><span class="line">0 0 1 1</span><br></pre></td></tr></table></figure></p><p>如果你对上面这些问题都了如指掌，那么恭喜你，基础部分顺利过关，可以继续升级了！</p><h4 id="四、CSS-语法解析过程"><a href="#四、CSS-语法解析过程" class="headerlink" title="四、CSS 语法解析过程"></a>四、CSS 语法解析过程</h4><p>1.我们来把 <code>CSS</code> 拎出来看一下，<code>HTML Parser</code> 会生成 <code>DOM</code> 树，而 <code>CSS Parser</code> 会将解析结果附加到 <code>DOM</code> 树上，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render3.png" alt="render3"></p><p>2.<code>CSS</code> 有自己的规则，一般如下：<br><code>WebKit</code> 使用 <code>Flex</code> 和 <code>Bison</code> 解析器生成器，通过 <code>CSS</code> 语法文件自动创建解析器。<code>Bison</code> 会创建自下而上的移位归约解析器。<code>Firefox</code> 使用的是人工编写的自上而下的解析器。</p><p>这两种解析器都会将 <code>CSS</code> 文件解析成 <code>StyleSheet</code> 对象，且每个对象都包含 <code>CSS</code> 规则。<code>CSS</code> 规则对象则包含选择器和声明对象，以及其他与 <code>CSS</code> 语法对应的对象。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/css-rule.jpg" alt="css-rule"></p><p>3.<code>CSS</code> 解析过程会按照 <code>Rule</code>，<code>Declaration</code> 来操作：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/test_CSSOM.png" alt="CSSOM"></p><p>4.那么他是如何解析的呢，我们不妨打印一下 <code>CSS Rules</code>：<br>控制台输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].cssRules</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/rule2.png" alt="rule2"></p><p>打印出来的结果大致分为几类：</p><ul><li>cssText：存储当前节点规则字符串</li><li>parentRule：父节点的规则</li><li>parentStyleSheet：包含 cssRules，ownerNode，rules 规则</li><li>…</li></ul><div class="alert danger"><p>规则貌似有点看不懂，不用着急，我们接着往下看。</p></div><p>5.CSS 解析和 Webkit 有什么关系？<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/webkit2.png" alt="webkit2"><br><div class="alert info"><p>CSS 依赖 WebCore 来解析，而 WebCore 又是 Webkit 非常重要的一个模块。</p></div></p><p>要了解 <code>WebCore</code> 是如何解析的，我们需要查看<a href="https://github.com/WebKit/webkit/tree/master/Source/WebCore/css" target="_blank" rel="noopener">相关源码</a>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CSSRule* CSSParser::createStyleRule(CSSSelector* selector)  </span><br><span class="line">&#123;  </span><br><span class="line">    CSSStyleRule* rule = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (selector) &#123;  </span><br><span class="line">        rule = <span class="keyword">new</span> CSSStyleRule(styleElement);  </span><br><span class="line">        m_parsedStyleObjects.append(rule);  </span><br><span class="line">        rule-&gt;setSelector(sinkFloatingSelector(selector));  </span><br><span class="line">        rule-&gt;setDeclaration(<span class="keyword">new</span> CSSMutableStyleDeclaration(rule, parsedProperties, numParsedProperties));  </span><br><span class="line">    &#125;  </span><br><span class="line">    clearProperties();  </span><br><span class="line">    <span class="keyword">return</span> rule;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从该函数的实现可以很清楚的看到，解析器达到某条件需要创建一个 <code>CSSStyleRule</code> 的时候将调用该函数，该函数的功能是创建一个 <code>CSSStyleRule</code> ，并将其添加已解析的样式对象列表 <code>m_parsedStyleObjects</code> 中去，这里的对象就是指的 <code>Rule</code> 。</p><div class="alert warning"><p>注意：源码是为了参考理解，不需要逐行阅读！</p></div><p><code>Webkit</code> 使用了自动代码生成工具生成了相应的代码，也就是说词法分析和语法分析这部分代码是自动生成的，而 <code>Webkit</code> 中实现的 <code>CallBack</code> 函数就是在 <code>CSSParser</code> 中。</p><p>这时候就不得不提到 <code>AST</code> 了，我们继续剖析。</p><p>补充阅读：<a href="https://webkit.org/status/#?search=css" target="_blank" rel="noopener">Webkit 对 CSS 支持</a></p><p>6.<strong>关于 AST</strong><br>如果对 <code>AST</code> 还不了解，请移步<a href="http://jartto.wang/2018/11/17/about-ast/"><code>AST</code> 抽象语法树</a>。这里我们不做过多解释，主要围绕如何解析这一过程展开，先来看一张 <code>Babel</code> 转换过程图：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/ast1.png" alt="ast1"></p><p>我们来举一个简单的例子，声明一个箭头函数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jarttoTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<a href="https://astexplorer.net/" target="_blank" rel="noopener">在线编译</a>，生成如下结果：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/ast2.png" alt="ast2"></p><p>从<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上图</a>我们可以看出：我们的箭头函数被解析成了一段标准代码，包含了类型，起始位置，结束位置，变量声明的类型，变量名，函数名，箭头函数表达式等等。</p><p>标准的解析代码，我们可以对其进行一些加工和处理，之后通过相应 <code>API</code> 输出。很多场景都会用到这个过程，如：</p><ul><li>JS 反编译，语法解析</li><li>Babel 编译 ES6 语法</li><li>代码高亮</li><li>关键字匹配</li><li>作用域判断</li><li>代码压缩</li><li>…</li></ul><p>场景千千万，但是都离不开一个过程，那就是：<br><div class="alert info"><p>AST 转换过程：解析 - 转换 - 生成</p></div></p><p>到这里，<code>CSS</code> 如何解析的来龙去脉我们已经非常清楚了，可以回到<a href="#">文章</a>开头的那个流程图了，相信你一定会有另一翻感悟。</p><h4 id="五、CSS-选择器执行顺序"><a href="#五、CSS-选择器执行顺序" class="headerlink" title="五、CSS 选择器执行顺序"></a>五、CSS 选择器执行顺序</h4><p>渲染引擎解析 <code>CSS</code> 选择器时是从右往左解析，这是为什么呢？举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.jartto</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.yellow</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们按照「从左到右」的方式进行分析：<br>1.先找到所有 <code>div</code> 节点；<br>2.在 <code>div</code> 节点内找到所有的子 <code>div</code> ,并且是 <code>class = “jartto”</code>；<br>3.然后再依次匹配 <code>p span.yellow</code> 等情况；<br>4.遇到不匹配的情况，就必须回溯到一开始搜索的 <code>div</code> 或者 <code>p</code> 节点，然后去搜索下个节点，重复这样的过程。</p><div class="alert warning"><p>有没有觉得很低效，那么问题出在哪里？</p></div><p>这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在<strong>回溯匹配不符合规则的节点</strong>。</p><p>我们不妨换个思路，还以上面的示例为准：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.jartto</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.yellow</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们按照「从右向左」的方式进行分析：<br>1.首先就查找到 <code>class=“yellow”</code> 的 <code>span</code> 元素；<br>2.接着检测父节点是否为 <code>p</code> 元素，如果不是则进入同级其他节点的遍历，如果是则继续匹配父节点满足 <code>class=“jartto”</code> 的 <code>div</code> 容器；<br>3.这样就又减少了集合的元素，只有符合当前的子规则才会匹配再上一条子规则。</p><p>综上所述，我们可以得出结论：<br><div class="alert success"><p>浏览器 <code>CSS</code> 匹配核心算法的规则是以从右向左方式匹配节点的。</p></div></p><p>样做是为了减少无效匹配次数，从而匹配快、性能更优。所以，我们在书写 <code>CSS Selector</code> 时，从右向左的 <code>Selector Term</code> 匹配节点越少越好。</p><p>不同 <code>CSS</code> 解析器对 <code>CSS Rules</code> 解析速度差异也很大，感兴趣的童鞋可以看看：<a href="http://test.veryos.com/selector/slickspeed/index.html" target="_blank" rel="noopener">CSS 解析引擎</a>，这里不再赘述。</p><h4 id="六、高效的-ComputedStyle"><a href="#六、高效的-ComputedStyle" class="headerlink" title="六、高效的 ComputedStyle"></a>六、高效的 ComputedStyle</h4><p>浏览器还有一个非常棒的策略，在特定情况下，浏览器会共享 <code>Computed Style</code>，网页中能共享的标签非常多，所以能极大的提升执行效率！</p><div class="alert success"><p>如果能共享，那就不需要执行匹配算法了，执行效率自然非常高。</p></div><p>如果两个或多个 <code>Element</code> 的 <code>ComputedStyle</code> 不通过计算可以确认他们相等，那么这些<code>ComputedStyle</code> 相等的 <code>Elements</code> 只会计算一次样式，其余的仅仅共享该 <code>ComputedStyle</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如何高效共享 <code>Computed Style</code> ？<br>1.<code>TagName</code> 和 <code>Class</code> 属性必须一样；<br>2.不能有 <code>Style</code> 属性。哪怕 <code>Style</code> 属性相等，他们也不共享；<br>3.不能使用 <code>Sibling selector</code>，譬如: <code>first-child</code>, <code>:last-selector</code>, <code>+ selector</code><br>4.<code>mappedAttribute</code> 必须相等；</p><p>为了更好的说明，我们再举两个例子：</p><p>不能共享，<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上述</a>规则2：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>jartto's<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以共享，<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上述</a>规则4：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"middle"</span>&gt;</span>jartto's<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"middle"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>到这里，相信你对 <code>ComputedStyle</code> 有了更多的认识，代码也就更加精炼和高效了。</p><h4 id="七、CSS-书写顺序对性能有影响吗？"><a href="#七、CSS-书写顺序对性能有影响吗？" class="headerlink" title="七、CSS 书写顺序对性能有影响吗？"></a>七、CSS 书写顺序对性能有影响吗？</h4><p>书写顺序会对 <code>CSS</code> 性能有影响吗，这是个值得思考的问题。</p><p>需要注意的是：浏览器并不是一获取到 <code>CSS</code> 样式就立马开始解析，而是根据 <code>CSS</code> 样式的书写顺序将之按照 <code>DOM</code> 树的结构分布渲染样式，然后开始遍历每个树结点的 <code>CSS</code> 样式进行解析，此时的 <code>CSS</code> 样式的遍历顺序完全是按照之前的书写顺序。</p><div class="alert info"><p>在解析过程中，一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染。</p></div><p>我们来看看下面这个代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width: 150px;</span><br><span class="line">height: 150px;</span><br><span class="line">font-size: 24px;</span><br><span class="line">position: absolute;</span><br></pre></td></tr></table></figure></p><p>当浏览器解析到 <code>position</code> 的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染。</p><p>渲染引擎首先解除该元素在文档中所占位置，这就导致了该元素的占位情况发生了变化，其他元素可能会受到它回流的影响而重新排位。</p><p>我们对代码进行调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 150px;</span><br><span class="line">height: 150px;</span><br><span class="line">font-size: 24px;</span><br></pre></td></tr></table></figure></p><p>这样就能让渲染引擎更高效的工作，可是问题来了：<br><div class="alert warning"><p>在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？</p></div></p><p>这里有一个规范，建议顺序大致如下：<br>1.定位属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position  display  float  left  top  right  bottom   overflow  clear   z-index</span><br></pre></td></tr></table></figure></p><p>2.自身属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width  height  padding  border  margin   background</span><br></pre></td></tr></table></figure></p><p>3.文字样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family   font-size   font-style   font-weight   font-varient   color</span><br></pre></td></tr></table></figure></p><p>4.文本属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow</span><br></pre></td></tr></table></figure></p><p>5.CSS3中新增属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content   box-shadow   border-radius  transform</span><br></pre></td></tr></table></figure></p><p>当然，我们需要知道这个规则就够了，剩下的可以交给一些<strong>插件</strong>去做，譬如：<a href="https://github.com/CSSLint/csslint" target="_blank" rel="noopener">CSSLint</a>。能用代码实现的，千万不要去浪费人力。</p><h4 id="八、优化策略"><a href="#八、优化策略" class="headerlink" title="八、优化策略"></a>八、优化策略</h4><p>我们从浏览器构成，聊到了渲染引擎，再到 <code>CSS</code> 的解析原理，最后到执行顺序，做了一系列的探索。期望大家能从 <code>CSS</code> 的渲染原理中了解整个过程，从而写出更高效的代码。</p><p>1.使用 <code>id selector</code> 非常的高效。在使用 <code>id selector</code> 的时候需要注意一点：因为 <code>id</code> 是唯一的，所以不需要既指定 <code>id</code> 又指定 <code>tagName</code>：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#id1</span> &#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-id">#id1</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>2.避免深层次的 <code>node</code> ，譬如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red;&#125; </span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-tag">p-class</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>3.不要使用 <code>attribute selector</code>，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：<code>p[id=&quot;id1&quot;]</code>。这样将 <code>id selector</code> 退化成 <code>attribute selector</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[id="jartto"]</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="blog"]</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-id">#jartto</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="selector-class">.blog</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以参考如下 <a href="http://nec.netease.com/standard/css-sort.html" target="_blank" rel="noopener">Css 规范</a>。</p><p>5.遵守 <a href="https://github.com/CSSLint/csslint" target="_blank" rel="noopener">CSSLint</a> 规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">font-faces        　　　　  　　　不能使用超过5个web字体</span><br><span class="line">import        　　　　　　　 　　  禁止使用@import</span><br><span class="line">regex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器</span><br><span class="line">universal-selector    　　 　　  禁止使用通用选择器*</span><br><span class="line">unqualified-attributes    　　　禁止使用不规范的属性选择器</span><br><span class="line">zero-units            　　 　　　0后面不要加单位</span><br><span class="line">overqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器</span><br><span class="line">shorthand        　　　　　　　　 简写样式属性</span><br><span class="line">duplicate-background-images    相同的url在样式表中不超过一次</span><br></pre></td></tr></table></figure></p><p>6.减少 <code>CSS</code> 文档体积</p><ul><li>移除空的 CSS 规则（Remove empty rules）</li><li>值为 0 不需要单位</li><li>使用缩写</li><li>属性值为浮动小数 0.**，可以省略小数点之前的0；</li><li>不给 h1-h6 元素定义过多的样式</li></ul><p>7.<code>CSS Will Change</code><br><code>WillChange</code> 属性，允许作者提前告知浏览器的默认样式，使用一个专用的属性来通知浏览器留意接下来的变化，从而优化和分配内存。</p><p>8.不要使用 <code>@import</code><br>使用 <code>@import</code> 引入 <code>CSS</code> 会影响浏览器的并行下载。使用 <code>@import</code> 引用的 <code>CSS</code> 文件只有在引用它的那个 <code>CSS</code> 文件被下载、解析之后，浏览器才会知道还有另外一个 <code>CSS</code> 需要下载，这时才去下载，然后下载后开始解析、构建 <code>Render Tree</code> 等一系列操作。</p><p>多个 <code>@import</code> 会导致下载顺序紊乱。在 <code>IE</code> 中，<code>@import</code> 会引发资源文件的下载顺序被打乱，即排列在 <code>@import</code> 后面的 <code>JS</code> 文件先于 <code>@import</code> 下载，并且打乱甚至破坏 <code>@import</code> 自身的并行下载。</p><p>9.避免过分重排（Reflow）<br>浏览器重新计算布局位置与大小。<br>常见的重排元素;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">width </span><br><span class="line">height </span><br><span class="line">padding </span><br><span class="line">margin </span><br><span class="line">display </span><br><span class="line">border-width </span><br><span class="line">border </span><br><span class="line">top </span><br><span class="line">position </span><br><span class="line">font-size </span><br><span class="line">float </span><br><span class="line">text-align </span><br><span class="line">overflow-y </span><br><span class="line">font-weight </span><br><span class="line">overflow </span><br><span class="line">left </span><br><span class="line">font-family </span><br><span class="line">line-height </span><br><span class="line">vertical-align </span><br><span class="line">right </span><br><span class="line">clear </span><br><span class="line">white-space </span><br><span class="line">bottom </span><br><span class="line">min-height</span><br></pre></td></tr></table></figure></p><p>10.高效利用 <code>computedStyle</code> </p><ul><li>公共类</li><li>慎用 ChildSelector</li><li>尽可能共享</li></ul><p>更多请查看上文：<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">高效的 ComputedStyle</a></p><p>11.减少昂贵属性：<br>当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写 <code>CSS</code> 时，我们应该尽量减少使用昂贵属性，如：</p><ul><li>box-shadow</li><li>border-radius</li><li>filter</li><li>:nth-child</li></ul><p>12.依赖继承。如果某些属性可以继承，那么自然没有必要在写一遍。</p><p>13.遵守 <code>CSS</code> 顺序规则</p><p>上面就是对<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">本文</a>的一个总结，你了解 <code>CSS</code> 具体的实现原理，晓得规避错误书写方式，知道为什么这么优化，这就够了。</p><p>性能优化，进无止境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="css" scheme="http://jartto.wang/tags/css/"/>
    
      <category term="optimazation" scheme="http://jartto.wang/tags/optimazation/"/>
    
      <category term="原理" scheme="http://jartto.wang/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="优化" scheme="http://jartto.wang/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>网站优化，这些工具你一定用得着</title>
    <link href="http://jartto.wang/2019/09/08/web-optimization-tools/"/>
    <id>http://jartto.wang/2019/09/08/web-optimization-tools/</id>
    <published>2019-09-08T10:52:36.000Z</published>
    <updated>2019-09-10T08:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。在「<a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a>」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！<br><a id="more"></a></p><h4 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h4><div class="alert success"><p>关于优化工具，我们主要从两方面说起：「性能评估工具」和「优化工具」。</p></div><p>1.性能评估工具</p><ul><li>Lighthouse</li><li>PageSpeed</li><li>YSlow</li></ul><p>2.优化工具我们主要依赖「Chrome DevTools」，大致如下：</p><ul><li>Network</li><li>Performance</li><li>Show Third Party Badges</li><li>Block Request URL</li><li>Coverage</li><li>DOM</li><li>Rendering</li><li>Layer</li></ul><h4 id="二、Lighthouse"><a href="#二、Lighthouse" class="headerlink" title="二、Lighthouse"></a>二、Lighthouse</h4><p>1.<code>Lighthouse</code> 安装<br><code>Chrome Setting</code> - 更多工具 - 扩展程序 - 打开 <code>Chrome</code> 网上应用店 - <code>Lighthouse</code></p><p>2.插件 - 生成报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/lighthouse.png" alt="lighthouse"></p><div class="alert success"><p>报告是我们的一个重要参考指标，这是网站评估的通用方法。</p></div><p>当然，网站也会有不同的类别，<strong>关注指标</strong>也不尽相同，后续我们会继续探讨「如何制定合理的网站优化性能指标」。</p><p>3.优化建议<br><code>Lighthouse</code> 比较人性化的点在于他既提出了问题，同时也提出了解决建议。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/performance.png" alt="performance"></p><h4 id="三、PageSpeed"><a href="#三、PageSpeed" class="headerlink" title="三、PageSpeed"></a>三、PageSpeed</h4><p>1.使用 <code>PageSpeed</code><br>我们可以在「Chrome DevTools」菜单栏中找到并打开：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagespeed.png" alt="pagespeed"></p><p>2.分析报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagescore.png" alt="pagescore"></p><h4 id="四、Chrome-DevTools-Network"><a href="#四、Chrome-DevTools-Network" class="headerlink" title="四、Chrome DevTools - Network"></a>四、Chrome DevTools - Network</h4><p>1.关于 <code>Network</code> 我们重点关注标注的 3 处<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network.png" alt="network"></p><p>2.<code>Timing</code> 也是优化不可缺少的工具：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network1.png" alt="network1"></p><p>补充说明一下：<br><code>TTFB</code>：等待初始响应所用的时间，也称为第一字节的时间，这是我们判断服务器以及网络状况的重要指标。</p><div class="alert info"><p>此时间将捕捉到服务器往返的延迟时间，以及等待服务器传送响应所用的时间。</p></div><h4 id="五、Chrome-DevTools-Performance"><a href="#五、Chrome-DevTools-Performance" class="headerlink" title="五、Chrome DevTools - Performance"></a>五、Chrome DevTools - Performance</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf.png" alt="perf"></p><p>2.版面主要由 4 部分构成</p><ul><li>控制面板：录制，清除，配置记录期间需要捕获的信息</li><li><code>Overview</code>：页面性能的高级汇总，以及页面加载情况</li><li>火焰图：<code>CPU</code> 堆叠追踪的可视化</li><li>总览：饼图记录各部分耗时情况</li></ul><p>3.Overview 详解</p><ul><li><p>FPS<br>每秒帧数。绿色竖线越高，<code>FPS</code> 越高。 <code>FPS</code> 图表上的红色块表示长时间帧，很可能会出现卡顿。</p></li><li><p>CPU<br><code>CPU</code> 资源。此面积图指示消耗 <code>CPU</code> 资源的事件类型。</p></li><li><p>NET<br>每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。<br>每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。<br>深色部分表示传输时间（下载第一个和最后一个字节之间的时间）。</p></li></ul><div class="alert danger"><p>需要特别注意，<code>Performance</code> 工具中的每一种颜色其实都有自己的含义。</p></div><ul><li>HTML 文件为蓝色。</li><li>脚本为黄色。</li><li>样式表为紫色。</li><li>媒体文件为绿色。</li><li>其他资源为灰色。</li></ul><p>小技巧：<br><div class="alert info"><p>使用无痕模式，减少 Chrome 扩展程序会给应用的干扰。</p></div></p><p>4.火焰图</p><ul><li><p>Network<br><code>Network</code> 这里我们可以看出来，我们资源加载的一个顺序情况。什么时间加载了什么资源，通过这些，我们更直观的知道资源是否并行加载。</p></li><li><p>Frames<br><a href="http://jartto.wang/2019/09/08/web-optimization-tools/">上文</a>提及到的页面帧情况。</p></li><li><p>Interactions</p></li><li><p>Timings 中如下 5 个指标是我们优化的方向      </p><ul><li>First Paint</li><li>DOMContentLoaded Event</li><li>Onload Event</li><li>First Contentful Paint</li><li>First Meaningful Paint</li></ul></li><li><p>Main：展示了主线程运行状况。<br><code>X</code> 轴代表着时间，每个长条代表着一个 <code>event</code>。长条越长就代表这个 <code>event</code> 花费的时间越长。<br><code>Y</code> 轴代表了调用栈 <code>call stack</code> 。</p></li></ul><p>在栈里，上面的 <code>event</code> 调用了下面的 <code>event</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf1.png" alt="perf1"></p><p>注意红色警告：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf2.png" alt="perf2"></p><ul><li>JS Heap<br><code>JavaScript</code> 运行过程中的大部分数据都保存在堆 <code>Heap</code> 中，所以 <code>JavaScript</code> 性能分析另一个比较重要的方面是<strong>内存</strong>，也就是<strong>堆的分析</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf3.png" alt="perf3"></p><ul><li>打开 Performance 监视器</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf4.png" alt="perf4"></p><h4 id="六、Chrome-DevTools-Show-Third-Party-Badges"><a href="#六、Chrome-DevTools-Show-Third-Party-Badges" class="headerlink" title="六、Chrome DevTools - Show Third Party Badges"></a>六、Chrome DevTools - Show Third Party Badges</h4><p>很多情况下，并不是我们网站本身的问题，有可能你使用的三方资源拖累了站点性能。所以，我们需要使用 <code>Show Third Party Badges</code> 来进行排查。</p><p>1.测试站点：<a href="https://techcrunch.com/" target="_blank" rel="noopener">https://techcrunch.com/</a></p><p>2.打开控制面板：<code>Command + Shift + P</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge.png" alt="badge"></p><p>3.打开 <code>Network</code>，注意资源前面的<strong>彩色标志</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge1.png" alt="badge1"></p><div class="alert success"><p>三方资源都被标记出来了，移除或者替换那些影响性能的东西。</p></div><h4 id="七、Chrome-DevTools-Block-Request-URL"><a href="#七、Chrome-DevTools-Block-Request-URL" class="headerlink" title="七、Chrome DevTools - Block Request URL"></a>七、Chrome DevTools - Block Request URL</h4><p>对于项目中不确定是否有用的资源，我们可以使用 <code>Block Request URL</code> 来排除。</p><p>1.选中资源 - 右键 - <code>Block Request URL</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/block.png" alt="block"></p><div class="alert info"><p>阻止某些资源加载，<strong>控制变量法</strong>来排查页面性能问题。</p></div><h4 id="八、Chrome-DevTools-Coverage"><a href="#八、Chrome-DevTools-Coverage" class="headerlink" title="八、Chrome DevTools - Coverage"></a>八、Chrome DevTools - Coverage</h4><p>1.打开控制面板：<code>Command + Shift + P</code></p><p>2.输入：<code>Show Coverage</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/corvage.png" alt="corvage"></p><p>3.找到相应的文件，可以看到文件左侧已经标<strong>记出了部分代码的使用情况</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/coverage.png" alt="coverage"></p><p>解决思路也很简单：<br>尽可能去通过 <code>Webpack</code> 来<a href="http://jartto.wang/2019/02/16/web-optimization/">拆包</a>，控制大小在 <code>40KB</code> 以下，移除那些未使用代码。</p><h4 id="九、Chrome-DevTools-DOM"><a href="#九、Chrome-DevTools-DOM" class="headerlink" title="九、Chrome DevTools - DOM"></a>九、Chrome DevTools - DOM</h4><p>我们经常提到要优化 <code>Dom</code>，那么节点控制在什么范围才合理呢？</p><ul><li>总共少于 1500 个节点</li><li>最大深度为 32 个节点</li><li>不要存在子节点超过 60 个节点的父节点</li></ul><p>查看所有 <code>DOM</code> 节点数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>).length</span><br></pre></td></tr></table></figure></p><p>查看子元素个数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'body &gt; *'</span>).length</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>通常，只在需要时查找创建 DOM 节点的方法，并在不再需要时<strong>销毁</strong>它们。</p></div><h4 id="十、Chrome-DevTools-Rendering"><a href="#十、Chrome-DevTools-Rendering" class="headerlink" title="十、Chrome DevTools - Rendering"></a>十、Chrome DevTools - Rendering</h4><p>关于重渲对页面的影响，我们就不多说了。那么如何知道<strong>页面的渲染</strong>过程呢？我们可以通过 <code>Rendering</code> 来可视化查看。</p><p>1.打开 Rendering 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.png" alt="render"></p><p>2.刷新页面<br><div class="alert warning"><p>绿色区域越重，说明重复渲染的次数越多，通过优化 DOM 来减少无效渲染。</p></div></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.gif" alt="render"></p><h4 id="十一、Chrome-DevTools-Layer"><a href="#十一、Chrome-DevTools-Layer" class="headerlink" title="十一、Chrome DevTools - Layer"></a>十一、Chrome DevTools - Layer</h4><p>你可能会很好奇，为什么要查看图层？<br><div class="alert info"><p>这是因为，我们经常会在不知不觉的情况下搞乱了图层关系，或者增加了不合适的图层。</p></div></p><p>1.打开控制面板：<code>Command + Shift + P</code><br>2.选择 <code>Layer</code> 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/layer.png" alt="layer"></p><p>是不是图层问题就清清楚楚的摆在眼前了～</p><h4 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h4><p>通过优化工具，我们可以轻而易举的对网站进行定位分析。之后就可以快速展开优化，让网站高性能的运转起来。优化，也不过如此。</p><p>后续我们会深入了解一些优化相关的原理细节，如果你有优化相关的问题，欢迎一起探讨，一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。在「&lt;a href=&quot;http://jartto.wang/2019/02/16/web-optimization/&quot;&gt;网站优化实战&lt;/a&gt;」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="tools" scheme="http://jartto.wang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何减少开发中的 Bug？</title>
    <link href="http://jartto.wang/2019/08/24/how-to-decrease-bugs/"/>
    <id>http://jartto.wang/2019/08/24/how-to-decrease-bugs/</id>
    <published>2019-08-24T03:35:27.000Z</published>
    <updated>2019-08-24T06:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。<br><a id="more"></a></p><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>爱因斯坦曾经说过：「如果给我一个小时解答一道决定我生死的问题，我会花55分钟来弄清楚这道题到底是在问什么。一旦清楚了它在问什么，剩下的5分钟足够解答这个问题。」</p><p>虽然我们软件开发过程不会面临生死的抉择，但是却直接影响着用户的<strong>使用感受</strong>，决定着产品的走向。所以程序员如何减少开发中的 Bug，既反映了<strong>代码质量</strong>，也反映了个<strong>人综合能力</strong>。</p><p>那么我们该如何有效的减少开发中的 Bug 呢？</p><div class="alert info"><p>我觉得应该从两方面说起：业务层和代码层。</p></div><h4 id="二、业务层"><a href="#二、业务层" class="headerlink" title="二、业务层"></a>二、业务层</h4><p>软件开发过程我们就不细说了，直接来看最重要的几个节点：</p><p>1.需求讨论阶段<br>一定要明确需求，<strong>测试，开发，产品三方务必达成一致</strong>。前期如果存在没有明确的问题，那么后期就会造成无效返工和不必要的争执，这在日常开发尤为常见。</p><div class="alert success"><p>所以，软件开发前期，我们都会进行「评审，反讲，评估」三个阶段。</p></div><p>2.开发完成阶段<br>开发完成后，程序员首先要完成「自测」，也就是软件开发中的「冒烟测试」，确保主流程无误。否则，在开发工程师提交代码后，测试工程师步履维艰，无法有效开展测试，会造成极大的资源浪费。</p><p>更规范的流程需要测试工程师在需求明确之后写出「测试用例」，开发工程师在完成开发后，自行对照「测试用例」完成初步验证，之后就可以代码提测了。</p><p>这么做的好处就是既保证了「高质量的代码交付」，同时减少了测试工程师的工作量，我们何乐而不为呢？</p><p>3.提测<br>自测和提测有什么区别呢，从软件开发过程来看，其实开发工程师和测试工程师其实完成了不同阶段的测试：</p><p>开发工程师「白盒测试」：<br>是指实际运行被测程序，<strong>通过程序的源代码进行测试而不使用用户界面</strong>。这种类型的测试需要从代码句法发现内部代码在算法、溢出、路径和条件等方面的缺点或者错误，进而加以修正。<br><div class="alert info"><p>白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。</p></div></p><p>测试工程师实际进行的是「黑盒测试」。那么什么是「黑盒测试」呢？<br>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，<strong>在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试</strong>。</p><p>它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。<strong>黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试</strong>。</p><div class="alert warning"><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。</p></div><p>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误。</p><ul><li>功能不正确或遗漏；</li><li>界面错误；</li><li>输入和输出错误；</li><li>数据库访问错误；</li><li>性能错误；</li><li>初始化和终止错误等；</li></ul><p>更多细节请查看文章：<a href="https://baike.baidu.com/item/黑盒测试/934030?fr=aladdin" target="_blank" rel="noopener">黑盒测试</a></p><h4 id="三、代码层"><a href="#三、代码层" class="headerlink" title="三、代码层"></a>三、代码层</h4><p>代码层面，我们需要从以下几方面来说起：</p><p>1.<strong>Eslint 规避低级语法问题</strong><br>这个显而易见，编写代码过程发现问题，避免因为简单语法，如：漏写了逗号，变量名写错，大小写问题等</p><p>2.<strong>边界处理</strong><br>做好容错，必要的判空，还有就是代码边界问题。多想一想如果数组不存在，我们如何处理？如果数组越界，我们如何修复？如果数据缺失，我们如何使页面不崩溃？</p><p>3.<strong>单元测试</strong><br>如果时间允许，我们可以做好单元测试，每次编译代码，或者提测前启动脚本，确定测试脚本都覆盖到了核心代码，尽可能减少代码出错率。</p><p>4.<strong>积累</strong><br>为什么说要积累，其实道理很简单。随着开发经验的增长，你可能会碰到很多问题，那么如果细心积累，其实很多错误在不知不觉中就被处理了。反之，你会不断的掉入同一个坑里，在进坑与出坑中迷失自我。那么我们如何积累呢？</p><p><strong>首先</strong>，碰到自己不会的问题，如果第一时间没有解决，通过查找或者请教别人解决了，那么一定要用小本本记下来，最好使用云笔记。好处不言自明。</p><p><strong>其次</strong>，要积累自己的函数库，我们经常用到的一些方法，不妨自己做一个封装，不断沉淀。也许有一天，你会发现，自己不知不知觉中写出了一个 Lodash 函数库。</p><p><strong>最后</strong>，你可以积累优秀的代码片段，嗯，「我们不生产代码，只是优秀代码的搬运工」。</p><p>5.学习<br>一句话，没有什么比学习优秀开源代码更有趣的事情了。<strong>阅读优秀源码，学习作者思想，站在巨人肩膀上，你才能走的更远！</strong></p><div class="alert success"><p>做好上面这些，相信你一定会是一位出色的工程师。</p></div><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>对于这类开放问题仁者见仁，智者见智，我相信每个人都会有自己的看法，也会有自己一套独特的方法。<strong>不管黑猫白猫，能抓住老鼠的就是好猫</strong>。对于程序员来说，能减少 Bug 的方法就是好方法。</p><div class="alert info"><p>程序员群体流传一句话：不写代码就有没有 Bug。</p></div><p>我们不能因为怕犯错误而减少写代码，更应该知难而上，越挫越勇。要知道日常开发中 「Bug 是不可避免的，只能减少」。</p><p>当然，这不应该成为我们写出 Bug 推脱的理由。不断超越，方是永恒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="bug" scheme="http://jartto.wang/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>使用 Electron5.0 构建你的 React 项目</title>
    <link href="http://jartto.wang/2019/07/13/use-electron-5/"/>
    <id>http://jartto.wang/2019/07/13/use-electron-5/</id>
    <published>2019-07-13T05:51:17.000Z</published>
    <updated>2019-07-30T05:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要使用 Electron 来构建 React 项目，突然发现之前的 <a href="https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start" target="_blank" rel="noopener">Demo</a> 已经不能正常运行了，有些感概技术发展的迅猛。<br><a id="more"></a><br>如果你还不了解 <code>Electron</code>，可以看我之前的文章：<a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a>，理论知识没有变。如果你想了解 <code>Electron5.0</code> 版本如何构建 <code>React</code> 项目，不妨继续看本文。</p><div class="alert danger"><p>需要注意：网上流传的 1.0 版本的项目应该已经启动不了了。</p></div><h4 id="一、为什么要写此文"><a href="#一、为什么要写此文" class="headerlink" title="一、为什么要写此文"></a>一、为什么要写此文</h4><p>之前研究的时候，<code>Electron</code> 还是 <code>1.0</code> 版本，因此写了一系列的文章。</p><ul><li><a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a></li><li><a href="http://jartto.wang/2018/01/04/first-exploration-electron-2/">初探 Electron - 升华篇</a></li><li><a href="http://jartto.wang/2018/01/14/first-exploration-electron-3/">初探 Electron - 实践篇1</a></li><li><a href="http://jartto.wang/2018/01/21/first-exploration-electron-4/">初探 Electron - 实践篇2</a></li></ul><p>经过本次尝试，发现 <code>5.0</code> 版本有了更多的变化，所以不想误人子弟，索性更新此系列文章。</p><div class="alert info"><p>这次起手，我们就来构建一个 React 项目。</p></div><h4 id="二、创建-React-项目"><a href="#二、创建-React-项目" class="headerlink" title="二、创建 React 项目"></a>二、创建 React 项目</h4><p>1.首先，全局安装 <code>cli</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global create-react-app</span><br></pre></td></tr></table></figure></p><p>2.创建项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app electron5-react-demo</span><br></pre></td></tr></table></figure></p><p>3.启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> electron5-react-demo &amp;&amp; yarn start</span><br></pre></td></tr></table></figure></p><p>4.访问 <code>http://localhost:3000/</code> 如果看到如下页面，说明你的 <code>React</code> 项目已经成功启动了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/react.png" alt="react"></p><h4 id="三、集成-Electron-环境"><a href="#三、集成-Electron-环境" class="headerlink" title="三、集成 Electron 环境"></a>三、集成 Electron 环境</h4><p>1.首先需要安装 <code>Electron</code> 和 <code>Electron-builder</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add electron electron-builder --dev</span><br></pre></td></tr></table></figure></p><p>2.增加相应开发工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add wait-on concurrently --dev</span><br><span class="line">yarn add cross-env electron-is-dev</span><br></pre></td></tr></table></figure></p><p>3.项目根目录下新建文件：<code>electron.js</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch public/electron.js</span><br></pre></td></tr></table></figure></p><p>此时项目目录如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│   ├── electron.js</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.js</span><br><span class="line">│   ├── App.test.js</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   └── serviceWorker.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><p>4.修改代码，可以去<a href="https://github.com/electron/electron-quick-start/blob/master/main.js" target="_blank" rel="noopener">官网</a>上拷贝一份内容，写入 <code>electron.js</code>，具体如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules to control application life and create native browser window</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">+ <span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      preload: path.join(__dirname, <span class="string">'preload.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+  mainWindow.loadURL(</span><br><span class="line">+  isDev</span><br><span class="line">+  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">+  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">+  );</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  <span class="comment">// mainWindow.webContents.openDevTools()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">    <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) app.quit()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it's common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this file you can include the rest of your app's specific main process</span></span><br><span class="line"><span class="comment">// code. You can also put them in separate files and require them here.</span></span><br></pre></td></tr></table></figure></p><p>注意我们做了两处修改（加号位置）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入环境变量：</span></span><br><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置启动文件</span></span><br><span class="line">mainWindow.loadURL(</span><br><span class="line">  isDev</span><br><span class="line">  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>5.修改 <code>package.json</code> 文件，总共两处：<br>其一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"electron5-react-demo"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">+    <span class="string">"main"</span>: <span class="string">"public/electron.js"</span>,</span><br><span class="line">+    <span class="string">"homepage"</span>: <span class="string">"./"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其二，修改启动项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"react-start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line"><span class="string">"react-build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line"><span class="string">"electron-start"</span>: <span class="string">"electron ."</span>,</span><br><span class="line"><span class="string">"electron-build"</span>: <span class="string">"electron-builder"</span>,</span><br><span class="line"><span class="string">"release"</span>: <span class="string">"yarn react-build &amp;&amp; electron-builder --publish=always"</span>,</span><br><span class="line"><span class="string">"build"</span>: <span class="string">"yarn react-build &amp;&amp; yarn electron-build"</span>,</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"concurrently \"cross-env BROWSER=none yarn react-start\" \"wait-on http://localhost:3000 &amp;&amp; electron .\""</span></span><br><span class="line"><span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line"><span class="string">"eject"</span>: <span class="string">"react-scripts eject"</span>,</span><br></pre></td></tr></table></figure></p><h4 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>看到如下界面，恭喜你，已经成功启动了：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/electron.png" alt="Electron"></p><div class="alert info"><p>试着修改一下吧，热修改也已经生效了。</p></div><h4 id="五、构建"><a href="#五、构建" class="headerlink" title="五、构建"></a>五、构建</h4><p>如果你想构建，可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>需要注意：构建会同时构建 React 和 Electron 两个项目。</p></div><p>构建完成后，项目目录中会出现一个 <code>dist</code> 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── builder-effective-config.yaml</span><br><span class="line">├── electron5-react-demo-0.1.0-mac.zip</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg.blockmap</span><br><span class="line">├── latest-mac.yml</span><br><span class="line">└── mac</span><br><span class="line">    └── electron5-react-demo.app</span><br></pre></td></tr></table></figure></p><p>目录中的 <code>dmg</code> 就是 <code>Mac</code> 上面的安装程序，双击安装：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/dmg.png" alt="dmg"></p><p>安装之后去运行吧，到这里，我们已经完成了整个项目。</p><h4 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h4><ul><li><a href="https://electronjs.org/docs?q=react" target="_blank" rel="noopener">Electron 文档</a></li><li><a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">API</a></li><li><a href="https://medium.com/@impaachu/how-to-build-a-react-based-electron-app-d0f27413f17f" target="_blank" rel="noopener">How to build a React based Electron app</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要使用 Electron 来构建 React 项目，突然发现之前的 &lt;a href=&quot;https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt; 已经不能正常运行了，有些感概技术发展的迅猛。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="electron" scheme="http://jartto.wang/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>Git 代码统计</title>
    <link href="http://jartto.wang/2019/07/09/git-stats/"/>
    <id>http://jartto.wang/2019/07/09/git-stats/</id>
    <published>2019-07-09T07:09:34.000Z</published>
    <updated>2019-07-09T08:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。<br><a id="more"></a></p><h4 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h4><p>目前大部分的项目可能都会用到 <code>Git</code> 来做代码管理，那么我们在不断的修改项目的过程中，可能会关注如下几个问题：</p><p>1.每个参与者贡献代码量，按劳分配某些资源🙈；<br>2.参与者的代码增删量，提交次数等；<br>3.统计活跃度；</p><div class="alert info"><p>那么，如何来对代码量做统计呢？</p></div><h4 id="二、常规操作"><a href="#二、常规操作" class="headerlink" title="二、常规操作"></a>二、常规操作</h4><p>一般情况，我们可以直接通过 <code>Git log</code> 来统计，如：</p><p>1.统计个人代码量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;jartto&quot; --pretty=tformat: --numstat | awk &apos;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&apos; -</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/code.png" alt="code"></p><p>2.贡献值统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort -u | wc -l</span><br></pre></td></tr></table></figure></p><p>3.查看排名前 5 的贡献者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>更多 <code>log</code> 操作可以请移步：<a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a>。</p></div><p>这时候，你可能在想：有没有省时省力的方式呢，顺便帮我生成报告。答案是肯定的，是时候请出我们的 <code>git_stats</code> 了。</p><h4 id="三、使用-git-stats"><a href="#三、使用-git-stats" class="headerlink" title="三、使用 git_stats"></a>三、使用 git_stats</h4><p>1.首先，我们需要全局安装 <code>git_stats</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install git_stats</span><br></pre></td></tr></table></figure></p><p>2.接下来，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git_stats generate</span><br></pre></td></tr></table></figure></p><p>3.打开 <code>git_stats</code> 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> git_stats &amp;&amp; open index.html</span><br></pre></td></tr></table></figure></p><h4 id="四、演示"><a href="#四、演示" class="headerlink" title="四、演示"></a>四、演示</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/gitstats.png" alt="generate"></p><p>2.<code>Dashboard</code> 可视化<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/activity.png" alt="activity"></p><p>如果你对 <code>git_stats</code> 生成的一大堆文件不满意，我们还有一种方式可以「无侵入」，同时显得更加「高冷」。</p><h4 id="五、补充：cloc"><a href="#五、补充：cloc" class="headerlink" title="五、补充：cloc"></a>五、补充：<code>cloc</code></h4><div class="alert info"><p>cloc 最优秀的地方就是「简洁粗暴」，我们来尝试一下。</p></div><p>1.尝试一下 <code>cloc</code>，首先，全局安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cloc</span><br></pre></td></tr></table></figure></p><p>2.简单用例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cloc [options] &lt;file(s)/dir(s)/git <span class="built_in">hash</span>(es)&gt;</span><br><span class="line">    Count physical lines of <span class="built_in">source</span> code and comments <span class="keyword">in</span> the given files</span><br><span class="line">    (may be archives such as compressed tarballs or zip files) and/or</span><br><span class="line">    recursively below the given directories or git commit hashes.</span><br><span class="line">    Example:    cloc src/ include/ main.c</span><br><span class="line"></span><br><span class="line">cloc [options] --diff &lt;set1&gt;  &lt;set2&gt;</span><br><span class="line">    Compute differences of physical lines of <span class="built_in">source</span> code and comments</span><br><span class="line">    between any pairwise combination of directory names, archive</span><br><span class="line">    files or git commit hashes.</span><br><span class="line">    Example:    cloc --diff Python-3.5.tar.xz python-3.6/</span><br></pre></td></tr></table></figure></p><p>3.使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: cloc [options] &lt;file(s)/dir(s)/git hash(es)&gt; | &lt;set 1&gt; &lt;set 2&gt; | &lt;report files&gt;</span><br></pre></td></tr></table></figure></p><p>进入项目，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc .</span><br></pre></td></tr></table></figure></p><p>稍等片刻，就会有一个输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">JavaScript                       10319         172724         254924         951843</span><br><span class="line">HTML                               679         120179           3665         224595</span><br><span class="line">JSON                              1714            256              0         182127</span><br><span class="line">Markdown                          1400          63461              2         171768</span><br><span class="line">C++                                 69           3538           3197          20331</span><br><span class="line">Python                              51           4292           7801          19137</span><br><span class="line">C/C++ Header                       117           3628           2033          18942</span><br><span class="line">CSS                                113           2011            823          16594</span><br><span class="line">XML                                 32           4427           1300          11277</span><br><span class="line">Sass                                65            282            414           4255</span><br><span class="line">Stylus                              60            539            593           3215</span><br><span class="line">YAML                               189            324            413           3039</span><br><span class="line">D                                   57              0              0           3003</span><br><span class="line">EJS                                113             43              8           2160</span><br><span class="line">reStructuredText                    18            681             51           2122</span><br><span class="line">Bourne Shell                        20            394            398           1875</span><br><span class="line">SVG                                  5              0              1           1646</span><br><span class="line">LESS                                13             26             33           1343</span><br><span class="line">make                                42            378            245           1310</span><br><span class="line">TypeScript                          17            276            584           1161</span><br><span class="line">Perl                                 1             87            170            582</span><br><span class="line">DTD                                  1            179            177            514</span><br><span class="line">m4                                   2             40              2            266</span><br><span class="line">Lisp                                 3             42             38            264</span><br><span class="line">Bourne Again Shell                   8             43             24            161</span><br><span class="line">C                                    4             40             37            149</span><br><span class="line">Ruby                                 6             24              5            140</span><br><span class="line">JSON5                                2              0              0            123</span><br><span class="line">CoffeeScript                         3             18             28             99</span><br><span class="line">Handlebars                           4             18              0             96</span><br><span class="line">Smarty                               6             17             30             91</span><br><span class="line">Windows Resource File                1              1              1             33</span><br><span class="line">DOS Batch                            5              2              0             16</span><br><span class="line">IDL                                  1              1              0             11</span><br><span class="line">zsh                                  1              4             13              7</span><br><span class="line">-----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>4.更多的使用命令，可以查看帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc --help</span><br></pre></td></tr></table></figure></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>上文介绍了三种 <code>Git</code> 代码统计方式：</p><p>1.通过 <code>Git log</code> 统计，稍微会麻烦一些，需要有一些 <code>awk</code> 知识的储备；<br>2.使用插件 <code>git_stats</code> 来生成可视化报告，对用户友好。美中不足就是会在当前项目增加很多 <code>html</code> 统计可视化文件；<br>3.命令行工具 <code>cloc</code>，简单易用，无侵入，使用门槛低；</p><div class="alert success"><p>综上所述，我们可以按照自己的使用场景来灵活的选用不同方式。</p></div><h4 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h4><ul><li><a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a></li><li><a href="https://www.zhihu.com/question/22004842/answer/177254508" target="_blank" rel="noopener">有哪些比较好用的代码量统计工具？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="git" scheme="http://jartto.wang/tags/git/"/>
    
      <category term="stats" scheme="http://jartto.wang/tags/stats/"/>
    
      <category term="git_stats" scheme="http://jartto.wang/tags/git-stats/"/>
    
  </entry>
  
</feed>
