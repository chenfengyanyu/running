<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jartto&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/ee1200dca3e1b26043739f4bd08bfc12</icon>
  <subtitle>Jartto 个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jartto.wang/"/>
  <updated>2019-10-26T08:14:52.572Z</updated>
  <id>http://jartto.wang/</id>
  
  <author>
    <name>Jartto</name>
    <email>jartto@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 渲染原理以及优化策略</title>
    <link href="http://jartto.wang/2019/10/23/css-theory-and-optimization/"/>
    <id>http://jartto.wang/2019/10/23/css-theory-and-optimization/</id>
    <published>2019-10-23T13:04:53.000Z</published>
    <updated>2019-10-26T08:14:52.572Z</updated>
    
    <content type="html"><![CDATA[<p>提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。<br><a id="more"></a><br>我们先来看看这张排行榜：<br><img src alt></p><h4 id="一、浏览器构成"><a href="#一、浏览器构成" class="headerlink" title="一、浏览器构成"></a>一、浏览器构成</h4><ul><li>User Interface：用户界面，包括浏览器中可见的地址输入框、浏览器前进返回按钮、书签，历史记录等用户可操作的功能选项。</li><li>Browser engine：浏览器引擎，可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据，是浏览器各个部分之间相互通信的核心。</li><li>Rendering engine：渲染引擎，解析 DOM 文档和 CSS 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。</li><li>Networking：网络功能模块，是浏览器开启网络线程发送请求以及下载资源的模块。</li><li>JavaScript Interpreter：JS 引擎，解释和执行 JS 脚本部分，例如 V8 引擎。</li><li>UI Backend：UI 后端则是用于绘制基本的浏览器窗口内控件，比如组合选择框、按钮、输入框等。</li><li>Data Persistence：数据持久化存储，涉及 Cookie、LocalStorage 等一些客户端存储技术，可以通过浏览器引擎提供的 API 进行调用。</li></ul><h4 id="二、渲染引擎"><a href="#二、渲染引擎" class="headerlink" title="二、渲染引擎"></a>二、渲染引擎</h4><h4 id="三、CSS-特性"><a href="#三、CSS-特性" class="headerlink" title="三、CSS 特性"></a>三、CSS 特性</h4><h4 id="四、CSS-语法解析过程"><a href="#四、CSS-语法解析过程" class="headerlink" title="四、CSS 语法解析过程"></a>四、CSS 语法解析过程</h4><h4 id="五、CSS-选择器执行顺序"><a href="#五、CSS-选择器执行顺序" class="headerlink" title="五、CSS 选择器执行顺序"></a>五、CSS 选择器执行顺序</h4><h4 id="六、高效的-ComputedStyle"><a href="#六、高效的-ComputedStyle" class="headerlink" title="六、高效的 ComputedStyle"></a>六、高效的 ComputedStyle</h4><h4 id="七、CSS-书写顺序对性能有影响吗？"><a href="#七、CSS-书写顺序对性能有影响吗？" class="headerlink" title="七、CSS 书写顺序对性能有影响吗？"></a>七、CSS 书写顺序对性能有影响吗？</h4><h4 id="八、优化策略"><a href="#八、优化策略" class="headerlink" title="八、优化策略"></a>八、优化策略</h4><p>1.使用 id selector 非常的高效。在使用 id selector 的时候需要注意一点：因为 id 是唯一的，所以不需要既指定 id 又指定 tagName：<br>/<em> Bad  </em>/<br>p#id1 {color:red;}  </p><p>/<em> Good  </em>/</p><p>#id1 {color:red;}</p><p>2.避免深层次的 node ，譬如：<br>/<em> Bad  </em>/<br>div &gt; div &gt; div &gt; p {color:red;}<br>/<em> Good  </em>/<br>p-class{color:red;}</p><p>3.不要使用 attribute selector，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：p[id=”id1”]。这样将 id selector 退化成 attribute selector。<br>/<em> Bad  </em>/<br>p[id=”id1”]{color:red;}<br>p[class=”class1”]{color:red;}<br>/<em> Good  </em>/</p><p>#id1{color:red;}<br>.class1{color:red;}<br>4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：<br>.foo {-moz-border-radius: 5px;border-radius: 5px; }<br>Css 规范：<a href="http://nec.netease.com/standard/css-sort.html" target="_blank" rel="noopener">http://nec.netease.com/standard/css-sort.html</a><br>5.遵守 CSSLint 规则：<a href="https://github.com/CSSLint/csslint" target="_blank" rel="noopener">https://github.com/CSSLint/csslint</a><br>font-faces        　　　　  　　　不能使用超过5个web字体<br>import        　　　　　　　 　　  禁止使用@import<br>regex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器<br>universal-selector    　　 　　  禁止使用通用选择器*<br>unqualified-attributes    　　　禁止使用不规范的属性选择器<br>zero-units            　　 　　　0后面不要加单位<br>overqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器<br>shorthand        　　　　　　　　 简写样式属性<br>duplicate-background-images    相同的url在样式表中不超过一次<br>6.减少 CSS 文档体积<br>-移除空的css规则（Remove empty rules）<br>-值为 0 不需要单位<br>-使用缩写<br>-属性值为浮动小数0.**，可以省略小数点之前的0；<br>-不给 h1-h6 元素定义过多的样式<br>7.CSS Will Change<br>WillChange 属性，允许作者提前告知浏览器的默认样式，使用一个专用的属性来通知浏览器留意接下来的变化，从而优化和分配内存。</p><p>8.不要使用@import<br>使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。<br>多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。</p><p>9.避免过分重排（reflow）<br>浏览器重新计算布局位置与大小。<br>常见的重排元素;<br>width<br>height<br>padding<br>margin<br>display<br>border-width<br>border<br>top<br>position<br>font-size<br>float<br>text-align<br>overflow-y<br>font-weight<br>overflow<br>left<br>font-family<br>line-height<br>vertical-align<br>right<br>clear<br>white-space<br>bottom<br>min-height<br>10.高效利用 computedStyle<br>公共类<br>慎用 ChildSelector<br>11.减少昂贵属性：<br>当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。<br>12.依赖继承。如果某些属性可以继承，那么自然没有必要在写一遍。</p><p>13.遵守 CSS 顺序规则</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="css" scheme="http://jartto.wang/tags/css/"/>
    
      <category term="optimazation" scheme="http://jartto.wang/tags/optimazation/"/>
    
      <category term="原理" scheme="http://jartto.wang/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="优化" scheme="http://jartto.wang/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>网站优化，这些工具你一定用得着</title>
    <link href="http://jartto.wang/2019/09/08/web-optimization-tools/"/>
    <id>http://jartto.wang/2019/09/08/web-optimization-tools/</id>
    <published>2019-09-08T10:52:36.000Z</published>
    <updated>2019-09-10T08:14:33.202Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。在「<a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a>」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！<br><a id="more"></a></p><h4 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h4><div class="alert success"><p>关于优化工具，我们主要从两方面说起：「性能评估工具」和「优化工具」。</p></div><p>1.性能评估工具</p><ul><li>Lighthouse</li><li>PageSpeed</li><li>YSlow</li></ul><p>2.优化工具我们主要依赖「Chrome DevTools」，大致如下：</p><ul><li>Network</li><li>Performance</li><li>Show Third Party Badges</li><li>Block Request URL</li><li>Coverage</li><li>DOM</li><li>Rendering</li><li>Layer</li></ul><h4 id="二、Lighthouse"><a href="#二、Lighthouse" class="headerlink" title="二、Lighthouse"></a>二、Lighthouse</h4><p>1.<code>Lighthouse</code> 安装<br><code>Chrome Setting</code> - 更多工具 - 扩展程序 - 打开 <code>Chrome</code> 网上应用店 - <code>Lighthouse</code></p><p>2.插件 - 生成报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/lighthouse.png" alt="lighthouse"></p><div class="alert success"><p>报告是我们的一个重要参考指标，这是网站评估的通用方法。</p></div><p>当然，网站也会有不同的类别，<strong>关注指标</strong>也不尽相同，后续我们会继续探讨「如何制定合理的网站优化性能指标」。</p><p>3.优化建议<br><code>Lighthouse</code> 比较人性化的点在于他既提出了问题，同时也提出了解决建议。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/performance.png" alt="performance"></p><h4 id="三、PageSpeed"><a href="#三、PageSpeed" class="headerlink" title="三、PageSpeed"></a>三、PageSpeed</h4><p>1.使用 <code>PageSpeed</code><br>我们可以在「Chrome DevTools」菜单栏中找到并打开：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagespeed.png" alt="pagespeed"></p><p>2.分析报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagescore.png" alt="pagescore"></p><h4 id="四、Chrome-DevTools-Network"><a href="#四、Chrome-DevTools-Network" class="headerlink" title="四、Chrome DevTools - Network"></a>四、Chrome DevTools - Network</h4><p>1.关于 <code>Network</code> 我们重点关注标注的 3 处<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network.png" alt="network"></p><p>2.<code>Timing</code> 也是优化不可缺少的工具：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network1.png" alt="network1"></p><p>补充说明一下：<br><code>TTFB</code>：等待初始响应所用的时间，也称为第一字节的时间，这是我们判断服务器以及网络状况的重要指标。</p><div class="alert info"><p>此时间将捕捉到服务器往返的延迟时间，以及等待服务器传送响应所用的时间。</p></div><h4 id="五、Chrome-DevTools-Performance"><a href="#五、Chrome-DevTools-Performance" class="headerlink" title="五、Chrome DevTools - Performance"></a>五、Chrome DevTools - Performance</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf.png" alt="perf"></p><p>2.版面主要由 4 部分构成</p><ul><li>控制面板：录制，清除，配置记录期间需要捕获的信息</li><li><code>Overview</code>：页面性能的高级汇总，以及页面加载情况</li><li>火焰图：<code>CPU</code> 堆叠追踪的可视化</li><li>总览：饼图记录各部分耗时情况</li></ul><p>3.Overview 详解</p><ul><li><p>FPS<br>每秒帧数。绿色竖线越高，<code>FPS</code> 越高。 <code>FPS</code> 图表上的红色块表示长时间帧，很可能会出现卡顿。</p></li><li><p>CPU<br><code>CPU</code> 资源。此面积图指示消耗 <code>CPU</code> 资源的事件类型。</p></li><li><p>NET<br>每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。<br>每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。<br>深色部分表示传输时间（下载第一个和最后一个字节之间的时间）。</p></li></ul><div class="alert danger"><p>需要特别注意，<code>Performance</code> 工具中的每一种颜色其实都有自己的含义。</p></div><ul><li>HTML 文件为蓝色。</li><li>脚本为黄色。</li><li>样式表为紫色。</li><li>媒体文件为绿色。</li><li>其他资源为灰色。</li></ul><p>小技巧：<br><div class="alert info"><p>使用无痕模式，减少 Chrome 扩展程序会给应用的干扰。</p></div></p><p>4.火焰图</p><ul><li><p>Network<br><code>Network</code> 这里我们可以看出来，我们资源加载的一个顺序情况。什么时间加载了什么资源，通过这些，我们更直观的知道资源是否并行加载。</p></li><li><p>Frames<br><a href="http://jartto.wang/2019/09/08/web-optimization-tools/">上文</a>提及到的页面帧情况。</p></li><li><p>Interactions</p></li><li><p>Timings 中如下 5 个指标是我们优化的方向      </p><ul><li>First Paint</li><li>DOMContentLoaded Event</li><li>Onload Event</li><li>First Contentful Paint</li><li>First Meaningful Paint</li></ul></li><li><p>Main：展示了主线程运行状况。<br><code>X</code> 轴代表着时间，每个长条代表着一个 <code>event</code>。长条越长就代表这个 <code>event</code> 花费的时间越长。<br><code>Y</code> 轴代表了调用栈 <code>call stack</code> 。</p></li></ul><p>在栈里，上面的 <code>event</code> 调用了下面的 <code>event</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf1.png" alt="perf1"></p><p>注意红色警告：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf2.png" alt="perf2"></p><ul><li>JS Heap<br><code>JavaScript</code> 运行过程中的大部分数据都保存在堆 <code>Heap</code> 中，所以 <code>JavaScript</code> 性能分析另一个比较重要的方面是<strong>内存</strong>，也就是<strong>堆的分析</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf3.png" alt="perf3"></p><ul><li>打开 Performance 监视器</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf4.png" alt="perf4"></p><h4 id="六、Chrome-DevTools-Show-Third-Party-Badges"><a href="#六、Chrome-DevTools-Show-Third-Party-Badges" class="headerlink" title="六、Chrome DevTools - Show Third Party Badges"></a>六、Chrome DevTools - Show Third Party Badges</h4><p>很多情况下，并不是我们网站本身的问题，有可能你使用的三方资源拖累了站点性能。所以，我们需要使用 <code>Show Third Party Badges</code> 来进行排查。</p><p>1.测试站点：<a href="https://techcrunch.com/" target="_blank" rel="noopener">https://techcrunch.com/</a></p><p>2.打开控制面板：<code>Command + Shift + P</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge.png" alt="badge"></p><p>3.打开 <code>Network</code>，注意资源前面的<strong>彩色标志</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge1.png" alt="badge1"></p><div class="alert success"><p>三方资源都被标记出来了，移除或者替换那些影响性能的东西。</p></div><h4 id="七、Chrome-DevTools-Block-Request-URL"><a href="#七、Chrome-DevTools-Block-Request-URL" class="headerlink" title="七、Chrome DevTools - Block Request URL"></a>七、Chrome DevTools - Block Request URL</h4><p>对于项目中不确定是否有用的资源，我们可以使用 <code>Block Request URL</code> 来排除。</p><p>1.选中资源 - 右键 - <code>Block Request URL</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/block.png" alt="block"></p><div class="alert info"><p>阻止某些资源加载，<strong>控制变量法</strong>来排查页面性能问题。</p></div><h4 id="八、Chrome-DevTools-Coverage"><a href="#八、Chrome-DevTools-Coverage" class="headerlink" title="八、Chrome DevTools - Coverage"></a>八、Chrome DevTools - Coverage</h4><p>1.打开控制面板：<code>Command + Shift + P</code></p><p>2.输入：<code>Show Coverage</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/corvage.png" alt="corvage"></p><p>3.找到相应的文件，可以看到文件左侧已经标<strong>记出了部分代码的使用情况</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/coverage.png" alt="coverage"></p><p>解决思路也很简单：<br>尽可能去通过 <code>Webpack</code> 来<a href="http://jartto.wang/2019/02/16/web-optimization/">拆包</a>，控制大小在 <code>40KB</code> 以下，移除那些未使用代码。</p><h4 id="九、Chrome-DevTools-DOM"><a href="#九、Chrome-DevTools-DOM" class="headerlink" title="九、Chrome DevTools - DOM"></a>九、Chrome DevTools - DOM</h4><p>我们经常提到要优化 <code>Dom</code>，那么节点控制在什么范围才合理呢？</p><ul><li>总共少于 1500 个节点</li><li>最大深度为 32 个节点</li><li>不要存在子节点超过 60 个节点的父节点</li></ul><p>查看所有 <code>DOM</code> 节点数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>).length</span><br></pre></td></tr></table></figure></p><p>查看子元素个数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'body &gt; *'</span>).length</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>通常，只在需要时查找创建 DOM 节点的方法，并在不再需要时<strong>销毁</strong>它们。</p></div><h4 id="十、Chrome-DevTools-Rendering"><a href="#十、Chrome-DevTools-Rendering" class="headerlink" title="十、Chrome DevTools - Rendering"></a>十、Chrome DevTools - Rendering</h4><p>关于重渲对页面的影响，我们就不多说了。那么如何知道<strong>页面的渲染</strong>过程呢？我们可以通过 <code>Rendering</code> 来可视化查看。</p><p>1.打开 Rendering 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.png" alt="render"></p><p>2.刷新页面<br><div class="alert warning"><p>绿色区域越重，说明重复渲染的次数越多，通过优化 DOM 来减少无效渲染。</p></div></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.gif" alt="render"></p><h4 id="十一、Chrome-DevTools-Layer"><a href="#十一、Chrome-DevTools-Layer" class="headerlink" title="十一、Chrome DevTools - Layer"></a>十一、Chrome DevTools - Layer</h4><p>你可能会很好奇，为什么要查看图层？<br><div class="alert info"><p>这是因为，我们经常会在不知不觉的情况下搞乱了图层关系，或者增加了不合适的图层。</p></div></p><p>1.打开控制面板：<code>Command + Shift + P</code><br>2.选择 <code>Layer</code> 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/layer.png" alt="layer"></p><p>是不是图层问题就清清楚楚的摆在眼前了～</p><h4 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h4><p>通过优化工具，我们可以轻而易举的对网站进行定位分析。之后就可以快速展开优化，让网站高性能的运转起来。优化，也不过如此。</p><p>后续我们会深入了解一些优化相关的原理细节，如果你有优化相关的问题，欢迎一起探讨，一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。在「&lt;a href=&quot;http://jartto.wang/2019/02/16/web-optimization/&quot;&gt;网站优化实战&lt;/a&gt;」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="tools" scheme="http://jartto.wang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何减少开发中的 Bug？</title>
    <link href="http://jartto.wang/2019/08/24/how-to-decrease-bugs/"/>
    <id>http://jartto.wang/2019/08/24/how-to-decrease-bugs/</id>
    <published>2019-08-24T03:35:27.000Z</published>
    <updated>2019-08-24T06:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。<br><a id="more"></a></p><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>爱因斯坦曾经说过：「如果给我一个小时解答一道决定我生死的问题，我会花55分钟来弄清楚这道题到底是在问什么。一旦清楚了它在问什么，剩下的5分钟足够解答这个问题。」</p><p>虽然我们软件开发过程不会面临生死的抉择，但是却直接影响着用户的<strong>使用感受</strong>，决定着产品的走向。所以程序员如何减少开发中的 Bug，既反映了<strong>代码质量</strong>，也反映了个<strong>人综合能力</strong>。</p><p>那么我们该如何有效的减少开发中的 Bug 呢？</p><div class="alert info"><p>我觉得应该从两方面说起：业务层和代码层。</p></div><h4 id="二、业务层"><a href="#二、业务层" class="headerlink" title="二、业务层"></a>二、业务层</h4><p>软件开发过程我们就不细说了，直接来看最重要的几个节点：</p><p>1.需求讨论阶段<br>一定要明确需求，<strong>测试，开发，产品三方务必达成一致</strong>。前期如果存在没有明确的问题，那么后期就会造成无效返工和不必要的争执，这在日常开发尤为常见。</p><div class="alert success"><p>所以，软件开发前期，我们都会进行「评审，反讲，评估」三个阶段。</p></div><p>2.开发完成阶段<br>开发完成后，程序员首先要完成「自测」，也就是软件开发中的「冒烟测试」，确保主流程无误。否则，在开发工程师提交代码后，测试工程师步履维艰，无法有效开展测试，会造成极大的资源浪费。</p><p>更规范的流程需要测试工程师在需求明确之后写出「测试用例」，开发工程师在完成开发后，自行对照「测试用例」完成初步验证，之后就可以代码提测了。</p><p>这么做的好处就是既保证了「高质量的代码交付」，同时减少了测试工程师的工作量，我们何乐而不为呢？</p><p>3.提测<br>自测和提测有什么区别呢，从软件开发过程来看，其实开发工程师和测试工程师其实完成了不同阶段的测试：</p><p>开发工程师「白盒测试」：<br>是指实际运行被测程序，<strong>通过程序的源代码进行测试而不使用用户界面</strong>。这种类型的测试需要从代码句法发现内部代码在算法、溢出、路径和条件等方面的缺点或者错误，进而加以修正。<br><div class="alert info"><p>白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。</p></div></p><p>测试工程师实际进行的是「黑盒测试」。那么什么是「黑盒测试」呢？<br>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，<strong>在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试</strong>。</p><p>它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。<strong>黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试</strong>。</p><div class="alert warning"><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。</p></div><p>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误。</p><ul><li>功能不正确或遗漏；</li><li>界面错误；</li><li>输入和输出错误；</li><li>数据库访问错误；</li><li>性能错误；</li><li>初始化和终止错误等；</li></ul><p>更多细节请查看文章：<a href="https://baike.baidu.com/item/黑盒测试/934030?fr=aladdin" target="_blank" rel="noopener">黑盒测试</a></p><h4 id="三、代码层"><a href="#三、代码层" class="headerlink" title="三、代码层"></a>三、代码层</h4><p>代码层面，我们需要从以下几方面来说起：</p><p>1.<strong>Eslint 规避低级语法问题</strong><br>这个显而易见，编写代码过程发现问题，避免因为简单语法，如：漏写了逗号，变量名写错，大小写问题等</p><p>2.<strong>边界处理</strong><br>做好容错，必要的判空，还有就是代码边界问题。多想一想如果数组不存在，我们如何处理？如果数组越界，我们如何修复？如果数据缺失，我们如何使页面不崩溃？</p><p>3.<strong>单元测试</strong><br>如果时间允许，我们可以做好单元测试，每次编译代码，或者提测前启动脚本，确定测试脚本都覆盖到了核心代码，尽可能减少代码出错率。</p><p>4.<strong>积累</strong><br>为什么说要积累，其实道理很简单。随着开发经验的增长，你可能会碰到很多问题，那么如果细心积累，其实很多错误在不知不觉中就被处理了。反之，你会不断的掉入同一个坑里，在进坑与出坑中迷失自我。那么我们如何积累呢？</p><p><strong>首先</strong>，碰到自己不会的问题，如果第一时间没有解决，通过查找或者请教别人解决了，那么一定要用小本本记下来，最好使用云笔记。好处不言自明。</p><p><strong>其次</strong>，要积累自己的函数库，我们经常用到的一些方法，不妨自己做一个封装，不断沉淀。也许有一天，你会发现，自己不知不知觉中写出了一个 Lodash 函数库。</p><p><strong>最后</strong>，你可以积累优秀的代码片段，嗯，「我们不生产代码，只是优秀代码的搬运工」。</p><p>5.学习<br>一句话，没有什么比学习优秀开源代码更有趣的事情了。<strong>阅读优秀源码，学习作者思想，站在巨人肩膀上，你才能走的更远！</strong></p><div class="alert success"><p>做好上面这些，相信你一定会是一位出色的工程师。</p></div><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>对于这类开放问题仁者见仁，智者见智，我相信每个人都会有自己的看法，也会有自己一套独特的方法。<strong>不管黑猫白猫，能抓住老鼠的就是好猫</strong>。对于程序员来说，能减少 Bug 的方法就是好方法。</p><div class="alert info"><p>程序员群体流传一句话：不写代码就有没有 Bug。</p></div><p>我们不能因为怕犯错误而减少写代码，更应该知难而上，越挫越勇。要知道日常开发中 「Bug 是不可避免的，只能减少」。</p><p>当然，这不应该成为我们写出 Bug 推脱的理由。不断超越，方是永恒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="bug" scheme="http://jartto.wang/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>使用 Electron5.0 构建你的 React 项目</title>
    <link href="http://jartto.wang/2019/07/13/use-electron-5/"/>
    <id>http://jartto.wang/2019/07/13/use-electron-5/</id>
    <published>2019-07-13T05:51:17.000Z</published>
    <updated>2019-07-30T05:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要使用 Electron 来构建 React 项目，突然发现之前的 <a href="https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start" target="_blank" rel="noopener">Demo</a> 已经不能正常运行了，有些感概技术发展的迅猛。<br><a id="more"></a><br>如果你还不了解 <code>Electron</code>，可以看我之前的文章：<a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a>，理论知识没有变。如果你想了解 <code>Electron5.0</code> 版本如何构建 <code>React</code> 项目，不妨继续看本文。</p><div class="alert danger"><p>需要注意：网上流传的 1.0 版本的项目应该已经启动不了了。</p></div><h4 id="一、为什么要写此文"><a href="#一、为什么要写此文" class="headerlink" title="一、为什么要写此文"></a>一、为什么要写此文</h4><p>之前研究的时候，<code>Electron</code> 还是 <code>1.0</code> 版本，因此写了一系列的文章。</p><ul><li><a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a></li><li><a href="http://jartto.wang/2018/01/04/first-exploration-electron-2/">初探 Electron - 升华篇</a></li><li><a href="http://jartto.wang/2018/01/14/first-exploration-electron-3/">初探 Electron - 实践篇1</a></li><li><a href="http://jartto.wang/2018/01/21/first-exploration-electron-4/">初探 Electron - 实践篇2</a></li></ul><p>经过本次尝试，发现 <code>5.0</code> 版本有了更多的变化，所以不想误人子弟，索性更新此系列文章。</p><div class="alert info"><p>这次起手，我们就来构建一个 React 项目。</p></div><h4 id="二、创建-React-项目"><a href="#二、创建-React-项目" class="headerlink" title="二、创建 React 项目"></a>二、创建 React 项目</h4><p>1.首先，全局安装 <code>cli</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global create-react-app</span><br></pre></td></tr></table></figure></p><p>2.创建项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app electron5-react-demo</span><br></pre></td></tr></table></figure></p><p>3.启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> electron5-react-demo &amp;&amp; yarn start</span><br></pre></td></tr></table></figure></p><p>4.访问 <code>http://localhost:3000/</code> 如果看到如下页面，说明你的 <code>React</code> 项目已经成功启动了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/react.png" alt="react"></p><h4 id="三、集成-Electron-环境"><a href="#三、集成-Electron-环境" class="headerlink" title="三、集成 Electron 环境"></a>三、集成 Electron 环境</h4><p>1.首先需要安装 <code>Electron</code> 和 <code>Electron-builder</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add electron electron-builder --dev</span><br></pre></td></tr></table></figure></p><p>2.增加相应开发工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add wait-on concurrently --dev</span><br><span class="line">yarn add cross-env electron-is-dev</span><br></pre></td></tr></table></figure></p><p>3.项目根目录下新建文件：<code>electron.js</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch public/electron.js</span><br></pre></td></tr></table></figure></p><p>此时项目目录如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│   ├── electron.js</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.js</span><br><span class="line">│   ├── App.test.js</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   └── serviceWorker.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><p>4.修改代码，可以去<a href="https://github.com/electron/electron-quick-start/blob/master/main.js" target="_blank" rel="noopener">官网</a>上拷贝一份内容，写入 <code>electron.js</code>，具体如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules to control application life and create native browser window</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">+ <span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      preload: path.join(__dirname, <span class="string">'preload.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+  mainWindow.loadURL(</span><br><span class="line">+  isDev</span><br><span class="line">+  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">+  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">+  );</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  <span class="comment">// mainWindow.webContents.openDevTools()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">    <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) app.quit()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it's common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this file you can include the rest of your app's specific main process</span></span><br><span class="line"><span class="comment">// code. You can also put them in separate files and require them here.</span></span><br></pre></td></tr></table></figure></p><p>注意我们做了两处修改（加号位置）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入环境变量：</span></span><br><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置启动文件</span></span><br><span class="line">mainWindow.loadURL(</span><br><span class="line">  isDev</span><br><span class="line">  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>5.修改 <code>package.json</code> 文件，总共两处：<br>其一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"electron5-react-demo"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">+    <span class="string">"main"</span>: <span class="string">"public/electron.js"</span>,</span><br><span class="line">+    <span class="string">"homepage"</span>: <span class="string">"./"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其二，修改启动项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"react-start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line"><span class="string">"react-build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line"><span class="string">"electron-start"</span>: <span class="string">"electron ."</span>,</span><br><span class="line"><span class="string">"electron-build"</span>: <span class="string">"electron-builder"</span>,</span><br><span class="line"><span class="string">"release"</span>: <span class="string">"yarn react-build &amp;&amp; electron-builder --publish=always"</span>,</span><br><span class="line"><span class="string">"build"</span>: <span class="string">"yarn react-build &amp;&amp; yarn electron-build"</span>,</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"concurrently \"cross-env BROWSER=none yarn react-start\" \"wait-on http://localhost:3000 &amp;&amp; electron .\""</span></span><br><span class="line"><span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line"><span class="string">"eject"</span>: <span class="string">"react-scripts eject"</span>,</span><br></pre></td></tr></table></figure></p><h4 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>看到如下界面，恭喜你，已经成功启动了：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/electron.png" alt="Electron"></p><div class="alert info"><p>试着修改一下吧，热修改也已经生效了。</p></div><h4 id="五、构建"><a href="#五、构建" class="headerlink" title="五、构建"></a>五、构建</h4><p>如果你想构建，可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>需要注意：构建会同时构建 React 和 Electron 两个项目。</p></div><p>构建完成后，项目目录中会出现一个 <code>dist</code> 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── builder-effective-config.yaml</span><br><span class="line">├── electron5-react-demo-0.1.0-mac.zip</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg.blockmap</span><br><span class="line">├── latest-mac.yml</span><br><span class="line">└── mac</span><br><span class="line">    └── electron5-react-demo.app</span><br></pre></td></tr></table></figure></p><p>目录中的 <code>dmg</code> 就是 <code>Mac</code> 上面的安装程序，双击安装：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/dmg.png" alt="dmg"></p><p>安装之后去运行吧，到这里，我们已经完成了整个项目。</p><h4 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h4><ul><li><a href="https://electronjs.org/docs?q=react" target="_blank" rel="noopener">Electron 文档</a></li><li><a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">API</a></li><li><a href="https://medium.com/@impaachu/how-to-build-a-react-based-electron-app-d0f27413f17f" target="_blank" rel="noopener">How to build a React based Electron app</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要使用 Electron 来构建 React 项目，突然发现之前的 &lt;a href=&quot;https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt; 已经不能正常运行了，有些感概技术发展的迅猛。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="electron" scheme="http://jartto.wang/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>Git 代码统计</title>
    <link href="http://jartto.wang/2019/07/09/git-stats/"/>
    <id>http://jartto.wang/2019/07/09/git-stats/</id>
    <published>2019-07-09T07:09:34.000Z</published>
    <updated>2019-07-09T08:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。<br><a id="more"></a></p><h4 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h4><p>目前大部分的项目可能都会用到 <code>Git</code> 来做代码管理，那么我们在不断的修改项目的过程中，可能会关注如下几个问题：</p><p>1.每个参与者贡献代码量，按劳分配某些资源🙈；<br>2.参与者的代码增删量，提交次数等；<br>3.统计活跃度；</p><div class="alert info"><p>那么，如何来对代码量做统计呢？</p></div><h4 id="二、常规操作"><a href="#二、常规操作" class="headerlink" title="二、常规操作"></a>二、常规操作</h4><p>一般情况，我们可以直接通过 <code>Git log</code> 来统计，如：</p><p>1.统计个人代码量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;jartto&quot; --pretty=tformat: --numstat | awk &apos;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&apos; -</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/code.png" alt="code"></p><p>2.贡献值统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort -u | wc -l</span><br></pre></td></tr></table></figure></p><p>3.查看排名前 5 的贡献者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>更多 <code>log</code> 操作可以请移步：<a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a>。</p></div><p>这时候，你可能在想：有没有省时省力的方式呢，顺便帮我生成报告。答案是肯定的，是时候请出我们的 <code>git_stats</code> 了。</p><h4 id="三、使用-git-stats"><a href="#三、使用-git-stats" class="headerlink" title="三、使用 git_stats"></a>三、使用 git_stats</h4><p>1.首先，我们需要全局安装 <code>git_stats</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install git_stats</span><br></pre></td></tr></table></figure></p><p>2.接下来，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git_stats generate</span><br></pre></td></tr></table></figure></p><p>3.打开 <code>git_stats</code> 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> git_stats &amp;&amp; open index.html</span><br></pre></td></tr></table></figure></p><h4 id="四、演示"><a href="#四、演示" class="headerlink" title="四、演示"></a>四、演示</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/gitstats.png" alt="generate"></p><p>2.<code>Dashboard</code> 可视化<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/activity.png" alt="activity"></p><p>如果你对 <code>git_stats</code> 生成的一大堆文件不满意，我们还有一种方式可以「无侵入」，同时显得更加「高冷」。</p><h4 id="五、补充：cloc"><a href="#五、补充：cloc" class="headerlink" title="五、补充：cloc"></a>五、补充：<code>cloc</code></h4><div class="alert info"><p>cloc 最优秀的地方就是「简洁粗暴」，我们来尝试一下。</p></div><p>1.尝试一下 <code>cloc</code>，首先，全局安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cloc</span><br></pre></td></tr></table></figure></p><p>2.简单用例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cloc [options] &lt;file(s)/dir(s)/git <span class="built_in">hash</span>(es)&gt;</span><br><span class="line">    Count physical lines of <span class="built_in">source</span> code and comments <span class="keyword">in</span> the given files</span><br><span class="line">    (may be archives such as compressed tarballs or zip files) and/or</span><br><span class="line">    recursively below the given directories or git commit hashes.</span><br><span class="line">    Example:    cloc src/ include/ main.c</span><br><span class="line"></span><br><span class="line">cloc [options] --diff &lt;set1&gt;  &lt;set2&gt;</span><br><span class="line">    Compute differences of physical lines of <span class="built_in">source</span> code and comments</span><br><span class="line">    between any pairwise combination of directory names, archive</span><br><span class="line">    files or git commit hashes.</span><br><span class="line">    Example:    cloc --diff Python-3.5.tar.xz python-3.6/</span><br></pre></td></tr></table></figure></p><p>3.使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: cloc [options] &lt;file(s)/dir(s)/git hash(es)&gt; | &lt;set 1&gt; &lt;set 2&gt; | &lt;report files&gt;</span><br></pre></td></tr></table></figure></p><p>进入项目，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc .</span><br></pre></td></tr></table></figure></p><p>稍等片刻，就会有一个输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">JavaScript                       10319         172724         254924         951843</span><br><span class="line">HTML                               679         120179           3665         224595</span><br><span class="line">JSON                              1714            256              0         182127</span><br><span class="line">Markdown                          1400          63461              2         171768</span><br><span class="line">C++                                 69           3538           3197          20331</span><br><span class="line">Python                              51           4292           7801          19137</span><br><span class="line">C/C++ Header                       117           3628           2033          18942</span><br><span class="line">CSS                                113           2011            823          16594</span><br><span class="line">XML                                 32           4427           1300          11277</span><br><span class="line">Sass                                65            282            414           4255</span><br><span class="line">Stylus                              60            539            593           3215</span><br><span class="line">YAML                               189            324            413           3039</span><br><span class="line">D                                   57              0              0           3003</span><br><span class="line">EJS                                113             43              8           2160</span><br><span class="line">reStructuredText                    18            681             51           2122</span><br><span class="line">Bourne Shell                        20            394            398           1875</span><br><span class="line">SVG                                  5              0              1           1646</span><br><span class="line">LESS                                13             26             33           1343</span><br><span class="line">make                                42            378            245           1310</span><br><span class="line">TypeScript                          17            276            584           1161</span><br><span class="line">Perl                                 1             87            170            582</span><br><span class="line">DTD                                  1            179            177            514</span><br><span class="line">m4                                   2             40              2            266</span><br><span class="line">Lisp                                 3             42             38            264</span><br><span class="line">Bourne Again Shell                   8             43             24            161</span><br><span class="line">C                                    4             40             37            149</span><br><span class="line">Ruby                                 6             24              5            140</span><br><span class="line">JSON5                                2              0              0            123</span><br><span class="line">CoffeeScript                         3             18             28             99</span><br><span class="line">Handlebars                           4             18              0             96</span><br><span class="line">Smarty                               6             17             30             91</span><br><span class="line">Windows Resource File                1              1              1             33</span><br><span class="line">DOS Batch                            5              2              0             16</span><br><span class="line">IDL                                  1              1              0             11</span><br><span class="line">zsh                                  1              4             13              7</span><br><span class="line">-----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>4.更多的使用命令，可以查看帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc --help</span><br></pre></td></tr></table></figure></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>上文介绍了三种 <code>Git</code> 代码统计方式：</p><p>1.通过 <code>Git log</code> 统计，稍微会麻烦一些，需要有一些 <code>awk</code> 知识的储备；<br>2.使用插件 <code>git_stats</code> 来生成可视化报告，对用户友好。美中不足就是会在当前项目增加很多 <code>html</code> 统计可视化文件；<br>3.命令行工具 <code>cloc</code>，简单易用，无侵入，使用门槛低；</p><div class="alert success"><p>综上所述，我们可以按照自己的使用场景来灵活的选用不同方式。</p></div><h4 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h4><ul><li><a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a></li><li><a href="https://www.zhihu.com/question/22004842/answer/177254508" target="_blank" rel="noopener">有哪些比较好用的代码量统计工具？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="git" scheme="http://jartto.wang/tags/git/"/>
    
      <category term="stats" scheme="http://jartto.wang/tags/stats/"/>
    
      <category term="git_stats" scheme="http://jartto.wang/tags/git-stats/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 之跨域通讯（postMessage）</title>
    <link href="http://jartto.wang/2019/06/11/post-message/"/>
    <id>http://jartto.wang/2019/06/11/post-message/</id>
    <published>2019-06-11T08:31:21.000Z</published>
    <updated>2019-07-09T08:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况下，我们受到浏览器的安全策略限制。如何能规避此限制，并且能安全的使用跨域通讯，这就不得不介绍一下 postMessage 了。<br><a id="more"></a></p><h4 id="一、关于-postMessage"><a href="#一、关于-postMessage" class="headerlink" title="一、关于 postMessage"></a>一、关于 postMessage</h4><div class="alert success"><p>window.postMessage() 方法可以安全地实现跨源通信。</p></div><p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 <code>https</code>），端口号（<code>443</code> 为 <code>https</code> 的默认值），以及主机 (两个页面的模数 <code>Document.domain</code> 设置为相同的值) 时，这两个脚本才能相互通信。</p><p><code>window.postMessage()</code> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p><h4 id="二、理解过程"><a href="#二、理解过程" class="headerlink" title="二、理解过程"></a>二、理解过程</h4><p><code>window.postMessage()</code> 方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个  <code>MessageEvent</code> 消息。 该 <code>MessageEvent</code> 消息有四个属性： </p><p>1.<code>message</code> 属性表示该 <code>message</code> 的类型；<br>2.<code>data</code> 属性为 <code>window.postMessage</code> 的第一个参数；<br>3.<code>origin</code> 属性表示调用 <code>window.postMessage()</code> 方法时调用页面的当前状态；<br>4.<code>source</code> 属性记录调用 <code>window.postMessage()</code> 方法的窗口信息。</p><p>关于更多细节，我们可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener"> MDN 文档</a>，这里就不赘述了。</p><h4 id="三、兼容性"><a href="#三、兼容性" class="headerlink" title="三、兼容性"></a>三、兼容性</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/postmsg/use.png" alt="caniuse"></p><p>通过上面的图片，我们可以看出来，几乎所有的浏览器都支持了 <code>postMessage</code>，所以放心大胆的去使用吧。</p><h4 id="四、用法简介"><a href="#四、用法简介" class="headerlink" title="四、用法简介"></a>四、用法简介</h4><p>基本用例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure></p><p>1.<code>otherWindow</code><br>其他窗口的一个引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性、执行 <code>window.open</code> 返回的窗口对象、或者是命名过或数值索引的 <code>window.frames</code>。</p><p>2.<code>message</code><br>将要发送到其他 <code>window</code> 的数据。它将会被结构化克隆算法序列化。</p><div class="alert info"><p>这意味着我们可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</p></div><p>3.<code>targetOrigin</code><br>通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 「*」（表示无限制）或者一个 <code>URI</code>。</p><p>在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 <code>targetOrigin</code> 提供的值，那么消息就不会被发送；</p><p>只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口。</p><p>我们举个例子，当用 <code>postMessage</code> 传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的 <code>origin</code> 属性完全一致，来防止密码被恶意的第三方截获。</p><p>如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的 <code>targetOrigin</code>，而不是 <code>*</code>。</p><div class="alert danger"><p>需要注意：不提供确切的目标将导致数据泄露到恶意站点。</p></div><p>4.<code>transfer</code><br>是一串和 <code>message</code> 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p><h4 id="五、事件监听"><a href="#五、事件监听" class="headerlink" title="五、事件监听"></a>五、事件监听</h4><p>我们来看下面这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// For Chrome, the origin property is in the event.originalEvent</span></span><br><span class="line">  <span class="comment">// object. </span></span><br><span class="line">  <span class="comment">// 这里不准确，chrome没有这个属性</span></span><br><span class="line">  <span class="comment">// var origin = event.origin || event.originalEvent.origin; </span></span><br><span class="line">  <span class="keyword">var</span> origin = event.origin</span><br><span class="line">  <span class="keyword">if</span> (origin !== <span class="string">"http://jartto.wang:8080"</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.<code>data</code><br>从其他 <code>window</code> 中传递过来的对象。</p><p>2.<code>origin</code><br>调用 <code>postMessage</code>  时消息发送方窗口的 <code>origin</code> . 这个字符串由 协议、<code>://</code>、域名、<code>: 端口号</code> 拼接而成。</p><p>例如 <code>https://jartto.wang (隐含端口 443)</code>、<code>http://jartto.net(隐含端口 80)</code>、<code>http://jartto.com:8080</code>。请注意，这个 <code>origin</code> 不能保证是该窗口的当前或未来 <code>origin</code> ，因为<code>postMessage</code> 被调用后可能被导航到不同的位置。</p><p>3.<code>source</code><br>对发送消息的窗口对象的引用， 我们可以使用此来在具有不同 <code>origin</code> 的两个窗口之间建立双向通信。</p><h4 id="六、简单应用"><a href="#六、简单应用" class="headerlink" title="六、简单应用"></a>六、简单应用</h4><p>1.监听 <code>message</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get it !!!'</span>,event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.发送数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(&#123;</span><br><span class="line">    name: <span class="string">'Jartto'</span>,</span><br><span class="line">    say: <span class="string">'hello~'</span>,</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多情况下，我们受到浏览器的安全策略限制。如何能规避此限制，并且能安全的使用跨域通讯，这就不得不介绍一下 postMessage 了。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="HTML5" scheme="http://jartto.wang/tags/HTML5/"/>
    
      <category term="postMessage" scheme="http://jartto.wang/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>进阶 PM2</title>
    <link href="http://jartto.wang/2019/05/24/pm2-cluster/"/>
    <id>http://jartto.wang/2019/05/24/pm2-cluster/</id>
    <published>2019-05-24T11:55:22.000Z</published>
    <updated>2019-07-09T03:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>PM2 大大简化了 Node 任务操作，除了简单的应用外，我们还可以做一些有趣的事情。本节我们来探讨一下 PM2 的平滑启动以及数据监控。<br><a id="more"></a><br>如果你还不了解 <code>PM2</code>，可以先看看<a href="http://jartto.wang/2016/06/27/first-experience-of-pm2/">PM2 初体验</a>，或者查看<a href="https://www.jianshu.com/p/f640450bd120" target="_blank" rel="noopener">PM2 用法简介</a>。</p><h4 id="一、PM2-两种启动方式"><a href="#一、PM2-两种启动方式" class="headerlink" title="一、PM2 两种启动方式"></a>一、<code>PM2</code> 两种启动方式</h4><p>1.<code>cluster_mode</code>：用 <code>cluster</code> 来做负载均衡，我们不需要做任何代码的改动。<br>2.<code>fork_mode</code>：用 <code>fork</code> 模式启动（默认），这可以允许我们通过改变 <code>exec_interpreter</code> 参数，启动 <code>php</code> 或者 <code>python</code> 服务。      </p><div class="alert success"><p>Node.js 给我们提供了 cluster 模块，它可以生成多个工作线程来共享同一个 TCP 连接。</p></div><h4 id="二、实时扩展集群"><a href="#二、实时扩展集群" class="headerlink" title="二、实时扩展集群"></a>二、实时扩展集群</h4><p>任何时候，如果我们需要增加工作线程的数量，可以通过 <code>pm2 scale &lt;app name&gt; &lt;n&gt;</code> 来对集群进行扩展。参数 <code>&lt;n&gt;</code> 指定工作线程的数量，被用来增加或减少集群数。</p><div class="alert info"><p>补充：可以通过 pm2 scale app +3 的方式来指定要增加多少工作线程。</p></div><p><code>PM2</code> 的 <code>reload &lt;app name&gt;</code> 功能将依次重启所有的工作线程。每一个线程会等待在新的线程创建之后才会被终止掉，因此，当你在产品环境部署新的代码时，<code>Server</code> 会不间断地一直保持运行。</p><h4 id="三、平滑重启"><a href="#三、平滑重启" class="headerlink" title="三、平滑重启"></a>三、平滑重启</h4><p>1.fork 模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"apps"</span> : [&#123;</span><br><span class="line">     <span class="string">"name"</span>         : <span class="string">"pc"</span>,</span><br><span class="line">     <span class="string">"script"</span>       : <span class="string">"jartto-server.js"</span>,</span><br><span class="line">     <span class="string">"kill_timeout"</span> : <span class="number">3000</span>,</span><br><span class="line">     <span class="string">"instances"</span>: <span class="number">2</span>,</span><br><span class="line">     <span class="string">"log_date_format"</span>: <span class="string">"YY-MM-DD HH:mm:ss Z"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> httpServer = server.listen(port, error =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">       <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">   process.send(<span class="string">'ready'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(<span class="string">'SIGINT'</span>, () =&gt; &#123;</span><br><span class="line">   httpServer.close(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">       process.exit(error ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.<code>cluster</code><br>在集群模式下，有一个默认系统可在应用程序接受连接时将每个集群设置为就绪。还有一个超时，默认为 <code>3000</code> 毫秒，我们可以使用 <code>ecosystem</code> 文件中的 <code>listen_timeout</code> 属性进行设置。</p><p>生成 <code>ecosystem.config.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 ecosystem</span><br></pre></td></tr></table></figure></p><p>输出日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[PM2] Spawning PM2 daemon with pm2_home=/Users/jartto/.pm2</span><br><span class="line">[PM2] PM2 Successfully daemonized</span><br><span class="line">File /Users/jartto/Documents/project/ecosystem.config.js generated</span><br></pre></td></tr></table></figure></p><p>简单示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;&#125;, &#123;&#125;], <span class="comment">// 存放每一个进程的配置信息</span></span><br><span class="line">  deploy: &#123;&#125; <span class="comment">// 包含部署配置的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，就可以通过 <code>startOrRestart</code> 来启动了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "cross-env PATH_TYPE=test pm2 startOrRestart ecosystem.config.js --only jartto-test --env test",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 <code>apps</code> 和 <code>deploy</code> 下面我们来细致聊一聊。</p><h4 id="四、apps-部分"><a href="#四、apps-部分" class="headerlink" title="四、apps 部分"></a>四、<code>apps</code> 部分</h4><p>上面 <code>ecosystem.config.js</code> 会生成一个简单的模版，为了更好的掌握，我们来看看更全的一些配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    apps : [&#123;</span><br><span class="line">        name: <span class="string">'Jartto-test'</span>, <span class="comment">// 进程名称</span></span><br><span class="line">        script: <span class="string">'./node_modules/nuxt-start/bin/nuxt-start.js'</span>, <span class="comment">// 启动脚本地址</span></span><br><span class="line">        args: <span class="string">'-p 8888 -H 0.0.0.0'</span>, <span class="comment">// 启动的配置</span></span><br><span class="line">        cwd: </span><br><span class="line">        instances: <span class="number">4</span>,</span><br><span class="line">        autorestart: <span class="literal">true</span>,</span><br><span class="line">        watch: <span class="literal">false</span>,</span><br><span class="line">        max_restarts: <span class="number">5</span>,</span><br><span class="line">        max_memory_restart: <span class="string">'1G'</span>,</span><br><span class="line">        env: &#123;</span><br><span class="line">            NODE_ENV: <span class="string">'development'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        env_production: &#123;</span><br><span class="line">            NODE_ENV: <span class="string">'production'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    deploy : &#123;</span><br><span class="line">        production : &#123;</span><br><span class="line">            user : <span class="string">'node'</span>,</span><br><span class="line">            host : <span class="string">'212.83.163.1'</span>,</span><br><span class="line">            ref : <span class="string">'origin/master'</span>,</span><br><span class="line">            repo : <span class="string">'git@github.com:repo.git'</span>,</span><br><span class="line">            path : <span class="string">'/var/www/production'</span>,</span><br><span class="line">            post-deploy : <span class="string">'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参数意义：</p><ul><li>apps：json 结构，apps 是一个数组，每一个数组成员就是对应一个pm2中运行的应用</li><li>name：应用程序的名称</li><li>cwd：应用程序所在的目录</li><li>script：应用程序的脚本路径</li><li>exec_interpreter：应用程序的脚本类型，这里使用的 shell，默认是 nodejs</li><li>min_uptime：最小运行时间，这里设置的是 60s 即如果应用程序在 60s 内退出，pm2 会认为程序异常退出，此时触发重启 max_restarts 设置数量</li><li>max_restarts：设置应用程序异常退出重启的次数，默认 15 次（从0开始计数）</li><li>exec_mode：应用程序启动模式，这里设置的是 cluster_mode（集群），默认是 fork</li><li>error_file：自定义应用程序的错误日志文件</li><li>out_file：自定义应用程序日志文件</li><li>pid_file：自定义应用程序的 pid 文件</li><li>watch：是否启用监控模式，默认是 false。如果设置成 true，当应用程序变动时，pm2 会自动重载。这里也可以设置你要监控的文件。</li></ul><h4 id="五、deploy-部分"><a href="#五、deploy-部分" class="headerlink" title="五、deploy 部分"></a>五、<code>deploy</code> 部分</h4><p>1.生成公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id jartto@server.com</span><br></pre></td></tr></table></figure></p><p>补充说明一下：<br><code>ssh-copy-id</code> 命令可以把本地主机的公钥复制到远程主机的 <code>authorized_keys</code> 文件上，实现免密码登陆。</p><p>2.配置 <code>ecosystem</code> 文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">    name: <span class="string">"app"</span>,</span><br><span class="line">    script: <span class="string">"app.js"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  deploy: &#123;</span><br><span class="line">    <span class="comment">// "production" is the environment name</span></span><br><span class="line">    production: &#123;</span><br><span class="line">      <span class="comment">// SSH key path, default to $HOME/.ssh</span></span><br><span class="line">      key: <span class="string">"/path/to/some.pem"</span>,</span><br><span class="line">      <span class="comment">// SSH user</span></span><br><span class="line">      user: <span class="string">"Jartto"</span>,</span><br><span class="line">      <span class="comment">// SSH host</span></span><br><span class="line">      host: [<span class="string">"192.168.0.13"</span>],</span><br><span class="line">      <span class="comment">// SSH options with no command-line flag, see 'man ssh'</span></span><br><span class="line">      <span class="comment">// can be either a single string or an array of strings</span></span><br><span class="line">      ssh_options: <span class="string">"StrictHostKeyChecking=no"</span>,</span><br><span class="line">      <span class="comment">// GIT remote/branch</span></span><br><span class="line">      ref: <span class="string">"origin/master"</span>,</span><br><span class="line">      <span class="comment">// GIT remote</span></span><br><span class="line">      repo: <span class="string">"git@github.com:jartto/repository.git"</span>,</span><br><span class="line">      <span class="comment">// path in the server</span></span><br><span class="line">      path: <span class="string">"/var/www/jartto-repository"</span>,</span><br><span class="line">      <span class="comment">// Pre-setup command or path to a script on your local machine</span></span><br><span class="line">      <span class="string">'pre-setup'</span>: <span class="string">"apt-get install git ; ls -la"</span>,</span><br><span class="line">      <span class="comment">// Post-setup commands or path to a script on the host machine</span></span><br><span class="line">      <span class="comment">// eg: placing configurations in the shared dir etc</span></span><br><span class="line">      <span class="string">'post-setup'</span>: <span class="string">"ls -la"</span>,</span><br><span class="line">      <span class="comment">// pre-deploy action</span></span><br><span class="line">      <span class="string">'pre-deploy-local'</span>: <span class="string">"echo 'This is a local executed command'"</span>,</span><br><span class="line">      <span class="comment">// post-deploy action</span></span><br><span class="line">      <span class="string">'post-deploy'</span>: <span class="string">"npm install"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令很简单，都有注释，这里就不赘述了。</p><p>3.是时候启动了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup deployment at remote location</span></span><br><span class="line">pm2 deploy production setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update remote version</span></span><br><span class="line">pm2 deploy production update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Revert to -1 deployment</span></span><br><span class="line">pm2 deploy production revert 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute a command on remote servers</span></span><br><span class="line">pm2 deploy production <span class="built_in">exec</span> <span class="string">"pm2 reload all"</span></span><br></pre></td></tr></table></figure></p><p>更多配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; &lt;command&gt;</span><br><span class="line">  Commands:</span><br><span class="line">    setup                run remote setup commands</span><br><span class="line">    update               update deploy to the latest release</span><br><span class="line">    revert [n]           revert to [n]th last deployment or 1</span><br><span class="line">    curr[ent]            output current release commit</span><br><span class="line">    prev[ious]           output previous release commit</span><br><span class="line">    exec|run &lt;cmd&gt;       execute the given &lt;cmd&gt;</span><br><span class="line">    list                 list previous deploy commits</span><br><span class="line">    [ref]                deploy to [ref], the &quot;ref&quot; setting, or latest tag</span><br></pre></td></tr></table></figure></p><p>了解更多，请参考<a href="https://pm2.io/doc/en/runtime/guide/easy-deploy-with-ssh/#force-deployment" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="六、环境变量"><a href="#六、环境变量" class="headerlink" title="六、环境变量"></a>六、环境变量</h4><p><code>pm2</code> 通过在配置文件中通过 <code>env_xx</code> 来声明不同环境的配置，然后在启动应用时，通过 <code>--env</code> 参数指定运行的环境。一个简单的示例可能如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://www.jartto.wang/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;env_dev&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://dev.jartto.wang/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;env_test&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://test.jartto.wang/&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="七、负载均衡"><a href="#七、负载均衡" class="headerlink" title="七、负载均衡"></a>七、负载均衡</h4><p><code>PM2</code> 提供了强大的负载能力，我们可以通过如下命令来开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js -i 3 # 开启三个进程</span><br><span class="line">pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程</span><br></pre></td></tr></table></figure></p><h4 id="八、数据监控"><a href="#八、数据监控" class="headerlink" title="八、数据监控"></a>八、数据监控</h4><p><code>PM2</code> 提供了一个数据监控命令：<code>pm2 monit</code>，执行命令后，大概界面如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/monit.png" alt="monit"></p><p>看起来不错，可惜并不实用。大家可能发现了，在实际场景下，我们线上环境会有 <code>N</code> 台服务器，你会一台台上去看监控数据吗？</p><div class="alert info"><p>显然，我们碰到了另一种场景，那么如何才能统一监控呢？</p></div><p>不要着急，<code>PM2</code> 为我们提供了另外一种方式，通过在 <code>Server</code> 端运行命令：<code>pm2 web</code>，我们可以在该机器启动一个监听服务：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/pm2web.png" alt="web"></p><p>之后，你可以通过 <code>主机 IP:9615</code> 来获取数据，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/api.png" alt="api"></p><div class="alert info"><p>获取数据可以通过客户端轮询，或者是服务端 Socket 推送，It’s up to you!</p></div><p>最后，我们来看看数据格式：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/data.png" alt="data"></p><p>有了数据，那么可视化岂不是小菜一碟，我们就可以在本地实时监控如下数据：<br>1.服务器内存情况；<br>2.<code>CPU</code> 使用情况；<br>3.各个站点服务情况，是否正常运转，是否报错，是否频繁重启等；<br>4.服务器平均负载；<br>…</p><h4 id="九、重置状态"><a href="#九、重置状态" class="headerlink" title="九、重置状态"></a>九、重置状态</h4><p>既然通过 <code>PM2</code> 来监控数据了，那么我们肯定希望每次的数据是准确的，所以这时候就可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 reset jartto-test</span><br></pre></td></tr></table></figure></p><p>来重置服务状态。</p><h4 id="十、最终效果"><a href="#十、最终效果" class="headerlink" title="十、最终效果"></a>十、最终效果</h4><p>有了数据，可视化就非常容易了，我们来看一个简单的示例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/show.png" alt="show"></p><p>当然，你可以做的更好，快发挥你创造性，做一些有趣的事情吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PM2 大大简化了 Node 任务操作，除了简单的应用外，我们还可以做一些有趣的事情。本节我们来探讨一下 PM2 的平滑启动以及数据监控。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="pm2" scheme="http://jartto.wang/tags/pm2/"/>
    
      <category term="cluster" scheme="http://jartto.wang/tags/cluster/"/>
    
      <category term="fork" scheme="http://jartto.wang/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>Nuxtjs 2.0 升级爬坑</title>
    <link href="http://jartto.wang/2019/04/23/update-nuxt2-0/"/>
    <id>http://jartto.wang/2019/04/23/update-nuxt2-0/</id>
    <published>2019-04-23T11:58:32.000Z</published>
    <updated>2019-04-23T13:18:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我在升级 Nuxt2.0 的过程，遇到了很多问题，逐一查找解决，废了不少时间。回头想想，真希望在升级的时候看到这样一篇文章，让我少走一些弯路。<br><a id="more"></a><br><div class="alert success"><p>这篇文章的意义也在于此，希望对大家能有所帮助。</p></div></p><h4 id="一、为什么要从-Nuxt1-0-升级到-Nuxt2-0？"><a href="#一、为什么要从-Nuxt1-0-升级到-Nuxt2-0？" class="headerlink" title="一、为什么要从 Nuxt1.0 升级到 Nuxt2.0？"></a>一、为什么要从 <code>Nuxt1.0</code> 升级到 <code>Nuxt2.0</code>？</h4><p>我们来看看 <code>Nuxt2.0</code> 有哪些<a href="https://www.cnblogs.com/zhuanzhuanfe/p/9101932.html" target="_blank" rel="noopener">更新</a>：</p><p>1.支持 <code>webpack4</code><br><code>webpack4</code> 有很多优化的提升，升级后就可以嗨皮的使用了。</p><p>2.弃掉了 <code>venders</code><br>我们以前一直使用 <code>vendors chunk</code>，这次发布后，我们不再使用 <code>CommonsChunkPlugin</code>，所以不必明确指定 <code>vendors</code>。</p><p><code>Nuxt</code> 自动添加了核心的 <code>packages</code> (包括 <code>vue</code>, <code>vue-router</code>, <code>babel-runtime</code>…)到 <code>Cache Group</code>中。</p><div class="alert info"><p>这使得 <code>webpack</code> 可以用最合理的方式拆分你的代码。</p></div><p>3.<code>chunk splitting</code> 的完全控制<br>尽管 <code>nuxt</code> 试图提供最有效的分割，但现在可以使用 <code>build.splitChunks</code> 选项完全控制它，并且可以选择禁用每个路由的异步块。</p><p>4.<code>Vue Loader 15 and mini-css-extract-plugin</code><br><code>Vue-Loader 15</code> 进行了完全的重写，它使用了一种完全不同的新架构，能够将 <code>webpack</code> 配置中定义的任何规则应用于 <code>*.vue</code> 文件内。</p><p>对于 <code>CSS</code> 抽取，使用一个新的插件 <code>mini-css-extract-plugin</code>，它支持 <code>CSS</code> 和 <code>SourceMaps</code>（<code>CSS splitting</code>）的按需加载，并构建在新的 <code>webpack v4</code> 特性（<code>module types</code>）上。</p><p>5.<code>nuxt es modules</code><br>我们可以在 <code>nuxt.config.js</code> 中使用 <code>import</code>, <code>export</code>, 服务器 <code>middleware</code>, <code>modules</code> 。</p><p>6.<code>CLI</code> 改善<br><code>nuxt2.0</code> 自动检测配置项和测试环境，并将切换到一个称为 <code>minimalCLI</code> 的特殊模式，其中包含更少的详细消息。</p><h4 id="二、升级-2-0"><a href="#二、升级-2-0" class="headerlink" title="二、升级 2.0"></a>二、升级 2.0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nuxt@latest</span><br></pre></td></tr></table></figure><h4 id="三、记得重新安装一下依赖"><a href="#三、记得重新安装一下依赖" class="headerlink" title="三、记得重新安装一下依赖"></a>三、记得重新安装一下依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><h4 id="四、升级问题"><a href="#四、升级问题" class="headerlink" title="四、升级问题"></a>四、升级问题</h4><p>问题一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module build failed: TypeError: Cannot read property &apos;eslint&apos; of undefined</span><br></pre></td></tr></table></figure></p><p>碰到这个问题，是因为 <code>isClient</code> 新版本已经移除了，我们试着<a href="https://github.com/nuxt/nuxt.js/issues/3216" target="_blank" rel="noopener">理解一下</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isClient was removed in nuxt-edge, it should be replaced by process.client in your nuxt.config.js as below.</span><br></pre></td></tr></table></figure></p><p><code>Nuxtjs1.0</code> 我们是这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extend(config, &#123; isDev, isClient &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDev &amp;&amp; isClient) &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">        enforce: <span class="string">"pre"</span>,</span><br><span class="line">        test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">        loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以应该修改成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extend (config, &#123; isDev &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDev &amp;&amp; process.client) &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">          enforce: <span class="string">'pre'</span>,</span><br><span class="line">          test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">          loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">          exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>注意 isClient 和 process.client！</p></div><p>问题二：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ERROR  Failed to compile with 1 errors</span><br><span class="line">error  <span class="keyword">in</span> ./.nuxt/router.js</span><br><span class="line"></span><br><span class="line">Module parse failed: Unexpected token (24:8)</span><br><span class="line">You may need an appropriate loader to handle this file <span class="built_in">type</span>.</span><br><span class="line">|</span><br><span class="line">| var _5f05608f = <span class="keyword">function</span> <span class="function"><span class="title">_5f05608f</span></span>() &#123;</span><br><span class="line">&gt;     <span class="built_in">return</span> import(<span class="string">'../pages/account/index.vue'</span> /* webpackChunkName: <span class="string">"pages/account/index"</span> */).<span class="keyword">then</span>(<span class="keyword">function</span> (m) &#123;</span><br><span class="line">|         <span class="built_in">return</span> m.default || m;</span><br><span class="line">|     &#125;);</span><br><span class="line"></span><br><span class="line">@ ./.nuxt/index.js 334:14-36</span><br><span class="line">@ ./.nuxt/client.js</span><br><span class="line">@ multi webpack-hot-middleware/client?name=client&amp;reload=<span class="literal">true</span>&amp;timeout=30000&amp;path=/__webpack_hmr ./.nuxt/client.js</span><br></pre></td></tr></table></figure></p><p>碰到这个问题，应该是某些包不兼容，所以可以先清除 <code>node_modules</code>，重新安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules/</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><p>问题三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Plugin/Preset files are not allowed to export objects, only functions</span><br></pre></td></tr></table></figure></p><p>这个问题是因为 <code>Babel7</code> 的更新，所以我们需要<a href="https://stackoverflow.com/questions/47830273/babel-plugin-preset-files-are-not-allowed-to-export-objects-only-functions" target="_blank" rel="noopener">更新配置文件</a>：</p><p>首先修改 <code>package.json</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "@babel/core": "^7.1.6",</span><br><span class="line">    "@babel/preset-env": "^7.1.6",</span><br><span class="line">    "@babel/preset-react": "^7.0.0",</span><br><span class="line">    "babel-loader": "^8.0.4",</span><br><span class="line">    "webpack": "^4.25.1",</span><br><span class="line">    "webpack-cli": "^3.1.2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着更改 <code>nuxt.config.js</code>，如果使用了动态导入，需要注意<a href="https://github.com/styleguidist/react-styleguidist/issues/987" target="_blank" rel="noopener">如下配置</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">presets: [<span class="string">'@babel/env'</span>, <span class="string">'@babel/react'</span>],</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="string">'@babel/plugin-syntax-dynamic-import'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>问题四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This dependency was not found: vant/lib/vant-css/index.css in ./plugins/vant.js</span><br><span class="line">import &apos;vant/lib/vant-css/index.css&apos;;</span><br></pre></td></tr></table></figure></p><p>我们发现升级后，第三方 <code>UI</code> 库的样式找不到了，通过查找，发现是文件<a href="https://youzan.github.io/vant/#/zh-CN/quickstart" target="_blank" rel="noopener">引用路径</a>发生了变化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue’;</span></span><br><span class="line"><span class="string">import Vant from '</span>vant’;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.css’;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Vue.use(Vant);</span></span><br></pre></td></tr></table></figure></p><p>问题五：静态资源加载异常<br><div class="alert warning"><p>这个异常很明显，图片全部访问不了了，所以一定要注意看看 <code>Nuxt2.0</code> 做了<a href="https://zh.nuxtjs.org/guide/assets/" target="_blank" rel="noopener">哪些更改</a>。</p></div></p><p>请注意: 从 <code>Nuxt2.0</code> 开始，<code>~/alias</code> 将无法在 <code>CSS</code> 文件中正确解析。你必须在 <code>url CSS</code> 引用中使用 <code>~assets</code>（没有斜杠）或 <code>@</code> 别名，即 <code>background:url(&quot;~assets/banner.svg&quot;)</code></p><p>问题六：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN  Using an Array as build.postcss will be deprecated in Nuxt 3. Please switch to the object declaration</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>意思很明了，postcss 以后需要用<a href="https://zh.nuxtjs.org/faq/postcss-plugins/" target="_blank" rel="noopener">对象声明</a>，不再支持数组方式。</p></div><p>我们将：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postcss: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"postcss-px2rem-exclude"</span>)(&#123;</span><br><span class="line">        remUnit: <span class="number">75</span>,</span><br><span class="line"></span><br><span class="line">        exclude: <span class="regexp">/node_modules|vant/</span></span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">        browsers: [<span class="string">'Android &gt;= 4.0'</span>, <span class="string">'iOS &gt;= 7'</span>]</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>替换成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postcss: &#123;</span><br><span class="line">    <span class="string">'postcss-px2rem-exclude'</span>: &#123;</span><br><span class="line">        emUnit: <span class="number">75</span>,</span><br><span class="line">        exclude: <span class="string">'/node_modules|vant/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'autoprefixer'</span>: &#123;</span><br><span class="line">        browsers: [<span class="string">'Android &gt;= 4.0'</span>, <span class="string">'iOS &gt;= 7’]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure></p><p>问题七：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError：regeneratorRuntime is not defined</span><br></pre></td></tr></table></figure></p><p>需要增加 babel <a href="https://github.com/nuxt/nuxt.js/issues/934" target="_blank" rel="noopener">运行时编译</a>，配置 <code>package.json</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"babel-plugin-transform-runtime": "^6.23.0",</span><br></pre></td></tr></table></figure></p><p>修改 <code>nuxt.config.js</code> 中的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="string">'@babel/plugin-syntax-dynamic-import'</span>,</span><br><span class="line">  <span class="string">'@babel/transform-runtime'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>问题八：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EACCES: permission denied, mkdir &apos;/Users/jartto/Documents/project/primary-station/node_modules/.cache’</span><br></pre></td></tr></table></figure></p><p>使用 <code>sudo</code> 启动，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm run start</span><br></pre></td></tr></table></figure></p><p>问题九：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR in Sentry CLI Plugin: Command failed: /apps/srv/instance/test-touch.gaotu100.com/node_modules/@sentry/cli/sentry-cli releases new 2.4.0</span><br><span class="line">error: An organization slug is required (provide with --org)</span><br><span class="line"></span><br><span class="line">Add --log-level=[info|debug] or export SENTRY_LOG_LEVEL=[info|debug] to see more output.</span><br><span class="line">Please attach the full debug log to all bug reports.</span><br></pre></td></tr></table></figure></p><p>这个问题类似和问题一一样，注意替换 <code>isClient</code>。</p><h4 id="五、升级前后对比"><a href="#五、升级前后对比" class="headerlink" title="五、升级前后对比"></a>五、升级前后对比</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/nuxt/diff.png" alt="diff"></p><p><a href="http://jartto.wang/2019/04/23/update-nuxt2-0/">如上</a>截图，我们只取了一部分，但是可以看到，文件被更细粒度的进行了拆分。这完全要归功于 <code>splitChunks</code>。当然，更多优化点和细节你可以慢慢来体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我在升级 Nuxt2.0 的过程，遇到了很多问题，逐一查找解决，废了不少时间。回头想想，真希望在升级的时候看到这样一篇文章，让我少走一些弯路。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="impress" scheme="http://jartto.wang/tags/impress/"/>
    
  </entry>
  
  <entry>
    <title>酷炫的 HTML5 网页 PPT</title>
    <link href="http://jartto.wang/2019/04/15/amusing-ppt/"/>
    <id>http://jartto.wang/2019/04/15/amusing-ppt/</id>
    <published>2019-04-15T12:07:39.000Z</published>
    <updated>2019-06-06T07:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般演讲、培训等场合，我们都离不开 PPT，那么如何做出一款与众不同而有充满科技感的 PPT 呢？这时候，我们可以尝试一下在线 PPT。<br><a id="more"></a></p><h4 id="一、选择在线-PPT-的几大原因"><a href="#一、选择在线-PPT-的几大原因" class="headerlink" title="一、选择在线 PPT 的几大原因"></a>一、选择在线 PPT 的几大原因</h4><p>1.省去了上传下载的麻烦；<br>2.降低了客户端对 PPT 软件的依赖；<br>3.随时更新，更灵活；<br>4.同屏播放，全场互动，增加用户体验；<br>…</p><h4 id="二、多种选择"><a href="#二、多种选择" class="headerlink" title="二、多种选择"></a>二、多种选择</h4><p>1.<code>revealjs</code><br>一个可以帮我们轻易使用 <code>HTML</code> 创建漂亮演示文稿的框架。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt1.png" alt="revealjs"></p><p>2.<code>impress</code><br>效果非常酷炫，下文将深入介绍。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt2.png" alt="impress"></p><p>3.<code>fathom.js</code><br>使用 <code>HTML</code>，<code>CSS</code>，<code>JS</code> 来实现滑动页面，体验非常接近 <code>PPT</code>。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt3.png" alt="fathom"></p><p>4.focusky<br>操作界面简洁，易上手。支持 3D 幻灯片演示特效打破常规。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt5.png" alt="focusky"></p><h4 id="三、强力推荐"><a href="#三、强力推荐" class="headerlink" title="三、强力推荐"></a>三、强力推荐</h4><p>上面介绍了很多可用的在线 <code>PPT</code> 类库，在我看来最酷炫的莫过于 <code>impress.js</code>，我们先来看一个演示：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/demo.gif" alt="impress-demo"></p><div class="alert info"><p>注意：在 Impress 中大量使用 3D 动画，可能会使页面变得卡顿。</p></div><h4 id="四、基本使用"><a href="#四、基本使用" class="headerlink" title="四、基本使用"></a>四、基本使用</h4><p>1.定义结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.每页 <code>PPT</code> 使用 <code>step</code> 类来区分<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bored"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"-1000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">q</span>&gt;</span>Aren’t you just <span class="tag">&lt;<span class="name">b</span>&gt;</span>bored<span class="tag">&lt;/<span class="name">b</span>&gt;</span> with all those slides-based presentations?<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>3.使用 <code>data-x</code>，<code>data-y</code> 完成平移操作<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bored"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"-1000"</span> <span class="attr">data-y</span>=<span class="string">"-1500"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">q</span>&gt;</span>Aren’t you just <span class="tag">&lt;<span class="name">b</span>&gt;</span>bored<span class="tag">&lt;/<span class="name">b</span>&gt;</span> with all those slides-based presentations?<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>4.缩放：<code>data-scale</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"0"</span> <span class="attr">data-y</span>=<span class="string">"0"</span> <span class="attr">data-scale</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"try"</span>&gt;</span>then you should try<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>impress.js<span class="tag">&lt;<span class="name">sup</span>&gt;</span>*<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"footnote"</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>*<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> no rhyme intended<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>5.页面旋转：<code>data-rotate</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"its"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"850"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span> <span class="attr">data-rotate</span>=<span class="string">"90"</span> <span class="attr">data-scale</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      It’s a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>presentation tool<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> </span><br><span class="line">      inspired by the idea behind <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://prezi.com"</span>&gt;</span>prezi.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">      and based on the <span class="tag">&lt;<span class="name">strong</span>&gt;</span>power of CSS3 transforms and transitions<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> in modern browsers.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6.调整 <code>z</code> 方向层级 <code>data-z</code>，可以理解为离用户的远近距离<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tiny"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"2825"</span> <span class="attr">data-y</span>=<span class="string">"2325"</span> <span class="attr">data-z</span>=<span class="string">"-3000"</span> <span class="attr">data-rotate</span>=<span class="string">"300"</span> <span class="attr">data-scale</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>and <span class="tag">&lt;<span class="name">b</span>&gt;</span>tiny<span class="tag">&lt;/<span class="name">b</span>&gt;</span> ideas<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>7.使用 <code>data-rotate-x</code>, <code>data-rotate-y</code>, <code>data-rotate-z</code> 实现 <code>3D</code> 旋转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;its-in-3d&quot; class=&quot;step&quot; data-x=&quot;6200&quot; data-y=&quot;4300&quot; data-z=&quot;-100&quot; data-rotate-x=&quot;-40&quot; data-rotate-y=&quot;10&quot; data-scale=&quot;2&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;span class=&quot;have&quot;&gt;have&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;you&quot;&gt;you&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;noticed&quot;&gt;noticed&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;its&quot;&gt;it’s&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;in&quot;&gt;in&lt;/span&gt;</span><br><span class="line">      &lt;b&gt;3D&lt;sup&gt;*&lt;/sup&gt;&lt;/b&gt;?</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;span class=&quot;footnote&quot;&gt;* beat that, prezi ;)&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>此外，还有一些可用的 <code>css</code> 类，<code>js</code> 初始化方法，以及 <code>stepenter</code> 事件等，具体可以参考<a href="https://github.com/impress/impress.js/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="五、投屏互动"><a href="#五、投屏互动" class="headerlink" title="五、投屏互动"></a>五、投屏互动</h4><p>演讲者端，监听 <code>impress:stepgoto</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> impressiv = <span class="function"><span class="keyword">function</span>(<span class="params">presi,session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> socket = io.connect(<span class="string">'http://jartto.wang'</span>);</span><br><span class="line">        socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">presi</span>: presi, <span class="attr">session</span>:session&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'演示结束，欢迎观看！'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'impress:stepgoto'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'slide'</span>, &#123;<span class="attr">slide</span>:event.target.id&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观众端，接收 <code>slide</code> 消息，然后自动翻页：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> impressiv = <span class="function"><span class="keyword">function</span>(<span class="params">presi</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> socket = io.connect(<span class="string">'http://jartto.wang'</span>);</span><br><span class="line">  socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">presi</span>: presi&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">'slide'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 控制用户端翻页</span></span><br><span class="line">    impress().goto(data.slide);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'演示结束，欢迎观看！'</span>);</span><br><span class="line">    <span class="comment">// io.disconnect();</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要特别注意，我们要禁止掉观众端的操作事件，否则你演讲过程就会被别人牵着鼻子走了🙈～<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'touchstart'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'click'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'keydown'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'keyup'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="六、可视化编辑"><a href="#六、可视化编辑" class="headerlink" title="六、可视化编辑"></a>六、可视化编辑</h4><p>如果你不喜欢写代码，我们可以选择<a href="http://qti3e.github.io/Imprezi/#/step-2" target="_blank" rel="noopener">可视化编辑器</a>。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt4.png" alt="visi"></p><h4 id="七、更多资源"><a href="#七、更多资源" class="headerlink" title="七、更多资源"></a>七、更多资源</h4><ul><li><a href="https://devzum.com/2014/11/10-best-javascript-and-html5-presentation-frameworks/" target="_blank" rel="noopener">10 Best JavaScript And HTML5 Presentation Frameworks</a></li><li><a href="https://github.com/impress/impress.js/wiki/Examples-and-demos" target="_blank" rel="noopener">impress examples-and-demos</a></li><li><a href="http://qti3e.github.io/Imprezi/#/step-2" target="_blank" rel="noopener">可视化编辑器</a></li><li><a href="https://github.com/melix/deck2pdf" target="_blank" rel="noopener">impress 导出 pdf</a></li><li><a href="https://github.com/impress/impress.js/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">impress api 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般演讲、培训等场合，我们都离不开 PPT，那么如何做出一款与众不同而有充满科技感的 PPT 呢？这时候，我们可以尝试一下在线 PPT。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="impress" scheme="http://jartto.wang/tags/impress/"/>
    
      <category term="html5" scheme="http://jartto.wang/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>如何成为合格的技术面试官？</title>
    <link href="http://jartto.wang/2019/04/07/learn-interview/"/>
    <id>http://jartto.wang/2019/04/07/learn-interview/</id>
    <published>2019-04-07T13:12:42.000Z</published>
    <updated>2019-04-15T12:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为技术面试官，<a href="http://jartto.wang/2019/01/06/f2e-interview/">面试过程</a>很少考虑候选人的感受。上来就是问，不合适就送走。虽然技术环节我很专业，但是其他细节我却知之甚少。<br><a id="more"></a><br>从来没觉得这样会有什么问题，直到有一天，我参加了一场面试官培训，才意识到自身的不足。</p><h4 id="一、明确面试的目的"><a href="#一、明确面试的目的" class="headerlink" title="一、明确面试的目的"></a>一、明确面试的目的</h4><p>作为公司的面试官，我们不是为了鄙视和炫耀技术，而是评估候选人能否担任工作。这属于团队建设核心工作，也是公司的一次品牌宣传。</p><div class="alert info"><p>你代表的不仅是个人，还有公司的形象，请尊重每一位候选人。</p></div><p>仓央嘉措曾经说过：我以为别人尊重我，是因为我很优秀。慢慢的我明白了，别人尊重我，是因为别人很优秀；优秀的人更懂得尊重别人。对人恭敬其实是在庄严你自己。</p><h4 id="二、开场过程"><a href="#二、开场过程" class="headerlink" title="二、开场过程"></a>二、开场过程</h4><p>为了体现足够的重视和面试的专业性，在开场过程，我们需要注意以下几点：<br>1.为候选人倒杯温水<br>这个我深有体会，有时候在持续多轮面试后，候选人已经嗓子冒烟了。所以，一杯水体现了公司的细节和关怀。</p><p>2.简单的寒暄缓和气氛<br>先简单的问候和寒暄，调整一下面试氛围，让候选人在舒服的气氛中开始。</p><p>3.面试官简单自我介绍<br>面试官应该做一下自我介绍，明确自己角色。阐述面试流程，告知候选人面试过程需要用电脑做记录。</p><p>4.候选人自我介绍<br>完成上面几项后，就可以从候选人自我介绍进入面试主流程了。</p><p>5.Q&amp;A<br>面试最后问问候选人，是否有什么问题想问，或者可以说说自己擅长而又没有被问到的方面。</p><p>6.致谢<br>感谢候选人能够花时间过来面试，表现出足够的重视。</p><p>7.告知等候时间/送候选人出去</p><div class="alert info"><p>让候选人更好的发挥，也为高效的面试做好铺垫。</p></div><h4 id="三、面试问题"><a href="#三、面试问题" class="headerlink" title="三、面试问题"></a>三、面试问题</h4><p>1.根据简历提前准备好，针对不同 <code>level</code> 使用不同题目；<br>2.不使用偏难怪题；<br>3.切合候选人的经验，不要依据自己熟悉的领域提问；<br>4.考察素质能力尽量使用相同的问题，以保证横向比较的公平；<br>5.问题和所面职位具有相关性；</p><h4 id="四、完整的行为示例-STAR"><a href="#四、完整的行为示例-STAR" class="headerlink" title="四、完整的行为示例 - STAR"></a>四、完整的行为示例 - STAR</h4><p>我们先来看看 <code>STAR</code> 解释：<code>Situation</code>, <code>Task</code>, <code>Action</code>, <code>Result</code>。</p><p>示例：<br>举个例子说说你擅长性能优化。</p><p>要点：<br>当时情况怎么样，需要做什么，采取了什么行动，达到了什么效果。</p><p>理念：<br>在收集 <code>STAR</code> 的时候不断提出更加深入的问题来判断其对该带我的认知程度及抗压能力。</p><h4 id="五、面试分工"><a href="#五、面试分工" class="headerlink" title="五、面试分工"></a>五、面试分工</h4><p>面试一般会分几轮，所以不同的面试官面试的重点也应该有所区别。<br>一面：基本技能（知识，专业技能）<br>二面：逻辑分析（专业技能，能力）<br>三面：综合素质（个性特征、动机、价值观）</p><p>这样的好处有两个：<br>1.在每一轮全面的面试相关领域；<br>2.避免重复的询问，导致过差的体验；</p><p>曾经有过这样的经历，在面试某大公司的过程，总共经历 4 次面试（三轮技术面，一轮 <code>HR</code> 面）。每一面都需要自我介绍，甚至还有重复的问题，整个过程体验非常差。第一、我觉得该公司并没有尊重我；第二、公司效率很低；第三、只是提自己的问题，从来不考虑候选人的感受；</p><p>所以面完之后我直接拒绝了，虽然浪费了时间，但是却让我排除了一些徒有虚名的公司。</p><div class="alert danger"><p>做好面试纪录，避免重复问题，以及避免第一印象效应。</p></div><h4 id="六、考察综合素质"><a href="#六、考察综合素质" class="headerlink" title="六、考察综合素质"></a>六、考察综合素质</h4><p>为了考察候选人的综合素质，面试过程我们其实可以从六方面去考察：<br>1.知识：<br>也就是我们常说的基本功。</p><p>2.专业技能：<br>职位相关的技术能力，这决定你是否能胜任工作。</p><p>3.能力：<br>个人能力包括：思维能力，学习能力，迁移能力，扩展能力等等。</p><p>4.个性特性：<br>正直诚实，责任心，坚韧性。</p><p>5.动机：<br>体现在成就导向，主动性。</p><p>6.价值观：<br>体现在团队合作。</p><div class="alert success"><p>从技能到性格，再到自驱以及团队合作，相信这样的人不优秀也难。</p></div><h4 id="七、评估"><a href="#七、评估" class="headerlink" title="七、评估"></a>七、评估</h4><p>1.有潜力：<br>能够在一段时间内，通过培养，胜任范围更大，难度更高的项目。</p><p>2.能干活：<br>能够胜任当前的工作，但是因某项能力（技术基础 or 某项软素质）较弱，在发展上会受到一些限制。</p><p>3.三颗完整 <a href="#"><code>STAR</code></a> 确实一项事实：<br>在收集 <code>STAR</code> 的时候不断提出更加深入的问题来判断其对该带我的认知程度及抗压能力。</p><p>优点：尽可能挖掘优点，如果有需要后面可以调整面试方向。<br>不足：基于我们职位要求。</p><p>4.预测：<br>通过其过去的行为来预测将来的行为。</p><div class="alert info"><p>做到上面这些，相信你会成为一个更有魅力的面试官。</p></div><p>不管是作为面试官还是候选人，我们都需要去了解这些流程。作为面试官，我们应该提升自身的综合素质，为公司树立较好的品牌效果。作为候选人，我们可以以此来判断该公司的靠谱程度，避免坐坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为技术面试官，&lt;a href=&quot;http://jartto.wang/2019/01/06/f2e-interview/&quot;&gt;面试过程&lt;/a&gt;很少考虑候选人的感受。上来就是问，不合适就送走。虽然技术环节我很专业，但是其他细节我却知之甚少。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://jartto.wang/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="interview" scheme="http://jartto.wang/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>算法学习思路</title>
    <link href="http://jartto.wang/2019/04/07/learn-algorithm/"/>
    <id>http://jartto.wang/2019/04/07/learn-algorithm/</id>
    <published>2019-04-07T11:06:18.000Z</published>
    <updated>2019-04-07T13:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多前端童鞋对算法都有莫名的恐惧，究其原因无非两点：其一，对算法不了解；其二，没有找到实际应用场景。<br><a id="more"></a></p><h4 id="一、为什么学习算法？"><a href="#一、为什么学习算法？" class="headerlink" title="一、为什么学习算法？"></a>一、为什么学习算法？</h4><p>这是个很有意思的问题，对算法感兴趣的人，不需要问为什么，算法对他们可能是一种兴趣。曾经有位同事，他刷遍了所有算法题，只要有算法竞赛，他都会去参加。当然，也取得了不错的成绩，甚至有了自己的世界排名。</p><p>一次闲聊中，我抛出了这个问题，他笑着说：没有为什么，就是觉得好玩。我一直好奇，为什么有人会觉得算法好玩，兴趣点究竟在哪里？</p><div class="alert info"><p>其实兴趣算一部分，而另一部分则是对编程能力的提升以及思维的扩展。</p></div><p>编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论。</p><p>我们用两张趣图来看看差别：<br>1.学习算法前，你可能这样：<br><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog2.gif" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog2.gif" style="width:70%;" alt></a></div><div style="clear:both;"></div></p><p>2.学习算法后，你变的机灵了：<br><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog1.gif" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog1.gif" style="width:70%;" alt></a></div><div style="clear:both;"></div></p><h4 id="二、如何入门？"><a href="#二、如何入门？" class="headerlink" title="二、如何入门？"></a>二、如何入门？</h4><p>那么如何学习算法呢？这里我推荐一本书《算法图解》，超薄的小册。书中通过一些简单有趣的例子来阐述算法的应用场景。之所以选它作为入门，是因为我们可以用很短的时间去翻读。</p><p>如果你还是觉得很麻烦，不用怕，我已经帮你准备好了学习笔记：</p><ul><li><a href="http://jartto.wang/2018/11/22/algorithm1/">算法图解1 - 二分查找和大O表示法</a></li><li><a href="http://jartto.wang/2018/11/25/algorithm2/">算法图解2 - 数组和链表</a></li><li><a href="http://jartto.wang/2018/11/26/algorithm3/">算法图解3 - 递归，快排</a></li><li><a href="http://jartto.wang/2018/11/27/algorithm4/">算法图解4 - 散列表</a></li><li><a href="http://jartto.wang/2018/11/28/algorithm5/">算法图解5 - 图和广度优先搜索</a></li><li><a href="http://jartto.wang/2018/11/29/algorithm6/">算法图解6 - 狄克斯特拉算法与贪婪算法</a></li><li><a href="http://jartto.wang/2018/11/29/algorithm7/">算法图解7 - 动态规划</a></li></ul><p>书中是围绕 <code>Python</code> 来写的，为了更适合前端童鞋阅读，我已经将相关代码用 <code>JS</code> 实现了一遍。当然，还是有很多的细节，还需要深入的去理解。但是最起码，我不再惧怕算法了，反而慢慢有点喜欢了。</p><div class="alert info"><p>算法的重中之重是培养算法思维。如果你能对算法灵活运用，那么就「大成」了。</p></div><h4 id="三、后面的路怎么走？"><a href="#三、后面的路怎么走？" class="headerlink" title="三、后面的路怎么走？"></a>三、后面的路怎么走？</h4><p>入门从来都不是一件简单的事情，在我们打开这扇神秘大门之后，将会有更多的宝藏需要我们去挖掘。</p><p>想要精通算法，在第一本书读完之后，我们还有更多的目标需要去完成。这里由浅入深的列举一些算法经典书籍，供大家参考学习：</p><p>1.入门系列：<br>《算法图解》《大话数据结构》<br>2.教科书之类：<br>《数据结构与算法分析》<br>3.进阶之旅：<br>《算法导论》<br>4.针对面试准备：<br>《剑指 Offer》《编程珠玑》<br>5.扩展阅读：<br>《算法之美》《算法帝国》<br>6.实践操作：<br>《算法竞赛入门经典》《力扣题库》</p><p>算法其实有很多经典书籍，我们没有那么多的时间去逐一翻阅，但是我们可以有一条明确的学习路线。</p><div class="alert success"><p>这条学习路线就是：入门 - 进阶 - 实践 - 升华</p></div><h4 id="四、配合实践"><a href="#四、配合实践" class="headerlink" title="四、配合实践"></a>四、配合实践</h4><p>其实<a href="http://jartto.wang/2019/04/07/learn-algorithm/">上面</a>已经提到了，在我们掌握算法思维之后，最为重要的一点就是刷题。相信很多童鞋都听过 <code>LeetCode</code> ，目前题库大概有 1000＋ 题目，没事了就去刷刷。</p><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode.png" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode.png" style="width:70%;" alt></a></div><div style="clear:both;"></div><p>当然，刷题也可以由浅入深，先从简单的入手吧！<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode2.png" alt="leetcode"></p><h4 id="五、推荐学习"><a href="#五、推荐学习" class="headerlink" title="五、推荐学习"></a>五、推荐学习</h4><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md" target="_blank" rel="noopener">JavaScript 算法与数据结构</a><br><a href="http://algorithm-visualizer.org/#path=sorting/bucket/basic" target="_blank" rel="noopener">可视化学习算法的好工具</a><br><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">互联网公司最常见的面试算法题有哪些？</a><br><a href="https://github.com/chenfengyanyu/interview" target="_blank" rel="noopener">算法练习，和我一起来刷题吧～</a></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>文章陆陆续续说了这么多，大体总结如下：<br>1.算法很重要，尤其是对于前端童鞋；<br>2.算法学习最好由浅入深，先了解算法思维，再去理解实际应用；<br>3.从一本小而薄的书开启，逐步全面的掌握相关知识体系；<br>4.推荐速成路线：《算法图解》-《剑指 Offer》- LeetCode 刷题 -《算法之美》-《算法导论》；<br>5.去努力实践，刷刷题库，参加参加竞赛；</p><p>好了，就这些吧，祝大家早日搞定算法，带上算法的王冠，去领略算法之美吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多前端童鞋对算法都有莫名的恐惧，究其原因无非两点：其一，对算法不了解；其二，没有找到实际应用场景。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法实践" scheme="http://jartto.wang/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="algorithm" scheme="http://jartto.wang/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>网站优化实战</title>
    <link href="http://jartto.wang/2019/02/16/web-optimization/"/>
    <id>http://jartto.wang/2019/02/16/web-optimization/</id>
    <published>2019-02-16T01:17:29.000Z</published>
    <updated>2019-02-20T13:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站优化是前端开发的重中之重，但是优化细节却十分繁杂。没有好的思路，优化很难高效的开展。本文将以实际网站来做参考，手把手教你如何一步步做好网站优化。<br><a id="more"></a><br>这不是一篇 <code>基础网站优化</code> 文章，继续下文前，请确定已经做了如下<code>基本优化</code>：<br>1.图片压缩、合并<br>2.代码精简、混淆<br>3.减少 <code>iframe</code> 使用<br>4.避免图片 <code>src</code> 为空<br>5.减少 <code>HTTP</code> 请求数<br>6.避免重定向<br>7.样式表放页头，脚本放底部<br>…</p><h4 id="一、优化的意义"><a href="#一、优化的意义" class="headerlink" title="一、优化的意义"></a>一、优化的意义</h4><p>我们可以从两个角度来看这个问题：<br>1.用户角度<br>网站优化能够让页面加载得更快，响应更加及时，极大提升用户体验。</p><p>2.服务商角度<br>优化会减少页面资源请求数，减小请求资源所占带宽大小，从而节省可观的带宽资源。</p><div class="alert info"><p>网站优化的目标是：减少网站加载时间，提高响应速度。</p></div><p>那么网站加载速度和用户体验又有着怎样的关系呢？我们来看下面这张图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/s.png" alt="speed"></p><p><code>Google</code> 和亚马逊的研究表明，<code>Google</code> 页面加载的时间从 <code>0.4</code> 秒提升到 <code>0.9</code> 秒导致丢失了 <code>20%</code> 流量和广告收入，对于亚马逊，页面加载时间每增加 <code>100ms</code> 就意味着 <code>1%</code> 的销售额损失。</p><div class="alert success"><p>可见，页面的加载速度对于用户有着至关重要的影响。</p></div><p>一个好的交互效果可能是这样的：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/good.png" alt="good"></p><h4 id="二、分析网站性能瓶颈"><a href="#二、分析网站性能瓶颈" class="headerlink" title="二、分析网站性能瓶颈"></a>二、分析网站性能瓶颈</h4><p>1.打包文件大小<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/webpack.png" alt="webpack"></p><p>2.打包文件目录<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/tree.png" alt="tree"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── favicon.ico</span><br><span class="line">├── index.html</span><br><span class="line">├── manifest.json</span><br><span class="line">├── static</span><br><span class="line">│   ├── DIN-Medium.1bbe3460.otf</span><br><span class="line">│   ├── DIN-Regular.799221d7.otf</span><br><span class="line">│   └── logo.c57d38d0.png</span><br><span class="line">├── umi.css</span><br><span class="line">├── umi.css.map</span><br><span class="line">├── umi.js</span><br><span class="line">└── umi.js.map</span><br></pre></td></tr></table></figure><div class="alert warning"><p>需要注意：生产环境不要开启 SOURCEMAP</p></div><p>3.静态资源加载时间<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/time.png" alt="time"></p><p>4.资源瀑布：<code>Waterfall</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/ttfb.png" alt="ttfb"></p><p><code>TTFB</code> 全称 <code>Time To First Byte</code>：是指网络请求被发起到从服务器接收到第一个字节的这段时间，它包含了 <code>TCP</code> 连接时间、发送 <code>HTTP</code> 请求时间和获得响应消息第一个字节的时间。</p><div class="alert info"><p>Content Download：即下载内容所需要的时间。</p></div><p>页面一接口情况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/wrong.png" alt="wrong"></p><p>页面二接口情况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/history.png" alt="history"></p><p>用户下载内容所需要的时间，受限于服务器的资源、资源的大小以及用户的网络速度。因此，我们暂时<code>不讨论</code>这方面的内容。</p><p>5.分析工具<br>通过 <code>webpack</code> 打包，分析一下大文件构成。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/bundle.png" alt="bundle"></p><p>6.<code>YSlow</code> 或者 <code>PageSpeed</code><br>我们可以通过 <a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google PageSpeed Insights API Extension</a> 来对 <code>网站整体性能</code> 做一下评估，按照建议去做一些高效优化。</p><p>加载时间概况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed1.png" alt="speed1"></p><p>影响网站加载因素：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed2.png" alt="speed2"></p><p>缓存策略问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed3.png" alt="speed3"></p><p><code>DOM</code> 节点：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed4.png" alt="speed4"></p><p>关键路径：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed5.png" alt="speed5"></p><p>主线程情况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed6.png" alt="speed6"></p><h4 id="三、通过策略解决问题"><a href="#三、通过策略解决问题" class="headerlink" title="三、通过策略解决问题"></a>三、通过策略解决问题</h4><p>1.<code>favicon.ico</code> 404 问题；✓<br>2.去除调试工具代码：<code>eruda</code>，线上环境是不需要的；✓<br>3.图片合并或者多个 <code>svg</code>；✓<br>建议使用 <a href="https://github.com/mixtur/webpack-spritesmith" target="_blank" rel="noopener"><code>webpack-spritesmith</code></a>，简单使用如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> SpritesmithPlugin(&#123;</span><br><span class="line">    src: &#123;</span><br><span class="line">        cwd: path.resolve(__dirname, <span class="string">'src/ico'</span>),</span><br><span class="line">        glob: <span class="string">'*.png'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    target: &#123;</span><br><span class="line">        image: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/jartto.png'</span>),</span><br><span class="line">        css: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/jartto.styl'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    apiOptions: &#123;</span><br><span class="line">        cssImageRef: <span class="string">"~jartto.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>4.大文件拆分 ✓<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/bundle.png" alt="bundle"></p><p>从上图分析得出，大文件主要包含：<code>dist.js</code>，<code>lottie.js</code>，<code>lodash.js</code>，<code>loading.json</code> 等文件。所以我们从这几个文件入手，逐个优化：</p><ul><li><p><code>moment.js</code>：配置 <code>moment</code> 忽略本地化，可减少 <code>70kb</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignoreMomentLocale: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p><code>dist.js</code>：在给单页应用做按需加载优化时，一般采用以下原则：</p></li></ul><ul><li>把整个网站划分成一个个小功能，再按照每个功能的相关程度把它们分成几类。</li><li>把每一类合并为一个 <code>Chunk</code>，按需加载对应的 <code>Chunk</code>。</li><li>对于用户首次打开你的网站时需要看到的画面所对应的功能，不要对它们做按需加载，而是放到执行入口所在的 <code>Chunk</code> 中，以降低用户能感知的网页加载时间。</li><li>对于个别依赖大量代码的功能点，例如依赖 <code>Chart.js</code> 去画图表、依赖 <code>flv.js</code> 去播放视频的功能点，可再对其进行按需加载。</li></ul><ul><li><p><code>lottie.js</code>：分离减少 <code>60kb</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lottie : <span class="string">'react-lottie'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>lodash.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lodash : &#123;</span><br><span class="line">    commonjs: <span class="string">'lodash'</span>,</span><br><span class="line">    amd: <span class="string">'lodash'</span>,</span><br><span class="line">    root: <span class="string">'_'</span> <span class="comment">// indicates global variable</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>动态导入以及文件拆分</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dynamicImport: &#123;</span><br><span class="line">  webpackChunkName: <span class="literal">true</span>,</span><br><span class="line">  loadingComponent: <span class="string">'./components/Loading/jartto.js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>按照上面我们一步步处理后，重新打包分析一下文件构成：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/bundle1.png" alt="bundle1"></p><p>这里为什么没有继续拆分 <code>dist.js</code> ，是因为目前阶段没有好的方案，需要对代码做很多调整，所以暂且保留。相关信息可以在 <code>Ant-Design Issuse</code> <a href="https://github.com/ant-design/ant-design/issues/12011" target="_blank" rel="noopener">Svg icons make bunlde size too large </a> 中查看解决方案。</p><p>5.存放 <code>CDN</code></p><ul><li><code>loading.json</code>，大小54kb ✓</li><li><code>svg</code> 替换 2 倍图 ✓</li><li>删除项目冗余图片 ✓</li></ul><p>6.优化 <code>TTFB</code></p><ul><li>减少 <code>DNS</code> 查询</li><li>使用 <code>CDN</code></li><li>提早 <code>Flush</code></li><li>添加周期头</li></ul><p>7.移除阻塞渲染的资源</p><ul><li><p><code>css</code> 预加载 <code>preload</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>异步加载第三方资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://cdn.jartto.wang/fastclick.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>没有 <code>async</code> 属性，<code>script</code> 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。如果有 <code>async</code> 属性，那么<code>script</code> 将被异步下载并执行，同时浏览器继续后续的处理。</p><p>8.确保文本在网页字体加载期间保持可见状态<br>利用 <code>font-display</code> 这项 <code>CSS</code> 功能，确保文本在网页字体加载期间始终对用户可见。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Arvo'</span>;</span><br><span class="line">    <span class="attribute">font-display</span>: auto;</span><br><span class="line">    <span class="attribute">src</span>:<span class="built_in">local</span>(<span class="string">'Arvo'</span>),<span class="built_in">url</span>(https://fonts.jartto.wang/fonts/temp.woff2)<span class="built_in">format</span>(<span class="string">'woff2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9.采用高效的缓存策略提供静态资源<br><div class="alert info"><p>延长缓存期限可加快重访网页的速度。</p></div></p><p><code>DNS TTL(Time-To-Live)</code>，简单的说它表示一条域名解析记录在 <code>DNS</code> 服务器上缓存时间.</p><p>当各地的 <code>DNS</code> 服务器接受到解析请求时，就会向域名指定的 <code>DNS</code> 服务器发出解析请求从而获得解析记录；<br>在获得这个记录之后，记录会在 <code>DNS</code> 服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，<code>DNS</code> 服务器将不再向 <code>DNS</code> 服务器发出请求，而是直接返回刚才获得的记录；</p><div class="alert info"><p>而这个记录在 <code>DNS</code> 服务器上保留的时间，就是 <code>TTL</code> 值。</p></div><p>所以一般更新域名解析的步骤如下：</p><ol><li>先查看域名当前的 <code>TTL</code> 值。</li><li>修改 <code>TTL</code> 值为可设定的最小值，建议为 60 秒。</li><li>等待一天，保证各地的 <code>DNS</code> 服务器缓存都过期并更新了记录。</li><li>设置修改 <code>DNS</code> 解析到新的记录，这个时候各地的 <code>DNS</code> 就能以最快的速度更新到新的记录。</li><li>确认各地的 <code>DNS</code> 已经更新完成后，再 <code>TTL</code> 值设置成常用的值(如: <code>TTL=86400</code>)。</li></ol><p>如下图，<code>TTL</code> 值设置的最佳实践，可供参考：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/ttl.jpg" alt="ttl"></p><div class="alert success"><p>后文我们会详细介绍 <code>DNS</code> 相关内容，欢迎各位童鞋关注。</p></div><p>10.避免 <code>DOM</code> 规模过大<br>网页包含的 <code>DOM</code> 节点最好少于 <code>1500</code> 个左右。理想状况是，树深度少于 <code>32</code> 个元素，且少于 <code>60</code> 个子/父元素。大型 <code>DOM</code> 可能会增加内存使用量、导致样式计算用时延长并产生高昂的布局重排费用。</p><p>11.最大限度地缩短关键请求深度<br><div class="alert info"><p><code>关键请求链</code> 显示了以高优先级加载的资源。</p></div><br>我们可以通过：缩短链长、缩减资源的下载文件大小，或者推迟下载不必要的资源，从而提高网页加载速度。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/parse.png" alt="parse"></p><p>当 <code>HTML</code> 解析过程中遇到一个 <code>script</code> 标记时，它会暂停 <code>DOM</code> 构建，将控制权移交给 <code>JavaScript</code> 引擎，等<code>JavaScript</code> 引擎运行完毕，浏览器再从中断的地方恢复 <code>DOM</code> 构建。</p><div class="alert danger"><p>也就是说，执行内联的 <code>JavaScript</code> 会阻塞页面的首次渲染。</p></div><p>在关键渲染路径中，我们通常要关注三个点：</p><ul><li>页面首次渲染需要的关键资源数量</li><li>关键资源的大小</li><li>关键渲染路径的往返次数（Roundtrip）</li></ul><div class="alert success"><p>我们的策略也非常简单，就是减少关键资源数量，降低资源大小，减少关键路径的往返次数。</p></div><p>优化关键渲染路径的常规步骤如下：<br>a. 对关键路径进行分析和特性描述：资源数、字节数、长度。<br>b. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>c. 优化关键字节数以缩短下载时间（往返次数）。<br>d. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资源，以缩短关键路径长度。</p><p>更多详情，请参考<a href="https://segmentfault.com/a/1190000013767948" target="_blank" rel="noopener">前端性能优化—关键渲染路径</a>。</p><p>12.最大限度地减少主线程工作<br>考虑减少为解析、编译和执行 <code>JS</code> 而花费的时间。我们可以提供较小的 <code>JS</code> 负载来实现此目标。</p><p>13.最优配置 <code>nginx</code><br>a. <code>gzip</code> 配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip  on;</span><br><span class="line">gzip_min_length  1k;</span><br><span class="line">gzip_buffers     4 8k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 4;</span><br><span class="line">gzip_types text/plain text/css application/json image/png image/x-icon application/javascript application/x-javascript text/javascript text/xml application/xml application/xml+rss text/cache-manifest application/octet-stream;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure></p><p>b. <code>nginx</code> 开启缓存<br>如果你对浏览器缓存还不太清楚，欢迎移步<a href="http://jartto.wang/2019/02/14/web-cache/">聊一聊浏览器缓存机制</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(html|htm|js|css|gif|jpg|jpeg|png|bmp|swf|ico|json|otf)$ &#123;</span><br><span class="line">  root /var/www/jartto_web/;</span><br><span class="line">  index index.html;</span><br><span class="line">  expires 1d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>Nginx 能非常有效地直接处理静态内容。在静态文件和 Nginx 在同一主机的情况下，这种特性尤为有用。</p></div><h4 id="四、效果如何？"><a href="#四、效果如何？" class="headerlink" title="四、效果如何？"></a>四、效果如何？</h4><div class="alert warning"><p>优化前：网站评分 27 ，首次内容绘制 6.9 秒</p></div><p>1.网站评分<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/opt1.png" alt="opt1"></p><p>2.加载概况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed1.png" alt="speed1"></p><div class="alert info"><p>优化后：网站评分 70 ，首次内容绘制 1.6 秒</p></div><p>1.网站评分<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/opt2.png" alt="opt2"></p><p>2.加载概况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed7.png" alt="speed7"></p><div class="alert success"><p>当然，优化还可以做更多，我们尽量让网站的评分接近 100 分，譬如：</p></div><p>1.网站评分<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/opt3.png" alt="opt3"></p><p>2.加载概况：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/web-optimization/speed8.png" alt="speed8"></p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>我们从头优化下来，做了不少代码改动，也达到了不错的效果。但是有几点还是需要注意：<br>1.尽可能减少白屏出现时间<br>骨架图解决 <code>webview</code> 加载页面过长的白屏过程。</p><p>2.关注整站性能，如 <code>TTFB</code><br>服务端接口也需要同步优化，而不要仅仅依赖前端单方面优化。</p><p>3.按照使用情况加载优先使用的资源</p><ul><li>css 预加载</li><li>font 预加载</li><li>js 预加载</li><li>图片懒加载</li></ul><p>4.请高效利用 <code>DNS</code> 和 <code>CDN</code></p><ul><li>增加缓存时间</li><li><code>DNS</code> 预解析</li></ul><p>网站优化从来不是一蹴而就，需要不断的去优化细节，不断的摸索尝试。从我的角度来看，其实优化更像是在网站性能和加载速度之间找到一个平衡点。譬如，<a href="http://jartto.wang/2019/02/16/web-optimization/">文中</a>我们为了优化文件打包大小，进行了大文件拆分。随之而来的问题就是拆分后的文件可能还会对某些文件有依赖，那么就影响到了关键渲染路径。</p><p>所以，优化不存在什么奇技淫巧，不断的去尝试，找到这个最佳优化点，这才是根本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站优化是前端开发的重中之重，但是优化细节却十分繁杂。没有好的思路，优化很难高效的开展。本文将以实际网站来做参考，手把手教你如何一步步做好网站优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊浏览器缓存机制</title>
    <link href="http://jartto.wang/2019/02/14/web-cache/"/>
    <id>http://jartto.wang/2019/02/14/web-cache/</id>
    <published>2019-02-14T00:54:13.000Z</published>
    <updated>2019-02-16T14:08:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多前端童鞋对于浏览器缓存都不太陌生，但是如果没有系统的归纳总结，可能三言两句很难说明白。如何才能完美的回答，这是一个值得思考的问题。<br><a id="more"></a></p><div class="alert success"><p>当然，我们不能为了应对面试才去掌握，而应该当作技能储备起来，做到活学活用。</p></div><h4 id="一、为什么要缓存"><a href="#一、为什么要缓存" class="headerlink" title="一、为什么要缓存"></a>一、为什么要缓存</h4><p>1.缓存可以减少用户等待时间，提升用户体验；<br>2.减少网络带宽消耗<br>对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本。</p><p>3.降低服务器压力<br>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。此外，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><div class="alert warning"><p>需要注意：缓存使用不当，会有「脏数据」，导致用户数据异常。</p></div><h4 id="二、常见缓存类型"><a href="#二、常见缓存类型" class="headerlink" title="二、常见缓存类型"></a>二、常见缓存类型</h4><div class="alert info"><p>浏览器缓存分为强缓存和协商缓存。</p></div><p>强缓存<br>1.<code>Expires</code>：<code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间<br><code>Expires</code> 也是需要在服务端配置（具体配置也根据服务器而定），<code>Expires</code> 添加的是该资源过期的日期。浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。</p><p>通过这种方式，可以实现直接从浏览器缓存中读取，而不需要去服务端判断是否已经缓存，避免了这次 <code>HTTP</code> 请求。值得注意的是 <code>Expires</code> 时间可能存在 <code>客户端时间跟服务端时间不一致</code> 的问题。</p><div class="alert info"><p>建议 Expires 结合 Cache-Control 一起使用，大型网站中一起使用的情况比较多见。</p></div><p>2.<code>Cache-Control</code>: <code>max-age</code> 强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒。<br><code>Cache-Control</code> 属性值是在 <code>server</code> 端配置的，不同的服务器有不同的配置，<code>web</code> 服务器 <code>apache</code>、<code>nginx</code>、<code>IIS</code> ,应用服务器 <code>tomcat</code> 等配置都不尽相同；</p><p>协商缓存<br>1.<code>Last-Modified</code>：值为资源最后更新时间，随服务器 <code>Response</code> 返回</p><p>2.<code>If-Modified-Since</code>：通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存。</p><p>3.<code>ETag</code>：表示资源内容的唯一标识，随服务器 <code>Response</code> 返回。<br><code>Web</code> 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识</p><div class="alert danger"><p>注：HTTP 中并没有指定如何生成 ETag，哈希是比较理想的选择。</p></div><p>4.<code>If-None-Match</code><br>服务器通过比较请求头部的 <code>If-None-Match</code> 与当前资源的 <code>ETag</code> 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存。</p><h4 id="三、缓存流程解析"><a href="#三、缓存流程解析" class="headerlink" title="三、缓存流程解析"></a>三、缓存流程解析</h4><p>看完上面的概念，我们来看看缓存流程是怎样的？先来看看下面这张图：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/cache/process.png" alt="process"></p><p>如上图所示：<br>1.浏览器会先检测强缓存类型（<code>Cache-Control</code> 或者 <code>Expires</code>）是否有效；<br>2.如果命中了强缓存，则直接从本地获取缓存资源；<br>3.当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 <code>Request Header</code> 验证这个资源是否命中协商缓存，称为 <code>HTTP</code> 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；<br>4.强缓存不会发送请求到服务器，但协商缓存会发送服务器请求；<br>5.当协商缓存也没命中时，服务器就会将资源发送回客户端。</p><p>需要注意：<br>1.强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；<br>2.当 <code>F5</code> 刷新网页时，跳过强缓存，但是会检查协商缓存；<br>3.当 <code>Ctrl + F5</code> 强制刷新页面时，直接从服务器加载，跳过强缓存和协商缓存；</p><h4 id="四、不会缓存的情况"><a href="#四、不会缓存的情况" class="headerlink" title="四、不会缓存的情况"></a>四、不会缓存的情况</h4><p>当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：<br>1.<code>HTTP</code> 信息头中包含 <code>Cache-Control:no-cache</code> ，<code>pragma:no-cache（HTTP1.0）</code>，或<code>Cache-Control: max-age=0</code> 等告诉浏览器不用缓存的请求；<br>2.需要根据 <code>Cookie</code>，认证信息等决定输入内容的动态请求是不能被缓存的；<br>3.经过 <code>HTTPS</code> 安全加密的请求；<br>4.<code>POST</code> 请求无法被缓存；<br>5.<code>HTTP</code> 响应头中不包含 <code>Last-Modified/Etag</code>，也不包含 <code>Cache-Control/Expires</code> 的请求无法被缓存；</p><h4 id="五、小故事大道理"><a href="#五、小故事大道理" class="headerlink" title="五、小故事大道理"></a>五、小故事大道理</h4><p>上文对整个概念做了阐述，还是不够形象，我们来通过几个小故事生动理解一下：</p><p>故事一：<code>Last-Modified</code><br>浏览器：<code>Hi</code>，我需要 <code>jartto.min.js</code> 这个文件，如果是在 <code>Last-Modified: Fri Feb 15 2019 19:57:31 GMT</code> 之后修改过的，请发给我。<br>服务器：（检查文件的修改时间）<br>服务器：<code>Oh</code>，这个文件在那个时间之后没有被修改过，你已经有最新的版本了。<br>浏览器：太好了，那我就显示给用户了。</p><p>故事二：<code>ETag</code><br>浏览器：<code>Hi</code>，我需要 <code>jartto.css</code> 这个文件，有没有不匹配 <code>3c61f-1c1-2aecb436</code> 这个串的<br>服务器：（检查 <code>ETag</code>…）<br>服务器：<code>Hey</code>，我这里的版本也是 <code>3c61f-1c1-2aecb436</code>，你已经是最新的版本了<br>浏览器：好，那就可以使用本地缓存了</p><div class="alert success"><p>看完这两个小故事，是否对协商缓存有了更清晰的认识了。</p></div><p>参考：<br><a href="https://www.cnblogs.com/slly/p/6732749.html" target="_blank" rel="noopener">浏览器缓存机制详解</a><br><a href="https://www.cnblogs.com/etoah/p/5579622.html" target="_blank" rel="noopener">web性能优化:详说浏览器缓存</a><br><a href="https://blog.csdn.net/bluedandelion/article/details/80895021" target="_blank" rel="noopener">前端性能优化之缓存利用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多前端童鞋对于浏览器缓存都不太陌生，但是如果没有系统的归纳总结，可能三言两句很难说明白。如何才能完美的回答，这是一个值得思考的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="http" scheme="http://jartto.wang/tags/http/"/>
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="cache" scheme="http://jartto.wang/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>JS 基础｜搞懂 typeof 和 instanceof</title>
    <link href="http://jartto.wang/2019/01/17/js-typeof/"/>
    <id>http://jartto.wang/2019/01/17/js-typeof/</id>
    <published>2019-01-17T15:21:53.000Z</published>
    <updated>2019-03-18T09:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 Code Review 的时候，发现了一些小问题，查出结果之后发现竟然是因为 typeof 和 instanceof 引发的。<br><a id="more"></a><br>这属于 <code>JS</code> 的基础知识，正是由于太基础了，所以很容易被忽略，导致项目中随处可见的滥用。</p><div class="alert success"><p>为了巩固基础，我会通过实例来详细说明，让我们一起搞懂 typeof 和 instanceof。</p></div><h4 id="一、typeof"><a href="#一、typeof" class="headerlink" title="一、typeof"></a>一、typeof</h4><p><code>typeof</code> 其实就是判断参数是什么类型的实例，就一个参数，用例：<code>typeof A</code><br>返回值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;</span><br></pre></td></tr></table></figure></p><p>我们先来验证几个基本类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'jartto'</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> !!’<span class="number">0</span>’; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> name; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>这里可以扩展一下，假如我们要判断某个变量是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!a) &#123; console.log(&apos;error&apos;)&#125;</span><br></pre></td></tr></table></figure></p><p>这时候，控制台会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p>所以我们可以使用 <code>typeof</code> 来判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">'undefined'</span>) &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>这样，就能避免代码异常，是一种比较严谨的处理方式。</p></div><p>需要注意：<br><code>ES6</code> 中 <code>let</code> 和 <code>const</code> 会形成「暂时性死区」也意味着 <code>typeof</code> 不再是一个百分之百安全的操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure></p><p>上面代码中，变量 <code>x</code> 使用 <code>let</code> 命令声明，所以在声明之前，都属于 <code>x</code> 的「死区」，只要用到该变量就会报错。因此，<code>typeof</code> 运行时就会抛出一个 <code>ReferenceError</code>。</p><p>如果用 <code>typeof</code> 来判断引用类型，会有怎样的结果？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'jartto'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> obj1; <span class="comment">// object</span></span><br></pre></td></tr></table></figure></p><p>如上所示，引用类型的数据，都返回了 <code>object</code>，我们无法做到精确判断。我们来总结一下：<br>1.对于基本类型，除 <code>null</code> 以外，均可以返回正确的结果。<br>2.对于引用类型，除 <code>function</code> 以外，一律返回 <code>object</code> 类型。<br>3.对于 <code>null</code> ，返回 <code>object</code> 类型。<br>4.对于 <code>function</code> 返回 <code>function</code> 类型。</p><div class="alert info"><p>这就需要用到 instanceof 来检测某个对象是不是另一个对象的实例。</p></div><h4 id="二、instanceof"><a href="#二、instanceof" class="headerlink" title="二、instanceof"></a>二、instanceof</h4><p><code>instanceof</code> 是用来判断 <code>A</code> 是否为 <code>B</code> 的实例，表达式为：<code>A instanceof B</code>，如果 <code>A</code> 是 <code>B</code> 的实例，则返回 <code>true</code>,否则返回 <code>false</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例来自于：https://blog.csdn.net/liwenfei123/article/details/77978027</span></span><br><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    <span class="keyword">var</span> L = A.__proto__;</span><br><span class="line">    <span class="keyword">var</span> R = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">//A的内部属性__proto__指向B的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述过程可以看出，当 <code>A</code> 的 <code>__proto__</code> 指向 <code>B</code> 的 <code>prototype</code> 时，就认为 <code>A</code> 就是 <code>B</code> 的实例，我们来看几个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p><code>JS</code> 中万物皆对象的思想：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>再举个例子，我们通过一个简单的继承来说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Other</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child <span class="keyword">instanceof</span> Child; <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent; <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> Other; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>很简单，我们只需要理解下面这行代码就可以了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></p><h4 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h4><p>我们来分析一下 <code>[]</code>、<code>Array</code>、<code>Object</code> 三者之间的关系：</p><p>从 <code>instanceof</code> 能够判断出 <code>[].proto</code> 指向 <code>Array.prototype</code>，而 <code>Array.prototype.proto</code> 又指向了<code>Object.prototype</code>，最终 <code>Object.prototype.proto</code> 指向了 <code>null</code>，标志着原型链的结束。</p><p>因此，<code>[]</code>、<code>Array</code>、<code>Object</code> 就在内部形成了一条原型链：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/typeof/proto.jpeg" alt="proto"><br>依次类推，类似的 <code>new Date()</code>、<code>new Parent()</code> 也会形成一条对应的原型链 。</p><div class="alert success"><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p></div><h4 id="四、巩固知识"><a href="#四、巩固知识" class="headerlink" title="四、巩固知识"></a>四、巩固知识</h4><p>Question 1：下面如何输出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun);</span><br><span class="line"><span class="built_in">console</span>.log(fun <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fun <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure></p><p>答：<code>function</code>, <code>true</code>, <code>true</code></p><p>Question2：如何判断一个变量是否为数组？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要用 typeof 判断</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是es3的规定，但是这必须假定只有一个全局执行环境</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的标准</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>答：通过 <code>instanceof</code> 判断，或者 <code>isArray</code> 来判断。</p><p>Question3：下面函数输出结果是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'Jartto'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hi~ '</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>答：这里需要注意变量声明提升，所以上面代码等效于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'Jartto'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hi~ '</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>这时候，<code>typeof name</code> 就等于 <code>undefined</code>，所以输出结果为 <code>Hi~Jartto</code>。</p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>突然发现我们总是忙碌于写业务，却忽略了基础的重要性。所以在不断写 <code>Bug</code> 和解决 <code>Bug</code> 的路上越走越远，却徒劳无获。</p><p>既然如此，那么我们就从当下开始，打好根基。我会陆续更新更多 <code>JS</code> 基础相关知识，大家共同学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 Code Review 的时候，发现了一些小问题，查出结果之后发现竟然是因为 typeof 和 instanceof 引发的。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="js" scheme="http://jartto.wang/tags/js/"/>
    
      <category term="typeof" scheme="http://jartto.wang/tags/typeof/"/>
    
      <category term="instanceof" scheme="http://jartto.wang/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>网站地图方案汇总，教你玩转可视化</title>
    <link href="http://jartto.wang/2019/01/06/map-case/"/>
    <id>http://jartto.wang/2019/01/06/map-case/</id>
    <published>2019-01-06T14:07:39.000Z</published>
    <updated>2019-01-09T00:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据可视化一直是大数据时代的核心，因为可视化能被更多的人看懂，数据才有了价值。如果你的网站要做可视化，除了各类统计图外，唯一不可或缺的元素就是地图。<br><a id="more"></a><br>不用担心，我已经帮你整理好了一份超详细的网站地图方案，快来看看吧。</p><h4 id="一、方案汇总"><a href="#一、方案汇总" class="headerlink" title="一、方案汇总"></a>一、方案汇总</h4><div class="alert success"><p>Top 1：Mapbox（推荐指数：☆☆☆☆☆）</p></div><p><a href="https://www.mapbox.com/" target="_blank" rel="noopener"><code>Mapbox</code></a> 地图风格会让你耳目一新，同时如同游戏般体验的地图动画效果更是如虎添翼。需要商业化或者一些重要推广活动的场景，可以用来数据演示，效果非常酷炫。唯一遗憾就是，<code>Mapbox</code> 是收费的。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/mapbox.png" alt="mapbox"></p><div class="alert success"><p>Top 2：Carto（推荐指数：☆☆☆☆☆）</p></div><p><a href="https://carto.com/" target="_blank" rel="noopener"><code>Carto</code></a> 是使用最佳数据流构建功能强大的位置智能应用程序的平台。当然，也是收费的。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/carto.gif" alt="carto"></p><div class="alert success"><p>Top 3：Google Map（推荐指数：☆☆☆☆☆）</p></div><p><a href="https://developers.google.com/maps/" target="_blank" rel="noopener"><code>Google</code></a> 地图就不用多说了，全世界都在流行，大部分地图公司数据和接口都是基于 <code>Google</code> 的。除此之外，<code>Google Map</code> 交互和设计也很不错。如果你需要做全球化地图可视化，建议使用 <code>Google Map</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/google.png" alt="google"></p><div class="alert success"><p>Top 4：deck.gl 推荐指数：☆☆☆☆</p></div><p><a href="http://deck.gl/#/" target="_blank" rel="noopener">deck.gl</a> 是一个 WebGL 驱动的框架，用于对大型数据集进行可视化探索性数据分析。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/deck-gl.png" alt="deck-gl"></p><div class="alert success"><p>Top 5：AMap 推荐指数：☆☆☆☆</p></div><p>高德地图（<a href="https://lbs.amap.com/" target="_blank" rel="noopener">AMap</a>）算是国内做的比较好的地图服务，功能强大，文档全面，对开发者友好。基本上可以满足一些数据可视化需求，此外，高德地图完全免费。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/amap.png" alt="amap"></p><div class="alert success"><p>Top 6：BMap 推荐指数：☆☆☆☆</p></div><p>百度地图加上 <code>ECharts</code> 一站式可视化，对开发者有着不小的吸引力。完善的中文文档和 <code>Demo</code>，强大的组件开发。此外，百度地图也是免费试用。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/bmap.png" alt="bmap"></p><p><a href="http://lbsyun.baidu.com" target="_blank" rel="noopener"><code>ECharts</code></a> 内接百度地图<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/echarts.png" alt="echarts"></p><div class="alert success"><p>Top 7：QQ.Map 推荐指数：☆☆☆☆</p></div><p>腾讯地图<a href="https://lbs.qq.com" target="_blank" rel="noopener">QQ.Map</a>，个人觉得仅次于高德和百度，但其应用场景却无处不在。滴滴，美团，摩拜，大众点评这些都使用了腾讯地图。要跟用户发生关系，当然得找大型社交平台了。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/qqmap.png" alt="qqmap"></p><div class="alert success"><p>Top 8：FengMap 推荐指数：☆☆☆☆</p></div><p><a href="https://www.fengmap.com/" target="_blank" rel="noopener">蜂鸟</a>视图具备专业的可视化地图数据生产团队，可满足各领域客户对高精度三维模型、室内地图的需求，提供各类大型复杂场景的三维地图模型制作服务。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/map/fmap.jpeg" alt="fmap"></p><h4 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h4><p>上面介绍了很多款地图，总体来说，各有优缺点。我来大概总结一下：</p><p>1.如果你对预算没有要求，而且需要很酷炫的功能，建议使用 Mapbox；<br>2.如果对地图改动较大，建议选择 Google Map，灵活的 API 可以让你更友好的扩展；<br>3.如果对细节要求很高，譬如：要精确显示某一条街道。那么尽量不要选国外地图，高德、百度、腾讯都是不错的选择；<br>4.如果你有其他数据可视化的要求，可以考虑 ECharts ＋ BMap 组合，比较容易无缝接入；<br>5.如果2C的话，并且想要用户黏性，那么可以试试腾讯地图；<br>6.如果想要更加立体或者3D效果，偏向于室内应用，如商场，酒店之类的场景，可以考虑蜂鸟室内地图；</p><div class="alert success"><p>地图没有好坏之分，贴合自己的使用场景，选择最好的地图方案，才能达到最佳的效果。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据可视化一直是大数据时代的核心，因为可视化能被更多的人看懂，数据才有了价值。如果你的网站要做可视化，除了各类统计图外，唯一不可或缺的元素就是地图。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端分享" scheme="http://jartto.wang/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="地图" scheme="http://jartto.wang/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="google" scheme="http://jartto.wang/tags/google/"/>
    
      <category term="高德" scheme="http://jartto.wang/tags/%E9%AB%98%E5%BE%B7/"/>
    
      <category term="百度" scheme="http://jartto.wang/tags/%E7%99%BE%E5%BA%A6/"/>
    
      <category term="腾讯" scheme="http://jartto.wang/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="mapbox" scheme="http://jartto.wang/tags/mapbox/"/>
    
  </entry>
  
  <entry>
    <title>前端面试官的套路，你懂吗？</title>
    <link href="http://jartto.wang/2019/01/06/f2e-interview/"/>
    <id>http://jartto.wang/2019/01/06/f2e-interview/</id>
    <published>2019-01-06T04:25:44.000Z</published>
    <updated>2019-01-06T14:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一年陆陆续续都在面试各种不同程度的 Web 前端开发，总觉得现在前端氛围太过于浮躁，急于求成的人比比皆是。<br><a id="more"></a><br>然而很多童鞋还是没有掌握面试的技巧，一次次碰壁。鉴于此，我觉得是时候总结一些面试经验了，只不过这一次我打算从面试官的角度来阐述。</p><div class="alert success"><p>我是如何面试前端的？</p></div><h4 id="一、筛选简历"><a href="#一、筛选简历" class="headerlink" title="一、筛选简历"></a>一、筛选简历</h4><p>我们先从筛选简历阶段说起，一般人力同事会帮我们去捞一些合适的简历，但是很多时候技术开发自己也不会闲着，而不同职能的人捞简历的方式也千差万别。</p><div class="alert warning"><p>先从我自己捞简历的角度来说吧，当然，不同的面试官有不同的风格，不可尽信。</p></div><p>1.我一般会去看简历中所提的技术栈是否匹配，怎么看呢？我们可以抓住简历中的技术名词，一般来说如果一点技术名词都没有提到，那么大概有以下几种可能：</p><ul><li>很水</li><li>很牛但是概率很小</li><li>不会写简历</li></ul><p>所以，一部分人可能会因为简历的问题没有了面试机会，这点是需要非常注意的。</p><div class="alert info"><p>那么有人可能会问，那我该如何在简历里面体现我的技术实力呢？</p></div><p>我们举个简单的例子，假如你要面试一个公司，他们主招 React 技术栈的前端开发，那么你的简历里面只有 React 这个名词是不够的，最好能体现出 React 的生态来。</p><p>这样写就不错：熟练使用 Antd＋React＋Redux 开发项目，Roadhog 或者 Webpack 构建项目，Nextjs 做服务端渲染。</p><p>其他技术栈类似，了解技术栈的周边生态，间接的反应了项目的体量。</p><h4 id="二、个人介绍"><a href="#二、个人介绍" class="headerlink" title="二、个人介绍"></a>二、个人介绍</h4><p>通过了简历筛选阶段，就真正到了面试环节。这时候一定要准备好一段最多 3 分钟的个人介绍。</p><div class="alert info"><p>请注意，最多 3 分钟！</p></div><p>碰到过这样的面试者，一段个人介绍说不完，滔滔不绝，从高中时代说起，然而面试官并没有那么多的耐心和时间。这样会留下不太好的初次印象。正确的做法是：<br><div class="alert success"><p>言简意赅的说明自己的工作时间，擅长技术栈和自己的工作预期。</p></div></p><h4 id="三、技术名词"><a href="#三、技术名词" class="headerlink" title="三、技术名词"></a>三、技术名词</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/pic2.png" alt="pic2"><br>既然我是通过技术名词来筛选简历，这就成为了我面试的重点考察区域。简历堆砌技术名词其实是一把双刃剑：<br>1.不写技术名词，简历容易被刷掉；<br>2.写上的话，可是需要充分的准备哦，否则这可能成为你的软肋；</p><p>为了充分说明，我举几个例子（这是真实面试的反馈）：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/resume1.jpg" alt="ruseum1"></p><p>再来看一个：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/resume2.jpg" alt="ruseum2"></p><p>可以看到，技术点我都会去问一下，根据掌握度，会有一个简单的评分（1-5）。而这个评分就是我定级的标准，后面会详细说明。</p><h4 id="四、挖掘项目的深度"><a href="#四、挖掘项目的深度" class="headerlink" title="四、挖掘项目的深度"></a>四、挖掘项目的深度</h4><p>项目经验也是面试中比较重要的一个环节，为了对面试者有一个全面的认识，所以我会花一些时间聊聊面试者做过的项目。</p><p>当然，不会有人只写一个项目，所以我的问题就变成了：能看出来你做过不少项目，有没有哪个项目是你做的最好，值得骄傲的？</p><div class="alert info"><p>这样，我就可以从最好的项目入手，省去了人为过滤的麻烦。</p></div><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/pic1.png" alt="pic1"></p><p>当面试者开始讲自己项目的同时，作为面试官，我有几件事情需要确定：</p><p>1.首先要确定项目是否是自己做的，即确定项目的真实性；</p><p>举个例子：你的项目是 <code>React</code> 搭建的，能告诉我搭建项目的过程和需要注意的地方吗？<br>这时候有人就漏底了，除了 <code>Create-react-app</code> 之外，什么都说不出来。难道你不用 <code>Router</code> 吗，难道不需要处理静态资源吗，难道不需要构建吗？<br><div class="alert danger"><p>细问之下，告诉我项目是其他同事搭建的，自己只负责开发业务。</p></div></p><p>2.项目的缺陷<br>我们在架构项目的时候，想的太多会过度设计，想的太少则可能会出现随着业务增长而来的种种问题。很多企业都在探索某个技术领域的最佳实践，其实并没有行业通用标准，只是思想可以借鉴罢了。</p><p>当然，你如果经验丰富，并且能不断重构，是可以修复一些项目缺陷。嗯，所以我的问题又来了：在项目中有没有碰到过一些问题，你是如何解决的？</p><div class="alert info"><p>这里主要考察面试者实际处理问题的能力，以及是否有独立思考的过程，这个很重要。</p></div><p>3.项目的深度</p><p>项目做到一定规模以后，一定会去深挖原理，甚至原本的架构或者插件都无法满足。举个例子：如果没有扩展过 <code>Webpack Loader</code> 的项目，基本可以肯定是一个小型项目，中型或大型项目以及业务复杂的项目都或多或少有一些方向的扩展。</p><p>项目深度的考察其实比较难，总会有一些行业通用问题需要去解决，这也就是 <code>BAT</code>，<code>TMD</code> 这些公司经常会去制定一些行业标准，开源一些技术方案的原因。</p><p>当然，很多公司还是达不到这个层次，所以项目深度也是因人而异，并没有通用标准。</p><div class="alert info"><p>所以考察方向就成了对这个项目的持续开发，垂直领域以及深度思考。</p></div><h4 id="五、程序基础，手写代码，算法"><a href="#五、程序基础，手写代码，算法" class="headerlink" title="五、程序基础，手写代码，算法"></a>五、程序基础，手写代码，算法</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/pic5.png" alt="pic5"></p><div class="alert info"><p>看到过这样一个问题：面试要求手写代码的面试官是不是都很 Low？</p></div><p>显然不是，通过写代码可以看出一个人的编程功底和思想。另一方面，我们很多时候都在阅读别人的代码，所以能迅速的看出你代码问题的人，在我看来，能力是在你之上的。</p><p>一般手写代码都集中在：数组操作、原生 <code>JS</code>、算法实现、以及数据结构这几方面。部分前端有可能会有一些 <code>CSS</code> 布局要求。这里我就不展开说明了，后续会出系列文章来探讨笔试面试题相关内容。欢迎关注，欢迎探讨。</p><h4 id="六、技术热情"><a href="#六、技术热情" class="headerlink" title="六、技术热情"></a>六、技术热情</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/pic4.png" alt="pic4"><br>我们来举两个例子：</p><p>问：<code>HTML5</code> 的地理定位你用过的场景是什么？</p><p>答：<code>balbalbal</code>…</p><p>问：有没有遇到过定位不准的情况，浏览器定位的原理究竟是什么呢？</p><p>答：……</p><p>再譬如：</p><p>问：<code>webpack</code> 你最常用的 <code>loader</code> 都有哪些？</p><p>答：<code>balbalbal</code>…<code>Babel</code></p><p>问：<code>Babel</code> 的作用是什么？</p><p>答：<code>balbalbal</code>…</p><p>问：有没有了解过 <code>Babel</code> 的原理，它是如何做到的呢？</p><p>答：……</p><p>相信大家也看出问题了，这位同学会有一些简单的使用场景，但是一追问原理，就一无所知。所以你觉得他对技术有热情吗，难道你对技术一点都不好奇吗？</p><div class="alert success"><p>技术热情决定了你在这行的成就，也决定了你是否能走得更远。</p></div><h4 id="七、个人规划"><a href="#七、个人规划" class="headerlink" title="七、个人规划"></a>七、个人规划</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/pic3.png" alt="pic3"><br>你一定很奇怪，为什么会考察个人规划？</p><p>原本我也是认为一些个人规划都是空谈主义，整一些虚无缥缈的东西有意思吗？然而实际并非如此，当我陆续面过很多工作 10 年之久的行业前辈的时候，我会发现有些人之后的几年毫无进展，完全是在混资历，技术一塌糊涂。</p><p>这时候我就有了反思，为什么会有这种现象，我猜测大概有如下几点原因：<br>1.没有个人规划，走哪算哪，混日子型；<br>2.忙于管理，疏于技术；<br>3.长期在一个岗位，做着千篇一律的事情；</p><p>个人规划的意义就很明显了，之前<a href="http://jartto.wang/2018/04/29/audition-of-f2e-3/">前端反思录（三）—谈谈个人规划</a>有提到过，这里就不细说了。</p><div class="alert warning"><p>人变老了的感觉不是说我不想学习新东西，而是老东西我还消化不完。</p></div><h4 id="八、面试者反馈"><a href="#八、面试者反馈" class="headerlink" title="八、面试者反馈"></a>八、面试者反馈</h4><p>面试接近尾声的时候，作为尊重，这时候我都会去问这样一个问题：大概情况我都了解了，有没有你觉得自己擅长而又没被问到的东西？</p><p>每个人都会有自己的思维，甚至是偏见，所以面试的时候一定要去得到面试者的互动和反馈，从而映证自己的观点。报着一个人才都不放过的心态，去全方位了解面试者。</p><div class="alert info"><p>也许他所擅长的刚好是你的软肋呢？海纳百川，有容乃大。</p></div><h4 id="九、你有什么问题想问我？"><a href="#九、你有什么问题想问我？" class="headerlink" title="九、你有什么问题想问我？"></a>九、你有什么问题想问我？</h4><p>面试官一定要放低姿态，不要一副高高在上的样子，尤其是做技术的。如果觉得面试者稍微有些紧张，可以先聊点其他，如：所学专业，住在哪里，上下班时间之类无关痛痒的问题，缓解一下紧张气氛。</p><p>至于最后一个问题为什么要问：你有什么问题想问我？有以下几点理由：<br>1.确定面试反馈；<br>2.给面试者一个沟通的机会；<br>3.看看面试者对应试部门的了解或者是对公司的兴趣；</p><h4 id="十、定级"><a href="#十、定级" class="headerlink" title="十、定级"></a>十、定级</h4><p>技术名词部分，我做了打分处理，所以定级就很容易了。一般情况我会按照 5 分制来评估，具体的标准这里就不透露了。</p><p>当然，每个面试官都有自己的风格，也许完全和我这一套背道而驰。但是你要记住，套路是一致的，任何事物都会有一个评判标准。</p><div class="alert info"><p>我走过最长的路，就是你的套路！</p></div><h4 id="十一、文末彩蛋"><a href="#十一、文末彩蛋" class="headerlink" title="十一、文末彩蛋"></a>十一、文末彩蛋</h4><p>每个人都是天才，但是如果你以爬树的本领来判断一条鱼的能力，那它终其一生都会以为自己是个笨蛋。很有意思的一幅图，分享给大家。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/interview/store.jpg" alt="store"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一年陆陆续续都在面试各种不同程度的 Web 前端开发，总觉得现在前端氛围太过于浮躁，急于求成的人比比皆是。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="F2E" scheme="http://jartto.wang/tags/F2E/"/>
    
      <category term="前端" scheme="http://jartto.wang/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://jartto.wang/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>用 Python 爬取 2018 前端热点</title>
    <link href="http://jartto.wang/2018/12/31/f2e-2018/"/>
    <id>http://jartto.wang/2018/12/31/f2e-2018/</id>
    <published>2018-12-31T13:45:23.000Z</published>
    <updated>2019-01-01T08:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>下午无聊在刷公众号，突然发现一篇文章「前端一年精选好文，请打包带走」。在这个跨年的日子里，我本来应该开着电视，看着跨年晚会。<br><a id="more"></a></p><h4 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h4><p>反复琢磨，我还是很好奇：这一年，前端精选好文都有哪些？</p><div class="alert info"><p>翻了一下，有 130 多篇文章。</p></div><p>我又退缩了，看完猴年马月了，还是先收藏吧。于是关掉手机，准备放飞自我。突然，脑子里一闪，打包，带走？嗯，我有了一个大胆的想法。</p><h4 id="二、想法"><a href="#二、想法" class="headerlink" title="二、想法"></a>二、想法</h4><p>既然一时半会儿看不完，何不看一下趋势，把握一下今年前端界的热点。<br><div class="alert success"><p>说到热点，还有什么比热词分析更直接的了。对，我要生成词云。</p></div><br>大体思路如下：<br>1.首先，要拿到文章中的关键词，需要使用爬虫；<br>2.为了不那么枯燥，我决定采用图片蒙版来做背景；<br>3.统计关键词出现的频率，进行分词；<br>4.过滤掉干扰词汇；<br>5.生成图片；</p><div class="alert info"><p>热词集合的图片就是我最终的目标。</p></div><h4 id="三、使用爬虫"><a href="#三、使用爬虫" class="headerlink" title="三、使用爬虫"></a>三、使用爬虫</h4><p>1.没什么好选择的，直接使用 <code>Python</code> 插件 <code>BeautifulSoup</code>，我们先拿到 <code>Dom</code> 元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;body id="activity-detail"&gt;   </span></span><br><span class="line"><span class="string">&lt;div id="js_article" class="rich_media"&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="js_top_ad_area" class="top_banner"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="rich_media_inner"&gt;</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br><span class="line"><span class="comment"># 可以抓到 a 标签内容</span></span><br><span class="line"><span class="comment"># print(soup.find_all('a'))</span></span><br><span class="line"><span class="comment"># 也直接抓取所有文本</span></span><br><span class="line">print(soup.get_text())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件，逐行写入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'&#123;&#125;/result/word.txt'</span>.format(sys.path[<span class="number">0</span>]),<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.writelines(soup.get_text());</span><br></pre></td></tr></table></figure></p><p>为了确定内容是否都抓到了，我们先进行打印：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/2018f2e/word.png" alt="word"><br>看到这些，基本上我们需要的内容已经就绪了，继续下一步。</p><h4 id="四、生成图片"><a href="#四、生成图片" class="headerlink" title="四、生成图片"></a>四、生成图片</h4><p>1.使用 <code>Photoshop</code>，制作一个 <code>F2E</code> 字样的蒙版文件，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/2018f2e/mask.png" alt="mask"></p><p>2.使用 <code>Python</code> 插件 <code>jieba</code> 进行分词：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jieba_processing_txt</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> userdict_list:</span><br><span class="line">        jieba.add_word(word)</span><br><span class="line"></span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=<span class="literal">False</span>)</span><br><span class="line">    liststr = <span class="string">'/ '</span>.join(seg_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> io.open(stopwords_path, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_stop:</span><br><span class="line">        f_stop_text = f_stop.read()</span><br><span class="line">        f_stop_seg_list = f_stop_text.splitlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> myword <span class="keyword">in</span> liststr.split(<span class="string">'/'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (myword.strip() <span class="keyword">in</span> f_stop_seg_list) <span class="keyword">and</span> len(myword.strip()) &gt; <span class="number">1</span>:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    <span class="keyword">print</span> (mywordlist)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(mywordlist)</span><br></pre></td></tr></table></figure></p><p>分词后，我们打印 <code>mywordlist</code>：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/2018f2e/array.png" alt="array"></p><div class="alert success"><p>整齐的数组，没有半点瑕疵。确定过眼神，是我要的数组。</p></div><p>3.使用 <code>woldcloud</code> 来生成词云图片：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc = WordCloud(font_path=font_path, background_color=<span class="string">"white"</span>, max_words=<span class="number">2000</span>          mask=back_coloring,max_font_size=<span class="number">60</span>, random_state=<span class="number">42</span>, width=<span class="number">1000</span>, height=<span class="number">860</span>, margin=<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line">wc.generate(jieba_processing_txt(mytext))</span><br><span class="line">wc.to_file(path.join(d, imgname1))</span><br></pre></td></tr></table></figure></p><p>4.为了去除干扰，我们还需要过滤掉无用的关键词，如：发布，整理，功能，介绍，已经，使用，可以，电脑等等<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdict_list = [<span class="string">'我们'</span>, <span class="string">'什么'</span>, <span class="string">'发布'</span>, <span class="string">'整理'</span>, <span class="string">'功能'</span>, </span><br><span class="line"><span class="string">'介绍'</span>,<span class="string">'已经'</span>,<span class="string">'使用'</span>,<span class="string">'可以'</span>,<span class="string">'电脑'</span>,<span class="string">'尽快'</span>,<span class="string">'收藏'</span>,<span class="string">'最后'</span>,<span class="string">'公众'</span>,<span class="string">'支持'</span>,<span class="string">'微信'</span>,<span class="string">'需要'</span>,<span class="string">'这些'</span>]</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>这里不得不吐槽一下，乱起八糟的广告真的很多，感觉自己在抓 2018 年的广告热词。</p></div><p>到这里就结束了，感兴趣的童鞋可以看看 <a href="https://github.com/chenfengyanyu/my-web-accumulation/tree/master/python-dom" target="_blank" rel="noopener">Demo</a></p><h4 id="五、打包带走"><a href="#五、打包带走" class="headerlink" title="五、打包带走"></a>五、打包带走</h4><p>嗯，运行程序，我们最终得到了一张图片：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/2018f2e/tags.jpg" alt="tag"><br>大体一看，2018 年，前端还是那些老样子，不过我们可以了解到一些特点：<br>1.<code>JavaScript</code> 的文章还是很多；<br>2.<code>React</code> 和 <code>Vue</code> 仍然是主流；<br>3.<code>Flutter</code> 出现的晚，但是上升趋势不容小觑；<br>4.<code>Nodejs</code>，<code>Electron</code> 还是很受前端欢迎；<br>5.<code>TypeScript</code> 和 <code>GraphQL</code> 仍然有不少的讨论；<br>6.优化、构建、开源、线路图仍然是前端的关注点；<br>7.全栈仍是前端的追逐目标；<br>…</p><p>任务完成，收工。这里还是得特别感谢前端之巅小编辛苦的整理。这些前端精选资源，我真的打包带走了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下午无聊在刷公众号，突然发现一篇文章「前端一年精选好文，请打包带走」。在这个跨年的日子里，我本来应该开着电视，看着跨年晚会。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="F2E" scheme="http://jartto.wang/tags/F2E/"/>
    
      <category term="前端" scheme="http://jartto.wang/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="python" scheme="http://jartto.wang/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>HTML5之多线程（Web Worker）</title>
    <link href="http://jartto.wang/2018/12/26/web-worker/"/>
    <id>http://jartto.wang/2018/12/26/web-worker/</id>
    <published>2018-12-26T00:47:17.000Z</published>
    <updated>2019-06-11T08:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到 HTML5 总是让人津津乐道，太多的特性和有趣的 API 让人耳目一新。但是很多童鞋还停留在语义化的阶段，忽视了 HTML5 的强劲之处。<br><a id="more"></a><br>这节我们来探讨一下多线程 Web-Worker。</p><h4 id="一、明确-JavaScript-是单线程"><a href="#一、明确-JavaScript-是单线程" class="headerlink" title="一、明确 JavaScript 是单线程"></a>一、明确 JavaScript 是单线程</h4><div class="alert success"><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p></div><p>听起来有些匪夷所思，为什么不设计成多线程提高效率呢？我们可以假设一种场景：<br>假定 <code>JavaScript</code> 同时有两个线程，一个线程在某个 <code>DOM</code> 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><div class="alert info"><p>作为浏览器脚本语言，<code>JavaScript</code> 的主要用途是与用户互动，以及操作 <code>DOM</code>。</p></div><p>这决定了它只能是单线程，否则会带来很复杂的同步问题。为了避免复杂性，从一诞生，<code>JavaScript</code> 就是单线程，这已经成了这门语言的核心特征，估计短期内很难改变。</p><h4 id="二、新曙光：Web-Worker"><a href="#二、新曙光：Web-Worker" class="headerlink" title="二、新曙光：Web Worker"></a>二、新曙光：Web Worker</h4><p>单线程始终是一个痛点，为了利用多核 <code>CPU</code> 的计算能力，<code>HTML5</code> 提出 <code>Web Worker</code> 标准，允许 <code>JavaScript</code> 脚本创建多个线程。但是子线程完全受主线程控制，且不得操作 <code>DOM</code>。<br><div class="alert info"><p>所以，这个新标准并没有改变 <code>JavaScript</code> 单线程的本质。</p></div><br><code>Web Workers</code> 是现代浏览器提供的一个 <code>JavaScript</code> 多线程解决方案，我们可以找到很多使用场景：<br>1.我们可以用 <code>Web Worker</code> 做一些大计算量的操作；<br>2.可以实现轮询，改变某些状态；<br>3.页头消息状态更新，比如页头的消息个数通知；<br>4.高频用户交互，拼写检查，譬如：根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等<br>5.加密：加密有时候会非常地耗时，特别是如果当你需要经常加密很多数据的时候（比如，发往服务器前加密数据）。<br>6.预取数据：为了优化网站或者网络应用及提升数据加载时间，你可以使用 <code>Workers</code> 来提前加载部分数据以备不时之需。</p><p>加密是一个使用 <code>Web Worker</code> 的绝佳场景，因为它并不需要访问 <code>DOM</code> 或者利用其它魔法，它只是纯粹使用算法进行计算而已。随着大众对个人敏感数据的日益重视，信息安全和加密也成为重中之重。这可以从近期的 12306 用户数据泄露事件中体现出来。</p><div class="alert success"><p>一旦在 Worker 进行计算，它对于用户来说是无缝地且不会影响到用户体验。</p></div><h4 id="三、兼容性"><a href="#三、兼容性" class="headerlink" title="三、兼容性"></a>三、兼容性</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webworker/hack.png" alt="hack"></p><h4 id="四、基本概念"><a href="#四、基本概念" class="headerlink" title="四、基本概念"></a>四、基本概念</h4><p>1.首先记得去判断是否支持<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.Worker) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.创建一个新的 <code>worker</code> 很简单<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>postMessage() 方法和 onmessage 事件处理函数是 Workers 的黑魔法。</p></div><p>3.<code>postMessage</code> 用来发送消息，而 <code>onmessage</code> 用来监听消息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'src/worker.js'</span>);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.postMessage(<span class="string">'你好吗!'</span>);</span><br></pre></td></tr></table></figure></p><p>在主线程中使用时，<code>onmessage</code> 和 <code>postMessage()</code> 必须挂在 <code>worker</code> 对象上，而在 <code>worker</code> 中使用时不用这样做。原因是，在 <code>worker</code> 内部，<code>worker</code> 是有效的全局作用域。</p><p>4.异常处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>5.终止 <code>worker</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p><code>worker</code> 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p></div><p>6.在 <code>worker</code> 线程中，<code>workers</code> 也可以调用自己的 <code>close</code>  方法进行关闭：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure></p><h4 id="五、快速开始"><a href="#五、快速开始" class="headerlink" title="五、快速开始"></a>五、快速开始</h4><p>为了快速掌握，我们来做一个小例子：项目结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">└── src</span><br><span class="line">    ├── main.js</span><br><span class="line">    └── worker.js</span><br></pre></td></tr></table></figure></p><p>Html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Work Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span> Hello Jartto! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>main.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'src/worker.js'</span>);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> message = e.data;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[From Worker]: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.postMessage(<span class="string">'写的真好!'</span>);</span><br></pre></td></tr></table></figure></p><p>Work.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> message = e.data;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[From Main]: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span>(message.indexOf(<span class="string">'好'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    postMessage(<span class="string">'谢谢支持'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>代码很简单，主线程发送：「写的真好！」<br>web worker 收到消息，发现内容中含有「好」字，回传给主线程：「谢谢支持」</p><h4 id="六、局限性"><a href="#六、局限性" class="headerlink" title="六、局限性"></a>六、局限性</h4><p>1.在 <code>worker</code> 内，不能直接操作 <code>DOM</code> 节点，也不能使用 <code>window</code> 对象的默认方法和属性。然而我们可以使用大量<code>window</code> 对象之下的东西，包括 <code>WebSockets</code>，<code>IndexedDB</code> 以及 <code>FireFox OS</code> 专用的 <code>Data Store API</code> 等数据存储机制。</p><p>这里举个例子，我们修改 <code>main.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'src/worker.js'</span>);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> message = e.data;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[From Worker]: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">+ worker.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">+   <span class="built_in">console</span>.log(error);</span><br><span class="line">+   worker.terminate();</span><br><span class="line">+ &#125;;</span><br><span class="line"></span><br><span class="line">worker.postMessage(<span class="string">'写的真好!'</span>);</span><br></pre></td></tr></table></figure></p><p>再来修改 <code>work.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ alert(<span class="string">'jartto'</span>);</span><br><span class="line">onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> message = e.data;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[From Main]: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span>(message.indexOf(<span class="string">'好'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    postMessage(<span class="string">'谢谢支持'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这时候运行就会报出：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webworker/error.png" alt="error"></p><p>这是因为：<code>worker.js</code> 执行的上下文，与主页面 <code>HTML</code> 执行时的上下文并不相同，最顶层的对象并不是 <code>Window</code>，<code>woker.js</code> 执行的全局上下文，而是 <code>WorkerGlobalScope</code>，<a href="#">下文</a>我们具体说明。</p><p>2.<code>workers</code> 和主线程间的数据传递通过这样的消息机制进行：双方都使用 <code>postMessage()</code> 方法发送各自的消息，使用<code>onmessage</code> 事件处理函数来响应消息（消息被包含在 <code>Message</code> 事件的 <code>data</code> 属性中）。<br><div class="alert info"><p>这个过程中数据并不是被共享而是被复制。</p></div></p><p>3.同源限制<br>分配给 <code>Worker</code> 线程运行的脚本文件，必须与主线程的脚本文件同源。</p><p>4.文件限制<br><code>Worker</code> 线程无法读取本地文件，即不能打开本机的文件系统<code>（file://）</code>，它所加载的脚本，必须来自服务器。</p><p>5.不允许本地文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SecurityError: Failed to create a worker: </span><br><span class="line">script at &apos;(path)/worker.js&apos; </span><br><span class="line">cannot be accessed from origin &apos;null&apos;.</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>Chrome doesn’t let you load web workers when running scripts from a local file.</p></div><p>那如何解决呢？我们可以启动一个本地服务器，建议使用 <code>http-server</code>，简单易用。</p><p>6.内容安全策略<br>有别于创建它的 <code>document</code> 对象，<code>worker</code> 有它自己的执行上下文。因此普遍来说，<code>worker</code> 并不受限于创建它的<code>document</code>（或者父级 <code>worker</code> ）的内容安全策略。</p><p>我们来举个例子，假设一个 <code>document</code> 有如下头部声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &apos;self&apos;</span><br></pre></td></tr></table></figure></p><p>这个声明有一部分作用在于，禁止它内部包含的脚本代码使用 <code>eval()</code> 方法。然而，如果脚本代码创建了一个 <code>worker</code>，在 <code>worker</code> 上下文中执行的代码却是可以使用 <code>eval()</code> 的。</p><div class="alert info"><p>为了给 worker 指定 CSP，必须为发送 worker 代码的请求本身加上一个 CSP。</p></div><p>关于 <a href="http://jartto.wang/2018/11/12/outline-of-CSP/">CSP（Content security policy 内容安全策略）</a>，可以看我之前的这篇文章。</p><p>有一个例外情况，即 <code>worker</code> 脚本的源如果是一个全局性的唯一的标识符（例如，它的 <code>URL</code> 指定了数据模式或者 <code>blob</code>），<code>worker</code>则会继承创建它的 <code>document</code> 或者 <code>worker</code> 的 <code>CSP</code>。</p><h4 id="七、扩展：WorkerGlobalScope"><a href="#七、扩展：WorkerGlobalScope" class="headerlink" title="七、扩展：WorkerGlobalScope"></a>七、扩展：WorkerGlobalScope</h4><p>关于 ，我们可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope" target="_blank" rel="noopener"><code>MDN</code></a> 上面找到文档：<br>1.<code>self</code>：<br>我们可以使用 <code>WorkerGlobalScope</code> 的 <code>self</code> 属性来获取这个对象本身的引用。</p><p>2.<code>location</code>：<br><code>location</code> 属性返回当线程被创建出来的时候与之关联的 <code>WorkerLocation</code> 对象，它表示用于初始化这个工作线程的脚步资源的绝对 <code>URL</code>，即使页面被多次重定向后，这个 <code>URL</code> 资源位置也不会改变。</p><p>3.<code>close</code>：<br>关闭当前线程，与 <code>terminate</code> 作用类似。</p><p>4.<code>caches</code>：<br>当前上下文得 <code>CacheStorage</code>，确保离线可用，同时可以自定义请求的响应。</p><p>5.<code>console</code>：<br>支持 <code>console</code> 语法。</p><p>6.<code>importScripts</code><br>我们可以通过 <code>importScripts()</code> 方法通过 <code>url</code> 在 <code>worker</code> 中加载库函数。</p><p>7.<code>XMLHttpRequest</code><br>有了它，才能发出 <code>Ajax</code> 请求。</p><p>8.可以使用：</p><ul><li><code>setTimeout/setInterval</code></li><li><code>addEventListener/postMessage</code></li></ul><p>还有很多 <code>API</code> 可以使用，这里就不一一举例了。</p><h4 id="八、异常处理"><a href="#八、异常处理" class="headerlink" title="八、异常处理"></a>八、异常处理</h4><p>当 <code>worker</code> 出现运行中错误时，它的 <code>onerror</code> 事件处理函数会被调用。它会收到一个扩展了 <code>ErrorEvent</code> 接口的名为 <code>error</code> 的事件。该事件不会冒泡并且可以被取消。</p><div class="alert info"><p>为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。</p></div><p>错误事件我们常用如下这三个关键信息：</p><ul><li><code>Message</code>：可读性良好的错误消息；</li><li><code>Filename</code>：发生错误的脚本文件名；</li><li><code>Lineno</code>：发生错误时所在脚本文件的行号；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h4><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">MDN</a><br><a href="http://jixianqianduan.com/frontend-javascript/2014/06/05/webworker-serviceworker.html" target="_blank" rel="noopener">从webWorker到serviceWorker</a><br><a href="https://www.cnblogs.com/giggle/p/5350288.html" target="_blank" rel="noopener">浅谈webWorker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 HTML5 总是让人津津乐道，太多的特性和有趣的 API 让人耳目一新。但是很多童鞋还停留在语义化的阶段，忽视了 HTML5 的强劲之处。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="HTML5" scheme="http://jartto.wang/tags/HTML5/"/>
    
      <category term="worker" scheme="http://jartto.wang/tags/worker/"/>
    
  </entry>
  
  <entry>
    <title>不会管理的程序员，永远只是一个大兵</title>
    <link href="http://jartto.wang/2018/12/16/manage/"/>
    <id>http://jartto.wang/2018/12/16/manage/</id>
    <published>2018-12-16T11:22:42.000Z</published>
    <updated>2018-12-25T01:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多童鞋都玩王者荣耀，你肯定知道大兵和英雄的区别。这里声明一下：本文的英雄都是狭义上的英雄，特指游戏中的角色。<br><a id="more"></a><br>当然，我也不会和你抬杠，在游戏里大兵也是决定成败的关键。但是请别忽略，如果没有英雄，大兵可能都走不到敌方阵营。</p><div class="alert success"><p>所以，英雄的重要性可想而知，领导恰恰是这样一个角色。</p></div><h4 id="一、题外话"><a href="#一、题外话" class="headerlink" title="一、题外话"></a>一、题外话</h4><p>其实你不用惊讶，在很多招聘网站，我们都能看到如下的一些团队介绍：<br>1.领导nice，地铁周边，扁平管理，不打卡，公司氛围好；<br>2.带薪年假，扁平管理，领导nice，免费零食；<br>3.免费零食，美女如云，年度旅游，股票期权，领导nice，地铁周边；</p><p>圈一下关键字：领导 Nice。有没有想过，领导 Nice 为什么都会成为一个关键点，几乎所有企业都会去强调这件事情。</p><div class="alert info"><p>说了这么多，其实只是想突出一下管理的重要性。</p></div><p>下面我们就程序员这个群体来说一下我粗浅的管理经验。</p><h4 id="二、如果你是领导"><a href="#二、如果你是领导" class="headerlink" title="二、如果你是领导"></a>二、如果你是领导</h4><p>1.请充分信任你的下属，认可他们的能力。让擅长的人做擅长的事，物尽其用，人尽其才。<br>2.学会放权，让下属去独立完成工作，领导给予支持。当然，别忘了在适当的时机进行点拨。<br>3.不要吝惜赞美，任何人都喜欢被夸奖。<br>4.经常沟通，了解下属想法，而不是只会派活，不管下属死活。这样的领导很难得到下属的拥护和爱戴。<br>5.不用向下属证明自己的能力，反之，下属能力强也是好事，领导会省很多心；<br>6.学会换位思考，多考虑下属的需求；<br>7.替下属承受伤害，顶住压力，而不是抱怨苛责；<br>8.技术管理需要有更广阔的视野，捕捉技术趋势，促进下属成长；<br>9.多去推动一些事情，做好部门协调工作；</p><div class="alert warning"><p>会用人是领导的必修课，反之只会增加内耗。</p></div><h4 id="三、如果你是下属"><a href="#三、如果你是下属" class="headerlink" title="三、如果你是下属"></a>三、如果你是下属</h4><p>1.多想想领导想要什么？给予领导支持，把领导送上去，你自然而然的就晋级了；<br>2.对于任何事情都要提前暴露风险，而不是临时提出，这样只会打破彼此的信任；<br>3.替领导去执行，把事情做好了才能得到赏识；<br>4.对于领导的小错误不要较真，死脑筋只会一直被穿小鞋；<br>5.不要挑衅领导，让其下不了台。<br>6.最重要的一点，干活了一定要让领导知道，否则只能是别人的垫脚石。譬如，加班了晒一下美丽的夜景，这就很机智了。<br>7.坚持学习，不思进取的人是没有前途的。</p><div class="alert warning"><p>很简单，选对方向，努力去做。</p></div><h4 id="四、马斯洛需求层次理论"><a href="#四、马斯洛需求层次理论" class="headerlink" title="四、马斯洛需求层次理论"></a>四、马斯洛需求层次理论</h4><p>正如马斯洛需求层次理论所说，人的需求像阶梯一样从低到高按层次分为五种，分别是：生理需求、安全需求、社交需求、尊重需求和自我实现需求。</p><p>当员工的生理需求、安全需求以及社会需求都满足了的时候，就会渴望被尊重和追求自我实现。所以，真正的理解下属需求不是一件容易的事情，不同阶段的人会有不同阶段的需求。</p><div class="alert success"><p>不会用人的领导只能是一个光杆司令。不会管理的程序员，永远只是一个大兵。</p></div><p>技术之余，我们应该多去了解一些管理理念，利人利己。</p><h4 id="五、文末，送上两个小故事："><a href="#五、文末，送上两个小故事：" class="headerlink" title="五、文末，送上两个小故事："></a>五、文末，送上两个小故事：</h4><p>1.农民正在抢收庄稼，遇到领导视察<br>问：房子破破烂烂，为什么不去修修？<br>答：没钱，没人，没时间。<br>问：那不行啊，要不断的修。<br>答：那庄稼怎么办？<br>…</p><p>2.漆黑的夜晚，看见有人在灯下晃悠，<br>问：你在干什么？<br>答：我在找东西。<br>问：你的东西丢在这了吗？<br>答：没有。<br>问：那为什么在这里找？<br>答：因为这里亮！<br>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多童鞋都玩王者荣耀，你肯定知道大兵和英雄的区别。这里声明一下：本文的英雄都是狭义上的英雄，特指游戏中的角色。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术杂谈" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="程序员" scheme="http://jartto.wang/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="管理" scheme="http://jartto.wang/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂 Git-Rebase</title>
    <link href="http://jartto.wang/2018/12/11/git-rebase/"/>
    <id>http://jartto.wang/2018/12/11/git-rebase/</id>
    <published>2018-12-11T14:07:00.000Z</published>
    <updated>2018-12-15T09:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Git 已经好几年了，却始终只是熟悉一些常用的操作。对于 Git Rebase 却很少用到，直到这一次，不得不用。<br><a id="more"></a></p><h4 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h4><p>上线构建的过程中扫了一眼代码变更，突然发现，<code>commit</code> 提交竟然多达 <code>62</code> 次。我们来看看都提交了什么东西：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/commit1.png" alt="commit1"></p><p>这里我们先不说 <code>git</code> <a href="http://jartto.wang/2018/07/08/git-commit/">提交规范</a>，就单纯这么多次无用的 <code>commit</code> 就很让人不舒服。可能很多人觉得无所谓，无非是多了一些提交纪录。</p><div class="alert danger"><p>然而，并非如此，你可能听过破窗效应，编程也是如此！</p></div><h4 id="二、导致问题"><a href="#二、导致问题" class="headerlink" title="二、导致问题"></a>二、导致问题</h4><p>1.不利于代码 <code>review</code><br>设想一下，你要做 <code>code review</code> ，结果一个很小的功能，提交了 <code>60</code> 多次，会不会有一些崩溃？</p><p>2.会造成分支污染<br>你的项目充满了无用的 <code>commit</code> 纪录，如果有一天线上出现了紧急问题，你需要回滚代码，却发现海量的 <code>commit</code> 需要一条条来看。</p><div class="alert info"><p>遵循项目规范才能提高团队协作效率，而不是随心所欲。</p></div><h4 id="三、Rebase-场景一：如何合并多次提交纪录？"><a href="#三、Rebase-场景一：如何合并多次提交纪录？" class="headerlink" title="三、Rebase 场景一：如何合并多次提交纪录？"></a>三、Rebase 场景一：如何合并多次提交纪录？</h4><div class="alert success"><p>基于上面所说问题，我们不难想到：每一次功能开发， 对多个 commit 进行合并处理。</p></div><p>这时候就需要用到 <code>git rebase</code> 了。这个命令没有太难，不常用可能源于不熟悉，所以我们来通过示例学习一下。</p><p>1.我们来合并最近的 4 次提交纪录，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure></p><p>2.这时候，会自动进入 <code>vi</code> 编辑模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">s 8f33126c feat: add test2.js</span><br><span class="line"></span><br><span class="line"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>有几个命令需要注意一下：</p><ul><li>p, pick = use commit</li><li>r, reword = use commit, but edit the commit message</li><li>e, edit = use commit, but stop for amending</li><li>s, squash = use commit, but meld into previous commit</li><li>f, fixup = like “squash”, but discard this commit’s log message</li><li>x, exec = run command (the rest of the line) using shell</li><li>d, drop = remove commit</li></ul><p>按照如上命令来修改你的提交纪录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s cacc52da add: qrcode</span><br><span class="line">s f072ef48 update: indexeddb hack</span><br><span class="line">s 4e84901a feat: add indexedDB floder</span><br><span class="line">p 8f33126c feat: add test2.js</span><br></pre></td></tr></table></figure></p><p>3.如果保存的时候，你碰到了这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot &apos;squash&apos; without a previous commit</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p></div><p>4.如果你异常退出了 <code>vi</code> 窗口，不要紧张：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --edit-todo</span><br></pre></td></tr></table></figure></p><p>这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></p><p>5.查看结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>三次提交合并成了一次，减少了无用的提交信息。</p></div><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/commit2.png" alt="commit2"></p><h4 id="四、Rebase-场景二：分支合并"><a href="#四、Rebase-场景二：分支合并" class="headerlink" title="四、Rebase 场景二：分支合并"></a>四、Rebase 场景二：分支合并</h4><p>1.我们先从 <code>master</code> 分支切出一个 <code>dev</code> 分支，进行开发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(master) git checkout -b feature1</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git1.png" alt="git1"><br>2.这时候，你的同事完成了一次 <code>hotfix</code>，并合并入了 <code>master</code> 分支，此时 <code>master</code> 已经领先于你的 <code>feature1</code> 分支了：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git2.png" alt="git2"><br>3.恰巧，我们想要同步 <code>master</code> 分支的改动，首先想到了 <code>merge</code>，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git merge master</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git3.png" alt="git3"><br>图中绿色的点就是我们合并之后的结果，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git log</span><br></pre></td></tr></table></figure></p><p>就会在记录里发现一些 <code>merge</code> 的信息，但是我们觉得这样污染了 <code>commit</code> 记录，想要保持一份干净的 <code>commit</code>，怎么办呢？这时候，<code>git rebase</code> 就派上用场了。</p><p>4.让我们来试试 <code>git rebase</code> ，先回退到同事 <code>hotfix</code> 后合并 <code>master</code> 的步骤：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git4.png" alt="git4"><br>5.使用 <code>rebase</code> 后来看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:(feature1) git rebase master</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>这里补充一点：<code>rebase</code> 做了什么操作呢？</p></div><p>首先，<code>git</code> 会把 <code>feature1</code> 分支里面的每个 <code>commit</code> 取消掉；<br>其次，把上面的操作临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下；<br>然后，把 <code>feature1</code> 分支更新到最新的 <code>master</code> 分支；<br>最后，把上面保存的 <code>patch</code> 文件应用到 <code>feature1</code> 分支上；</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git5.png" alt="git5"></p><p>从 <code>commit</code> 记录我们可以看出来，<code>feature1</code> 分支是基于 <code>hotfix</code> 合并后的 <code>master</code> ，自然而然的成为了最领先的分支，而且没有 <code>merge</code> 的 <code>commit</code> 记录，是不是感觉很舒服了。</p><p>6.在 <code>rebase</code> 的过程中，也许会出现冲突 <code>conflict</code>。在这种情况，<code>git</code> 会停止 <code>rebase</code> 并会让你去解决冲突。在解决完冲突后，用 <code>git add</code> 命令去更新这些内容。</p><div class="alert warning"><p>注意，你无需执行 git-commit，只要执行 continue</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>这样 <code>git</code> 会继续应用余下的 <code>patch</code> 补丁文件。</p><p>7.在任何时候，我们都可以用 <code>--abort</code> 参数来终止 <code>rebase</code> 的行动，并且分支会回到 <code>rebase</code> 开始前的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase —abort</span><br></pre></td></tr></table></figure></p><h4 id="五、更多-Rebase-的使用场景"><a href="#五、更多-Rebase-的使用场景" class="headerlink" title="五、更多 Rebase 的使用场景"></a>五、更多 Rebase 的使用场景</h4><div class="alert info"><p>git-rebase 存在的价值是：对一个分支做「变基」操作。</p></div><p>1.当我们在一个过时的分支上面开发的时候，执行 <code>rebase</code> 以此同步 <code>master</code> 分支最新变动；<br>2.假如我们要启动一个放置了很久的并行工作，现在有时间来继续这件事情，很显然这个分支已经落后了。这时候需要在最新的基准上面开始工作，所以 <code>rebase</code> 是最合适的选择。</p><h4 id="六、为什么会是危险操作？"><a href="#六、为什么会是危险操作？" class="headerlink" title="六、为什么会是危险操作？"></a>六、为什么会是危险操作？</h4><p>根据上文来看，<code>git-rebase</code> 很完美，解决了我们的两个问题：<br>1.合并 <code>commit</code> 记录，保持分支整洁；<br>2.相比 <code>merge</code> 来说会减少分支合并的记录；</p><p>如果你提交了代码到远程，提交前是这样的：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git2.png" alt="git2"></p><p>提交后远程分支变成了这样：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git5.png" alt="git5"></p><p>而此时你的同事也在 <code>feature1</code> 上开发，他的分支依然还是：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git6.png" alt="git6"></p><p>那么当他 <code>pull</code> 远程 <code>master</code> 的时候，就会有丢失提交纪录。这就是为什么我们经常听到有人说 <code>git rebase</code> 是一个危险命令，因为它改变了历史，我们应该谨慎使用。</p><div class="alert info"><p>除非你可以肯定该 <code>feature1</code> 分支只有你自己使用，否则请谨慎操作。</p></div><p>结论：只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git-rebase</code>来操作。</p><h4 id="七、参考："><a href="#七、参考：" class="headerlink" title="七、参考："></a>七、参考：</h4><p><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">rebase</a><br><a href="https://cloud.tencent.com/developer/news/231201" target="_blank" rel="noopener">git-rebase 使用总结</a><br><a href="https://blog.csdn.net/gtlbtnq9mr3/article/details/80222523" target="_blank" rel="noopener">git 中的 rebase操作</a><br><a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank" rel="noopener">git-rebase vs git-merge 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Git 已经好几年了，却始终只是熟悉一些常用的操作。对于 Git Rebase 却很少用到，直到这一次，不得不用。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="git" scheme="http://jartto.wang/tags/git/"/>
    
      <category term="rebase" scheme="http://jartto.wang/tags/rebase/"/>
    
  </entry>
  
</feed>
