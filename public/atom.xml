<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jartto&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/ee1200dca3e1b26043739f4bd08bfc12</icon>
  <subtitle>Jartto 个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jartto.wang/"/>
  <updated>2020-05-14T00:20:02.918Z</updated>
  <id>http://jartto.wang/</id>
  
  <author>
    <name>Jartto</name>
    <email>jartto@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebP 方案分析与实践</title>
    <link href="http://jartto.wang/2020/05/02/webp-practice/"/>
    <id>http://jartto.wang/2020/05/02/webp-practice/</id>
    <published>2020-05-02T10:22:43.000Z</published>
    <updated>2020-05-14T00:20:02.918Z</updated>
    
    <content type="html"><![CDATA[<p>对于网站来说，图片始终扮演着重要角色。图片大小直接影响网站速度、流量、运营成本以及用户体验。因此，减少图片大小成为网站优化最重要的一个环节。<br><a id="more"></a><br>如果你对优化还不甚了解，推荐阅读如下文章：<br>1.<a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a><br>2.<a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化工具</a><br>3.<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">CSS 渲染原理以及优化策略</a><br>4.<a href="http://jartto.wang/2020/03/15/about-web-fmp/">网站性能指标 - FMP</a><br>5.<a href="http://jartto.wang/2020/03/29/web-tti/">聚焦 Web 性能指标 TTI</a><br>6.<a href="http://jartto.wang/2020/04/05/about-wrk/">Web「性能测试」知多少？</a></p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>当我们在做网站性能优化的时候，减少图片大小，意味着减少了网络传输，提升了网站加载速度，而这部分也是性价比最高的。</p><p>我们可以通过压缩图片来减少体积，但压缩比例一直是前端开发和设计师争执的焦点。压缩比例大的话，可以有效减少图片体积，对页面加载有利，但是却损失了像素，是设计师无法容忍的。</p><p>在这种矛盾的场景下，我们既要最大程度的压缩图片又要保持足够的清晰，<code>WebP</code> 便应运而生。<br><div class="alert danger"><p>值得注意的是：WebP 并不是新技术，而是受限于兼容性而未全面普及。</p></div></p><h4 id="二、目标与意义"><a href="#二、目标与意义" class="headerlink" title="二、目标与意义"></a>二、目标与意义</h4><p>1.时间成本<br>我们先来看一组数据对比图，如果你做过 <code>Gif</code> 动图，你肯定知道下面这样的处理意义有多大：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/sample.png" alt="WebP 时间对比"></p><div class="alert success"><p>在肉眼无法识别差异的前提下，图片大小减少了 88%。</p></div><p>2.带宽成本</p><ul><li><code>YouTube</code> 的视频略缩图采用 <code>WebP</code> 格式后，网页加载速度提升了 <code>10%</code>；</li><li>谷歌的 <code>Chrome</code> 网上应用商店采用 <code>WebP</code> 格式图片后，每天可以节省几 <code>TB</code> 的带宽，页面平均加载时间大约减少 <code>1/3</code>；</li><li><code>Google+</code> 移动应用采用 <code>WebP</code> 图片格式后，每天节省了 <code>50TB</code> 数据存储空间。</li></ul><p>目前 <code>Google</code>、<code>Facebook</code>、阿里、京东的等国内外互联网公司广泛应用了 <code>WebP</code>，超过 <code>70%</code> 的浏览器已经支持 <code>WebP</code>。</p><h4 id="三、什么是-WebP-？"><a href="#三、什么是-WebP-？" class="headerlink" title="三、什么是 WebP ？"></a>三、什么是 WebP ？</h4><div class="alert info"><p>WebP 格式，谷歌开发的一种旨在加快图片加载速度的图片格式。</p></div><p>优势在于它具有<strong>更优的图像数据压缩算法</strong>，在拥有肉眼无法识别差异的图像质量前提下，带来<strong>更小的图片体积</strong>，同时具备了无损和有损的压缩模式、<code>Alpha</code> 透明以及动画的特性，在 <code>JPEG</code> 和 <code>PNG</code> 上的转化效果都非常优秀、稳定和统一。</p><p>在尝试一些技术前，我们必须要充分了解他的<strong>兼容性</strong>，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/caniuse.png" alt="WebP 兼容性"></p><p>可以看出来，绝大多数浏览器已经有了较好的支持。当然，除了 <code>Safari</code> 和 <code>IE</code>！我们来看看浏览器市场占有率吧：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/chrome.png" alt="浏览器市场占有率"></p><div class="alert warning"><p>Safari 和 Foxmail 也在进行支持 WebP 的测试。</p></div><h4 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h4><p><code>WebP</code> 看起来不错，那么它究竟适合什么样的场景呢？不着急，我们先来看下面的图例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/sence.png" alt="WebP 使用场景"></p><p>从上面我们可以看出，适合 <code>WebP</code> 场景的站点不外乎如下几种场景：<br>1.<strong>网站图片比重大</strong><br>如果你的网站 <code>80%</code> 甚至更多依赖图片资源，那么请使用 <code>WebP</code>，资源成本可以较少 <code>50%</code> 以上。</p><p>2.<strong>细节要求不高</strong><br>图片起到占位目的，不需要毛孔级别，那么请大胆使用！</p><p>3.<strong>流量运营推广</strong><br>运营推广都是抢占先机，我们不但要和竞品比拼用户，更要快速响应，提高转化率。</p><p>4.<strong>视频首图</strong><br>视频内容形式的网站，资源存储必是一大难题。如何做到稳准狠，速度必不可少，大量的视频占位图也便成为了重中之重。</p><h4 id="五、实践方案"><a href="#五、实践方案" class="headerlink" title="五、实践方案"></a>五、实践方案</h4><p>相信到这里，你已经对 <code>WebP</code> 有了足够的了解，快来看看实际项目中我们是如何使用的吧～</p><p><strong>方式一：<code>HTML5 Picture</code></strong><br><code>Picture</code> 元素允许我们在不同的设备上显示不同的图片，一般用于响应式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span> <span class="attr">srcset</span>=<span class="string">"images/jartto.webp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/jartto.jpg"</span> <span class="attr">alt</span>=<span class="string">“jartto’s</span> <span class="attr">demo</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>Picture</code> 算是最简单易行的方案了，但是需要注意以下两点：<br>1.兼容性，<code>IE</code> 不支持，可以查看<a href="https://caniuse.com/#search=picture" target="_blank" rel="noopener">Picutre Element</a>；<br>2.老项目迁移成本较大，需要改动每一个 <code>IMG</code> 资源，请尽可能封装成组件；</p><p><strong>方式二：<code>Webpack + Nginx</code></strong><br>此方案在 <code>Webpack</code> 打包过程生成了 <code>.webp</code> 格式的图片，通过 <code>Nginx</code> 检测浏览器 <code>Accept</code> 是否包含 <code>image/webp</code> 而进行动态转发。<br><div class="alert info"><p>完整格式：accept: image/webp,image/apng,image/<em>,</em>/*;q=0.8</p></div></p><p>1.项目引入 <code>Webpack</code> 插件 <code>imagemin-webp-webpack-plugin</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const ImageminWebpWebpackPlugin = require(&apos;imagemin-webp-webpack-plugin’);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">            new ImageminWebpWebpackPlugin(&#123;</span><br><span class="line">                config: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.(jpe?g|png)$/,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            quality: 60,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                overrideExtension: false,</span><br><span class="line">                detailedLogs: true,</span><br><span class="line">                strict: false</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><p>2.<code>Nginx</code> 配置<br>检测 <code>Accept</code> 头中是否含有 <code>WebP</code> 字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_accept</span> <span class="variable">$webp_suffix</span> &#123;</span><br><span class="line">    default   <span class="string">""</span>;</span><br><span class="line">    <span class="string">"~*webp"</span>  <span class="string">".webp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果浏览器支持 <code>WebP</code> 格式，那么我们就将 <code>.png</code> 或者 <code>.jpg</code> 格式图片转发到 <code>.webp</code> 格式下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location  ~* ^/_nuxt/img/(.+\.png|jpe?g)$ &#123;</span><br><span class="line">    rewrite ^/_nuxt/img/(.+\.png|jpe?g)$ /<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    root /apps/srv/instance/<span class="built_in">test</span>-webp.jartto.wang/.nuxt/dist/client/img/;</span><br><span class="line">    add_header Vary Accept;</span><br><span class="line">    try_files <span class="variable">$uri</span><span class="variable">$webp_suffix</span> <span class="variable">$uri</span> =404;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置完 <code>Nginx</code> 转发规则后，记得 <code>Reload Nginx</code>。刷新浏览器，这时候浏览器中的图片 <code>Type</code> 类型已经变成了 <code>WebP</code> 格式。</p><p><strong>方式三：服务端 <code>Nginx PageSpeed</code> 模块</strong><br><code>Google</code> 开发的 <code>PageSpeed</code> 模块有一个功能，会自动将图像转换成 <code>WebP</code> 格式或者是浏览器所支持的其它格式。<br><div class="alert info"><p>安装 Nginx 模块请查看文档：<a href="https://www.modpagespeed.com/doc/build_ngx_pagespeed_from_source#dependencies" target="_blank" rel="noopener">Build ngx_pagespeed From Source</a></p></div></p><p>安装成功之后，需要在 <code>Nginx Config</code> 中添加如下内容：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pagespeed</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">pagespeed</span> FileCachePath <span class="string">"/var/cache/ngx_pagespeed/"</span>;</span><br><span class="line"><span class="comment"># pagespeed RewriteLevel OptimizeForBandwidth;</span></span><br><span class="line"><span class="attribute">pagespeed</span> XHeaderValue <span class="string">"Powered By Jartto"</span>;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_gif_to_png;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_png_to_jpeg;</span><br><span class="line"><span class="attribute">pagespeed</span> EnableFilters convert_jpeg_to_webp;</span><br><span class="line"><span class="attribute">pagespeed</span> ImageRecompressionQuality <span class="number">10</span>;</span><br><span class="line"><span class="comment"># pagespeed EnableFilters convert_jpeg_to_progressive;</span></span><br><span class="line"><span class="comment"># pagespeed EnableFilters inline_images;</span></span><br><span class="line"></span><br><span class="line">location ~ "\.pagespeed\.([a-z]\.)?[a-z]&#123;2&#125;\.[^.]&#123;10&#125;\.[^.]+" &#123;</span><br><span class="line"><span class="attribute">add_header</span> <span class="string">""</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ "^/pagespeed_static/"</span> &#123; &#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ "^/ngx_pagespeed_beacon$"</span> &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>看起来此方案是最佳选择，既没有前端代码侵入，也不需要各种嗅探，服务端一个模块就搞定了。需要注意的是，当我们想受便利的同时，<strong>一定要明确具体的原理，多维度思考</strong>。</p><p>既然在服务端完成 <code>WebP</code> 格式的转化，那么一定要注意此操作对服务器的性能损耗。我们不妨试一下，通过 <code>Wrk</code> 对服务器施压，看一下服务器的并发性能。</p><p>具体的压测过程就不细说了，感兴趣的童鞋可以查看：<a href="http://jartto.wang/2020/04/05/about-wrk/">Web 性能测试</a>。我们直接上结论：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/nginx.png" alt="Nginx CPU"></p><p><strong>相比转码，相同 <code>QPS</code> 下 <code>Nginx</code> 对 <code>CPU</code> 的使用上升了 <code>70%</code>，页面提升时间在毫秒量级，性价比不高</strong>。</p><p><strong>方式四：<code>Nginx + Lua（OpenResty）</code></strong><br>先来科普一下：<code>OpenResty</code> 是一个强大的 <code>Web</code> 应用服务器，<code>Web</code> 开发人员可以使用 <code>Lua</code> 脚本语言调动 <code>Nginx</code> 支持的各种 <code>C</code> 以及 <code>Lua</code> 模块，更主要的是在性能方面，<code>OpenResty</code> 可以快速构造出足以胜任 <code>10K</code> 以上并发连接响应的超高性能 <code>Web</code> 应用系统。</p><p><code>Lua</code> 是一种轻量小巧的脚本语言，用标准 <code>C</code> 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>1.编写 <code>Lua</code> 脚本</strong><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">file_exists</span><span class="params">(name)</span></span></span><br><span class="line">   <span class="keyword">local</span> f=<span class="built_in">io</span>.<span class="built_in">open</span>(name,<span class="string">"r"</span>)</span><br><span class="line">   <span class="keyword">if</span> f~=<span class="literal">nil</span> <span class="keyword">then</span> <span class="built_in">io</span>.<span class="built_in">close</span>(f) <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> newFile = ngx.var.request_filename;</span><br><span class="line"><span class="keyword">local</span> originalFile = newFile:<span class="built_in">sub</span>(<span class="number">1</span>, #newFile - <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> file_exists(originalFile) <span class="keyword">then</span></span><br><span class="line">  ngx.<span class="built_in">exit</span>(<span class="number">404</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">"cwebp -q 75 "</span> .. originalFile  .. <span class="string">" -o "</span> .. newFile);</span><br><span class="line"><span class="keyword">if</span> file_exists(newFile) <span class="keyword">then</span></span><br><span class="line">    ngx.exec(ngx.var.uri)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>不考虑学习成本的话，<code>Nginx + Lua</code> 将会是最好的选择。</p><p><strong>2.配置 <code>Nginx</code> 文件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http 中加入，lua 脚本的搜索路径</span></span><br><span class="line">lua_package_path <span class="string">"/usr/local/openresty/nginx/conf/jartto/?.lua;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># server 中配置 location</span></span><br><span class="line">location /images &#123;</span><br><span class="line">  expires 365d;</span><br><span class="line">  <span class="comment"># 如果不存在，则通过 @webp 进行内部重定向</span></span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @webp; </span><br><span class="line">&#125;</span><br><span class="line">location @webp&#123;</span><br><span class="line">  <span class="comment"># 图片访问地址</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$uri</span> ~ <span class="string">"/([a-zA-Z0-9-_]+)\.(png|jpg|gif)\.webp"</span>) &#123; </span><br><span class="line">    <span class="comment"># 查找执行的 lua 脚本</span></span><br><span class="line">    content_by_lua_file <span class="string">"/usr/local/nginx/conf/jartto/webp.lua"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>补充：浏览器嗅探（阿里云 <code>OSS</code> 方式）</strong><br>1.本地嗅探：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check_webp_feature:</span></span><br><span class="line"><span class="comment">// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class="line"><span class="comment">// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_webp_feature</span>(<span class="params">feature, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> kTestImages = &#123;</span><br><span class="line">        lossy: <span class="string">"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"</span>,</span><br><span class="line">        lossless: <span class="string">"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=="</span>,</span><br><span class="line">        alpha: <span class="string">"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=="</span>,</span><br><span class="line">        animation: <span class="string">"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = (img.width &gt; <span class="number">0</span>) &amp;&amp; (img.height &gt; <span class="number">0</span>);</span><br><span class="line">        callback(feature, result);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(feature, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="string">`data:image/webp;base64<span class="subst">$&#123;kTestImages[feature]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.调用方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jartto's Demo</span></span><br><span class="line">check_webp_feature(<span class="string">'lossy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">feature, isSupported</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSupported) &#123;</span><br><span class="line">        <span class="comment">// webp is supported, you can cache the result here if you want</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>请注意，图像加载是非阻塞且异步的。 这意味着依赖于 WebP 支持的任何代码最好都应放在回调函数中。</p></div><h4 id="六、部署模型"><a href="#六、部署模型" class="headerlink" title="六、部署模型"></a>六、部署模型</h4><p>服务端部署模型需要简单了解一下，这样我们就可以根据不同的实际情况从上述<a href="http://jartto.wang/2020/05/02/webp-practice/">四种方案</a>中进行选择了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/webp/server.png" alt="Server"></p><p>注意，如果你需要对 <code>Nginx</code> 进行配置，请不要操作 <code>Load Balancer</code> 层，尽量在应用服务器层操作。</p><h4 id="七、技术揭秘"><a href="#七、技术揭秘" class="headerlink" title="七、技术揭秘"></a>七、技术揭秘</h4><p><strong>1.分块 <code>MacroBlocking</code></strong><br>将图片划分成多个宏块 <code>Macro Blocks</code>，典型的宏块由一个 <code>16×16</code> 的亮度像素 <code>luma pixel</code> 块和两个 <code>8×8</code> 的色度像素 <code>chroma pixel</code> 块组成。<br><div class="alert success"><p>分块越小，预测越准，需要记录的信息也越多。</p></div><br>一般来说，细节越丰富的地方，分块越细，即使用 <code>4×4</code> 分块预测。细节相对不丰富的地方使用 <code>16×16</code> 分块。</p><p><strong>2.帧内预测</strong><br><code>WebP</code> 有损压缩使用了帧内预测编码，这一技术也被用于 <code>VP8</code> 视频编码中的关键帧压缩。</p><p><code>VP8</code> 有四种常见的帧内预测模型：</p><ul><li><code>H_PRED(horizontal prediction)</code>：像素块中每一行使用其左边一列 <code>Col L</code> 的数据填充；</li><li><code>V_PRED(vertical prediction)</code>：像素块中每一列使用其上边一行 <code>Row A</code> 的数据填充；</li><li><code>DC_PRED(DC prediction)</code>：像素块中每个单元使用 <code>Row A</code> 和 <code>Col L</code> 的所有像素的平均值填充；</li><li><code>TM_PRED(TrueMotion prediction)</code>：混合式，接近真实数据；</li></ul><p>使用哪种分块预测模式是动态决定的。<br><div class="alert info"><p>编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。</p></div></p><p><strong>3.算法编码</strong><br><code>WebP</code> 使用 <code>Arithmetic entropy encoding</code>，该算法相比 <code>JPEG</code> 上使用的 <code>Huffman encoding</code>，在压缩表现上更出色。</p><p>深入研究，请移步：<a href="#">Compression Techniques</a></p><h4 id="八、4种常见压缩格式"><a href="#八、4种常见压缩格式" class="headerlink" title="八、4种常见压缩格式"></a>八、4种常见压缩格式</h4><ol><li><p><code>Lossy</code><br>有损压缩基于 <code>VP8</code> 关键帧编码。 <code>VP8</code> 是 一种视频压缩格式，是 <code>VP6</code> 和 <code>VP7</code> 格式的后继格式。</p></li><li><p><code>Lossless</code><br>无损压缩格式由 <code>WebP</code> 团队开发。</p></li><li><p>Alpha<br><code>8</code> 位 <code>Alpha</code> 通道对于图形图像很有用。 <code>Alpha</code> 通道可与有损 <code>RGB</code> 一起使用，该功能目前无法在任何其他格式下使用。</p></li><li><p>Animation<br>它支持真彩色动画图像。</p></li></ol><div class="alert warning"><p>24 位色被称为真彩色，它可以达到人眼分辨的极限，发色数是 1677 万多色，也就是 2 的 24 次方。</p></div><h4 id="九、WebP-方案-ROI"><a href="#九、WebP-方案-ROI" class="headerlink" title="九、WebP 方案 ROI"></a>九、WebP 方案 ROI</h4><p>一般在做技术选型的过程中，我们都要评估引入技术的收益，这也就是我们常说的 <code>ROI</code>。那么如果你决定要使用 <code>WebP</code>，以下的数据可能会对你产生帮助：<br>1.优化后，网站资源大小从 <code>2.6MB</code> 减少到 <code>1.5MB</code>；<br>2.图片大小减少到原来的 <code>1/8</code>；<br>3.同一时间服务器请求数增加 <code>335%</code>，请求时长减少 <code>75%</code>；<br>4.<code>Lighthouse Performance</code> 评分 <code>97</code>，<code>FCP</code>，<code>FMP</code>大概在 <code>0.5-0.7s</code>（和其他优化有关）；           </p><div class="alert danger"><p>网站数据可能不尽相同，以上数据仅供参考。</p></div><h4 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h4><p><a href="http://jartto.wang/2020/05/02/webp-practice/">上文</a> 我们从 <code>WebP</code> 背景展开，介绍了它的兼容性、应用场景，以及 4 种实践方案，同时也提到了浏览器如何嗅探 <code>WebP</code> 格式。后半部分主要从原理出发，了解 <code>WebP</code> 格式的算法细节以及压缩格式，由浅入深，逐层剖析。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于网站来说，图片始终扮演着重要角色。图片大小直接影响网站速度、流量、运营成本以及用户体验。因此，减少图片大小成为网站优化最重要的一个环节。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="webp" scheme="http://jartto.wang/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>Web「性能测试」知多少？</title>
    <link href="http://jartto.wang/2020/04/05/about-wrk/"/>
    <id>http://jartto.wang/2020/04/05/about-wrk/</id>
    <published>2020-04-05T13:44:12.000Z</published>
    <updated>2020-04-06T15:22:02.875Z</updated>
    
    <content type="html"><![CDATA[<p>身为前端的你，是否会有这样的烦恼：随着访问用户的成倍增加，站点变得越来越脆弱。任何的访问过慢或崩溃都将是一场灾难。<br><a id="more"></a><br>这就对我们工程师提出了更高的要求，要保障网站的「可访问性」和「稳定性」都维持在一个较高水平。那么，是时候了解了解 <code>Web</code> 性能测试了！</p><h4 id="一、情景再现"><a href="#一、情景再现" class="headerlink" title="一、情景再现"></a>一、情景再现</h4><p>有一个大型推广活动来了，类似与抢火车票、淘宝双十一，你能否回答 <code>Boss</code> 的如下问题？<br>1.我们的网站是否能扛住如此的高并发？<br>2.服务器单机 <code>QPS</code> 是多少？<br>3.如果站点扛不住，扩容的话，需要几台？<br>…</p><p>一连串的问题，如果你招架不住，不妨仔细<a href="http://jartto.wang/2020/04/05/about-wrk/">阅读本文</a>。</p><h4 id="二、什么是性能测试？"><a href="#二、什么是性能测试？" class="headerlink" title="二、什么是性能测试？"></a>二、什么是性能测试？</h4><p>要回答上面的问题，需要我们有一些知识储备。不着急，循序渐进，各个击破。<br><div class="alert success"><p>一般来说「性能测试」包括压力测试、负载测试、容量测试三种主要测试类型。</p></div></p><p><strong>1.压力测试 <code>StressTest</code></strong><br>压力测试可以测试网站在某个特定的持续的压力下运行的稳定性。</p><p><strong>2.负载测试 <code>LoadTest</code></strong><br>负载测试是为了检验系统在给定负载下是否能达到预期性能指标。</p><p><strong>3.容量测试 <code>CapabilityTest</code></strong><br>容量测试针对数据库而言，是在数据库中有较大数量的数据记录情况下对系统进行的测试。</p><p>内容比较多，为了专注聚焦，我们本节主要来看一下压力测试。</p><h4 id="三、压力测试"><a href="#三、压力测试" class="headerlink" title="三、压力测试"></a>三、压力测试</h4><p>压力测试是通过不断向被测系统施加压力，测试系统在压力情况下的性能表现。主要考察当前软硬件环境下系统所能承受的最大负荷并帮助开发人员找出系统瓶颈所在。我们可以模拟巨大的流量请求以查看应用程序在峰值使用情况以及服务器状况。</p><div class="alert info"><p>有效的压力测试将应用以下这些关键条件：重复，并发，量级，随机变化。</p></div><p><strong>需要注意的是</strong>：压力测试并不会报告是什么导致了问题。它只会报告这有了问题，例如：查询页面在并发 1000 个用户使用时变慢下来，但它不会显示什么导致了变慢。</p><p>捕获到的性能统计数据例如 <code>CPU</code> 和内存使用量只是强调了潜在的问题区域，但并不会指出实际的根源在应用程序的什么地方。</p><p>更多的概念可以查看：<a href="https://blog.csdn.net/weixin_40296254/article/details/80247111" target="_blank" rel="noopener">为什么要进行压力测试?</a>。</p><h4 id="四、核心指标"><a href="#四、核心指标" class="headerlink" title="四、核心指标"></a>四、核心指标</h4><p>了解了上述压力测试之后，我们先不着急进行网站压测，补充几个可以让你事半功倍的核心指标：</p><p>1.什么是 <code>TPS</code> ？<br>即 <code>Transactions Per Second</code> 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。</p><div class="alert warning"><p>一个事务可能对应多个请求，这与数据库的事务操作极其相似。</p></div><p>2.什么是 <code>QPS</code> ？<br><code>Queries Per Second</code> 的缩写，每秒能处理查询数目，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p><strong>需要注意的是</strong>：虽然名义上是查询的意思，但实际上，现在习惯于对单一接口服务的处理能力用 <code>QPS</code> 进行表述（即使它并不是查询操作）。</p><p>3.什么是 <code>RT</code> ？<br>响应时间，处理一次请求所需要的平均处理时间。我们一般会关注 <code>90th</code> 请求的的处理时间，因为可能因网络情况出现极端情况，长尾数据会对我们产生干扰。</p><p>4.系统 <code>CPU</code> 利用率<br>如果系统的 <code>CPU</code> 使用率已经很高，说明我们的系统是个计算度很复杂的系统，这时候如果 <code>QPS</code> 已经上不去了，就需要赶紧扩容，通过增加机器分担计算的方式来提高系统的吞吐量。</p><p>5.系统内存<br>如果 <code>CPU</code> 使用率一般，但是系统的 <code>QPS</code> 上不去，说明我们的机器并没有忙于计算，而是受到其他资源的限制，如内存、<code>I/O</code>。这时候首先看下内存是不是已经不够了，如果内存不够了，那就赶紧扩容了。</p><h4 id="五、QPS-如何计算？"><a href="#五、QPS-如何计算？" class="headerlink" title="五、QPS 如何计算？"></a>五、QPS 如何计算？</h4><p><code>QPS</code> 并没有准确的计算公式，但是实际压测中我们完全可以按照如下模型进行估算：<br><div class="alert info"><p>原理：每天 80% 的访问集中在 20% 的时间里，这 20% 时间叫做「峰值时间」。</p></div></p><p>公式：( 总 <code>PV</code> 数 <em> <code>80%</code> ) / ( 每天秒数 </em> <code>20%</code> ) = 峰值时间每秒请求数(<code>QPS</code>)<br>机器：峰值时间每秒 <code>QPS</code> / 单台机器的 <code>QPS</code> = 需要的机器</p><p>问：每天 <code>300w PV</code> 的在单台机器上，这台机器需要多少 <code>QPS</code>？<br>答：<code>( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</code></p><p>问：如果一台机器的 <code>QPS</code> 是 <code>58</code> ，需要几台机器来支持？<br>答：<code>139 / 58 = 3</code></p><p>具体的计算公式可以参考这篇文章：<a href="#">峰值 <code>QPS</code> 和机器计算公式</a>。</p><h4 id="六、推荐工具"><a href="#六、推荐工具" class="headerlink" title="六、推荐工具"></a>六、推荐工具</h4><p><a href="https://www.zhihu.com/question/21861449" target="_blank" rel="noopener">压测工具</a>有很多，<code>JMeter</code>，<code>LoadRunner</code>，<code>WebLoad</code>，<code>NeoLoad</code>，<code>Loadster</code>，<code>TcpCopy</code>，<code>AB</code>，<code>WebBench</code> 等等，恐怕一时间无法说完。但是论起上手能力，就要说说我们的主角 <code>wrk</code> 了。</p><p><a href="https://github.com/wg/wrk" target="_blank" rel="noopener"><code>wrk</code></a> 是一款针对 <code>Http</code> 协议的基准测试工具，它能够在单机多核 <code>CPU</code> 的条件下，使用系统自带的高性能 <code>I/O</code> 机制，如 <code>Epoll</code>，<code>Kqueue</code> 等，通过多线程和事件模式，对目标机器产生大量的负载。</p><p>有多容易，我们不妨试试看？</p><p>1.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk.git  </span><br><span class="line">cd wrk  </span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>注意使用 <code>./wrk</code> 命令启动。</p><p>2.基本使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t12 -c400 -d30s http://127.0.0.1:8080/jartto</span><br></pre></td></tr></table></figure></p><p>参数说明：<br><code>-c</code>：<code>HTTP</code> 连接数，每一个线程处理 <code>N</code> = 连接数/线程数<br><code>-d</code>：持续时间，<code>2s</code>，<code>2m</code>，<code>2h</code><br><code>-t</code>：总的线程数<br><code>-s</code>：脚本，可以是 <code>Lua</code> 脚本<br><code>-H</code>：增加 <code>HTTP header</code>，例如：<code>User-Agent: jartto</code><br><code>--latency</code>：输出时间统计的细节<br><code>--timeout</code>：超时时间</p><p>3.输出<br>上面我们使用 <code>12</code> 线程，保持打开 <code>400</code> 个 <code>Http</code> 连接，执行 <code>30s</code>。脚本运行完毕会输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Running 30s <span class="built_in">test</span> @ http://127.0.0.1:8080/jartto</span><br><span class="line">  12 threads and 400 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   635.91us    0.89ms  12.92ms   93.69%</span><br><span class="line">    Req/Sec    56.20k     8.07k   62.00k    86.54%</span><br><span class="line">  22464657 requests <span class="keyword">in</span> 30.00s, 17.76GB <span class="built_in">read</span></span><br><span class="line">Requests/sec: 748868.53</span><br><span class="line">Transfer/sec:    606.33MB</span><br></pre></td></tr></table></figure></p><p>输出说明：<br><code>Latency</code>：响应时间<br><code>Req/Sec</code>：每个线程每秒钟的完成的请求数<br><code>Avg</code>：平均<br><code>Max</code>：最大<br><code>Stdev</code>：标准差<br><code>+/- Stdev</code>： 正负一个标准差占比</p><div class="alert danger"><p>标准差大说明样本离散程度高，系统性能波动大。</p></div><p>在压测过程中，一般线程数不宜过多，<code>CPU</code> 核数的 <code>2-4</code> 倍就可以了。 太多反而因为线程切换过多造成效率降低， 因为 <code>wrk</code> 不是使用每个连接一个线程的模型， 而是通过异步网络 <code>I/O</code> 提升并发量。</p><p>所以网络通信不会阻塞线程执行，这也是 <code>wrk</code> 可以用很少的线程模拟大量网路连接的原因。</p><h4 id="七、高级定制"><a href="#七、高级定制" class="headerlink" title="七、高级定制"></a>七、高级定制</h4><p>到这里，相信文章开头提出的问题，你已经可以很好的回答了。我们不妨继续升级，来一些高级定制。可能很多童鞋注意到了上面文档中提到的 <code>-s</code> 参数了，我们先看看官方文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An optional LuaJIT script can perform HTTP request generation, response processing, </span><br><span class="line">and custom reporting.</span><br></pre></td></tr></table></figure></p><p><code>LuaJIT</code> 脚本可以执行 <code>HTTP</code> 请求生成，响应处理和自定义报告。这里是 <code>Lua</code> 的一些<a href="https://github.com/wg/wrk/tree/master/scripts" target="_blank" rel="noopener">案例</a>。鉴于篇幅过长，本节我们先了解到这里，精彩部分我们就留到<a href="#">下一篇</a>继续探讨吧！</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p><!-- `wrk` 中执行 `HTTP` 请求的时候，调用 `Lua` 分为 `3` 个阶段，`setup`，`running`，`done`，每个 `wrk` 线程中都有独立的脚本环境。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身为前端的你，是否会有这样的烦恼：随着访问用户的成倍增加，站点变得越来越脆弱。任何的访问过慢或崩溃都将是一场灾难。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="wrk" scheme="http://jartto.wang/tags/wrk/"/>
    
  </entry>
  
  <entry>
    <title>聚焦 Web 性能指标 TTI</title>
    <link href="http://jartto.wang/2020/03/29/web-tti/"/>
    <id>http://jartto.wang/2020/03/29/web-tti/</id>
    <published>2020-03-29T14:23:53.000Z</published>
    <updated>2020-03-30T03:12:56.132Z</updated>
    
    <content type="html"><![CDATA[<p>如果你经常做网站优化，可能会陷入一个性能指标的泥潭即「面向指标优化」。真正的用户体验从来不是指标决定，相反它应该最真实的反映用户行为。<br><a id="more"></a><br>所以本节我们就来研究 <code>TTI(Time to Interactive)</code>，话题展开之前，我们先来了解一些背景知识。</p><h4 id="一、RAIL-模型"><a href="#一、RAIL-模型" class="headerlink" title="一、RAIL 模型"></a>一、RAIL 模型</h4><p><code>RAIL</code> 是一种以用户为中心的性能模型。每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/rail.png" alt="RAIL 性能模型"></p><p>1.响应：输入延迟时间（从点按到绘制）小于 100 毫秒。<br>用户点按按钮（例如打开导航）。</p><p>2.动画：每个帧的工作（从 JS 到绘制）完成时间小于 16 毫秒。<br>用户滚动页面，拖动手指（例如，打开菜单）或看到动画。 拖动时，应用的响应与手指位置有关（例如，拉动刷新、滑动轮播）。 此指标仅适用于拖动的持续阶段，不适用于开始阶段。</p><p>3.空闲：主线程 JS 工作分成不大于 50 毫秒的块。<br>用户没有与页面交互，但主线程应足够用于处理下一个用户输入。</p><p>4.加载：页面可以在 1000 毫秒内就绪。<br>用户加载页面并看到关键路径内容。</p><div class="alert info"><p>如果要提升网站用户体验，RAIL 是个不错的评估模型。</p></div><h4 id="二、解读-TTI（页面可交互时间）"><a href="#二、解读-TTI（页面可交互时间）" class="headerlink" title="二、解读 TTI（页面可交互时间）"></a>二、解读 TTI（页面可交互时间）</h4><p><code>TTI</code> 指的是应用既在视觉上都已渲染出了，可以响应用户的输入了。要了解 <code>TTI</code>，我们需要知道它的计算规则，先来看下面这张图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/tti.png" alt="TTI"></p><p>在<a href="https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/preview#" target="_blank" rel="noopener">官方文档</a>中找到了如下描述：<br><code>First Idle is the first early sign of time where the main thread has come at rest and the browser has completed a First Meaningful Paint.</code></p><p><code>Time to Interactive is after First Meaningful Paint. The browser’s main thread has been at rest for at least 5 seconds and there are no long tasks that will prevent immediate response to user input.</code></p><p>我们可以简单的理解一下：<br>1.<code>First Idle</code> 是主线程处于静止状态且浏览器已完成 <code>First Meanfulful Paint</code> 的第一个早期迹象；<br>2.<code>TTI</code> 在 <code>FMP</code> 之后，浏览器主线程静止至少 <code>5s</code>，并且没有可以阻断用户交互响应的「长任务」。</p><p>如果你对 <code>FMP</code> 还不了解，不妨先看看这篇文章：<a href="http://jartto.wang/2020/03/15/about-web-fmp/">网站性能指标 - <code>FMP</code></a>。除此之外，第二条中提到的「长任务」又是什么呢？</p><h4 id="三、Long-Task（长任务）"><a href="#三、Long-Task（长任务）" class="headerlink" title="三、Long Task（长任务）"></a>三、Long Task（长任务）</h4><p>对于「长任务」，我们通过如下图示说明：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/longtask.png" alt="长任务"></p><div class="alert info"><p>对于用户而言，任务耗时较长表现为滞后或卡顿，而这也是目前网页不良体验的主要根源。</p></div><p>如何测量 <code>Long Task</code>？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jartto's Demo</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span><br><span class="line">    <span class="comment">// TODO...</span></span><br><span class="line">    <span class="built_in">console</span>.log(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.observe(&#123;<span class="attr">entryTypes</span>: [<span class="string">'longtask'</span>]&#125;);</span><br></pre></td></tr></table></figure></p><p>控制台输出结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"self"</span>,</span><br><span class="line">  <span class="string">"entryType"</span>: <span class="string">"longtask"</span>,</span><br><span class="line">  <span class="string">"startTime"</span>: <span class="number">315009.59500001045</span>,</span><br><span class="line">  <span class="string">"duration"</span>: <span class="number">99.9899999878835</span>,</span><br><span class="line">  <span class="string">"attribution"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">      <span class="string">"entryType"</span>: <span class="string">"taskattribution"</span>,</span><br><span class="line">      <span class="string">"startTime"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"containerType"</span>: <span class="string">"window"</span>,</span><br><span class="line">      <span class="string">"containerSrc"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"containerId"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"containerName"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Long Tasks API</code> 可以将任何耗时超过 <code>50</code> 毫秒的任务标示为可能存在问题，并向应用开发者显示这些任务。 选择 <code>50</code> 毫秒的时间是为了让应用满足在 <code>100</code> 毫秒内响应用户输入的 <code>RAIL</code> 指导原则。</p><p>实际开发过程中，我们可以通过一个 <code>hack</code> 来检查页面中「长任务」的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detect long tasks hack</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">detectLongFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastFrameTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentFrameTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (currentFrameTime - lastFrameTime &gt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="comment">// Report long frame here...</span></span><br><span class="line">        &#125;</span><br><span class="line">        detectLongFrame(currentFrameTime);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h4 id="四、如何计算-TTI？"><a href="#四、如何计算-TTI？" class="headerlink" title="四、如何计算 TTI？"></a>四、如何计算 TTI？</h4><p>在计算之前，我们先来看一下 <code>Timing API</code>：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/tti/timing.png" alt="Timing API"></p><p><code>Google</code> 官方文档中有一段描述：<br><code>Note: Lower Bounding FirstInteractive at DOMContentLoadedEndDOMContentLoadedEnd is the point where all the DOMContentLoaded listeners finish executing. It is very rare for critical event listeners of a webpage to be installed before this point. Some of the firstInteractive definitions we experimented with fired too early for a small number of sites, because the definitions only looked at long tasks and network activity (and not at, say, how many event listeners are installed), and sometimes when there are no long tasks in the first 5-10 seconds of loading we fire FirstInteractive at FMP, when the sites are often not ready yet to handle user inputs. We found that if we take max(DOMContentLoadedEnd, firstInteractive) as the final firstInteractive value, the values returned to reasonable region. Waiting for DOMContentLoadedEnd to declare FirstInteractive is sensible, so all the definitions introduced below lower bound firstInteractive at DOMContentLoadedEnd.</code></p><p>所以，我们可以通过 <code>domContentLoadedEventEnd</code> 来粗略的进行估算：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面可交互时间 </span></span><br><span class="line">TTI: domContentLoadedEventEnd - navigationStart,</span><br></pre></td></tr></table></figure></p><div class="alert info"><p><a href="https://w3c.github.io/navigation-timing/#dom-performancenavigationtiming-domcontentloadedeventend" target="_blank" rel="noopener">domContentLoadedEventEnd</a>：文档的 DOMContentLoaded 事件的结束时间。</p></div><p><code>The domContentLoadedEventEnd attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately after the current document&#39;s DOMContentLoaded event completes.</code></p><p>如果你觉得上述计算过于复杂，可以通过 <code>Google</code> 实验室提供的 <code>Polyfill</code> 来获取。</p><h4 id="五、TTI-指标监控"><a href="#五、TTI-指标监控" class="headerlink" title="五、TTI 指标监控"></a>五、TTI 指标监控</h4><p>我们可以通过 <a href="https://github.com/GoogleChromeLabs/tti-polyfill" target="_blank" rel="noopener"><code>Google TTI Polyfill</code></a>来对 <code>TTI</code> 进行监测。<br>1.安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install tti-polyfill</span><br></pre></td></tr></table></figure></p><p>2.使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ttiPolyfill <span class="keyword">from</span> <span class="string">'./path/to/tti-polyfill.js'</span>;</span><br><span class="line">ttiPolyfill.getFirstConsistentlyInteractive(opts).then(<span class="function">(<span class="params">tti</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Use `tti` value in some way.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>很简单，就不细说了。推荐几篇 <code>TTI</code> 相关文章：<br><a href="https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/preview#" target="_blank" rel="noopener">First Interactive and Consistently Interactive</a><br><a href="https://web.dev/user-centric-performance-metrics/#tracking_tti" target="_blank" rel="noopener">User-centric performance metrics</a><br><a href="https://calibreapp.com/blog/time-to-interactive" target="_blank" rel="noopener">Focusing on the Human-Centric Metrics</a></p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你经常做网站优化，可能会陷入一个性能指标的泥潭即「面向指标优化」。真正的用户体验从来不是指标决定，相反它应该最真实的反映用户行为。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="tti" scheme="http://jartto.wang/tags/tti/"/>
    
  </entry>
  
  <entry>
    <title>网站性能指标 - FMP</title>
    <link href="http://jartto.wang/2020/03/15/about-web-fmp/"/>
    <id>http://jartto.wang/2020/03/15/about-web-fmp/</id>
    <published>2020-03-15T10:47:26.374Z</published>
    <updated>2020-03-30T03:13:15.709Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端童鞋来说，优化是一个永恒的话题。上线并不是网站开发的终点，如何吸引用户、提升用户体验，应该成为我们 <code>F2E</code> 的追求目标。<br><a id="more"></a><br>如果你对优化还不了解，建议先阅读如下两篇文章：</p><ol><li><a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a></li><li><a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化，这些工具你一定用得着</a></li></ol><p>当然，衡量网站性能的指标有很多，今天我们就来看一个「令人费解而又头疼」的指标 - <code>FMP</code>。</p><div class="alert success"><p><code>First Meaningful Paint</code> 是指页面的首要内容出现在屏幕上的时间。</p></div><h4 id="一、FMP-之怪现象"><a href="#一、FMP-之怪现象" class="headerlink" title="一、FMP 之怪现象"></a>一、FMP 之怪现象</h4><p>目前尚无标准化的 <code>FMP</code> 定义，因此也没有性能条目类型。 部分原因在于很难以通用的方式确定「有效」对于所有页面意味着什么。但是，一般来说，在单个页面或单个应用中，最好是将 <code>FMP</code> 视为主角元素呈现在屏幕上的时刻。</p><p>所以，我们经常会面临这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/lighthouse.png" alt="Lighthouse 评分"><br><code>FCP</code> 在可接受范围，但是 <code>FMP</code> 却完全失控。</p><p>也可能是这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp1.png" alt="Performance FMP"></p><p>或许还有这样的问题：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp2.png" alt="Performance FMP"></p><p>为什么结构类似的站点，<code>FMP</code> 加载却千差万别。要了解 <code>FMP</code> 我们需要知道它的计算规则，下面让我们一层层抽丝剥茧。</p><h4 id="二、刨根问底"><a href="#二、刨根问底" class="headerlink" title="二、刨根问底"></a>二、刨根问底</h4><p>究竟是什么导致 <code>FMP</code> 的时机差距如此之大？或许我们可以从 <code>FMP</code> 定义来说起。</p><p><code>When FMP and FCP are the same time in seconds, they share the same identical score. If FMP is slower than FCP, say when there&#39;s iframe content loading, then the FMP score will be lower than the FCP score.</code></p><p>什么意思呢，我们先来看一张官方图片：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/fmp.png" alt="FMP 评分规则"></p><p>如果 <code>FCP</code> 是 <code>1.5s</code>，<code>FMP</code> 是 <code>3s</code>，那么 <code>FCP</code> 分数将会是 <code>99</code>，但是 <code>FMP</code> 分数将是 <code>75</code>。</p><p>除了上述影响外，我们还需要关注 <code>Lighthouse V3</code> 的记分规则：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/score.png" alt="记分规则"></p><p>虽然 <code>FMP</code> 权重仅为 <code>1</code> ，很遗憾，因为如上规则的存在，我们站点无法到达满分💯。</p><div class="alert info"><p>确定页面上最关键的主角元素之后，我们应确保初始脚本加载仅包含渲染这些元素并使其可交互所需的代码。</p></div><p>相关源码：<br><a href="https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/audits/metrics/first-meaningful-paint.js" target="_blank" rel="noopener">Lighthouse FMP 源码</a><br><a href="https://medium.com/@aswin_s/score-a-perfect-100-in-lighthouse-audits-part-1-3199163037" target="_blank" rel="noopener">Score a perfect 100 in Lighthouse audits</a></p><h4 id="三、重要结论"><a href="#三、重要结论" class="headerlink" title="三、重要结论"></a>三、重要结论</h4><p>了解了相关计算规则之后，我们继续来剖析 <code>FMP</code>。对于不同的站点，首要内容是不同的，例如：</p><ul><li>对于博客文章：「大标题」 + 「首屏文字」是首要内容；</li><li>对于百度或者 <code>Google</code> 的搜索结果页：「首屏的结果」就是首要内容；</li><li>对于淘宝等购物网站来说，图片会极为重要，因此它是首要内容；</li></ul><div class="alert danger"><p>需要注意的是，通常首要内容是不包括 Headers 和导航条的。</p></div><p>为了方便理解，我们用一个简单的公式表示：「首次有效绘制 = 具有最大布局变化的绘制」。</p><p>很好，此刻我们不用纠结「首次有效渲染」了，转而去了解「最大布局变化的绘制」。基于 <code>Chromium</code> 的实现，这个绘制是使用 <code>LayoutAnalyzer</code> 进行计算的，它会收集所有的布局变化，当布局发生最大变化时得出时间。</p><p>具有最大布局变化的绘制如何计算呢？<br>1.侦听页面元素的变化；<br>2.遍历每次新增的元素，并计算这些元素的得分总；<br>3.如果元素可见，得分为 <code>1 * weight</code>，如果元素不可见，得分为 <code>0</code>；</p><p>还是很抽象，我们继续探索 <code>LayoutAnalyzer</code>，在源码中得到如下公式：<br><div class="alert info"><p>布局显著性 = 添加的对象数目 / max(1, 页面高度 / 屏幕高度)</p></div></p><p>这下清晰了，既然可以算出来，那么优化 <code>FMP</code> 指日可待。从上面可以看出来「布局显著性」是通过添加对象数目与页面高度来计算的。似乎对象数目成了解决问题的关键节点。</p><p>我们继续探索，如何去找到对象数目呢？很简单，打开 <code>Chrome DevTool</code>，切到 <code>Layout</code> 面板。如果你还不会使用 <code>Layout</code> 面板，可以先看看<a href="http://jartto.wang/2019/09/08/web-optimization-tools/">网站优化工具</a>。</p><p>这里就不展开了，直接上图，看看红框部分：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/fmp/layout.png" alt="Layout Objects"></p><p>惊不惊喜，我们精简 <code>DOM</code> 似乎可以将公式中分子变小，或者让页面高度大于屏幕高度。到这里，所有谜团都解开了，优化 <code>FMP</code> 也就变得毫无挑战了。</p><p>相关源码：<br><a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/layout/layout_analyzer.h?type=cs&amp;q=LayoutAnalyzer&amp;sq=package:chromium&amp;g=0&amp;l=76" target="_blank" rel="noopener">LayoutAnalyzer 源码</a><br><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/trace-event-reading" target="_blank" rel="noopener">Tracing Results</a><br><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/trace-event-reading" target="_blank" rel="noopener">Understanding about:tracing results</a></p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>我们从扑簌迷离的 <code>FMP</code> 表象一层层找到了 <code>Lighthouse</code> 的记分规则，又从 <code>Tracing Results</code> 中得知最大布局变化的计算规则，因此转向 <code>LayoutAnalyzer</code> 源码研究，最终找到 <code>Layout Objects</code>，从而解决了问题。虽然波折，但结局令人舒适。</p><p>最后，再啰嗦一下，以下结论对理解 <code>FMP</code> 很重要：</p><ul><li>对于博客文章：「大标题」 + 「首屏文字」是首要内容；</li><li>对于百度或者 <code>Google</code> 的搜索结果页：「首屏的结果」就是首要内容；</li><li>对于淘宝等购物网站来说，图片会极为重要，因此它是首要内容；</li></ul><p>如果你觉得还是过于复杂，不妨去试试 <code>SSR</code> 吧，<code>FMP</code> 将不再是烦恼。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于前端童鞋来说，优化是一个永恒的话题。上线并不是网站开发的终点，如何吸引用户、提升用户体验，应该成为我们 &lt;code&gt;F2E&lt;/code&gt; 的追求目标。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="lighthouse" scheme="http://jartto.wang/tags/lighthouse/"/>
    
      <category term="fmp" scheme="http://jartto.wang/tags/fmp/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>破局：技术视野与规划</title>
    <link href="http://jartto.wang/2020/03/08/breaking-the-game/"/>
    <id>http://jartto.wang/2020/03/08/breaking-the-game/</id>
    <published>2020-03-08T10:32:43.000Z</published>
    <updated>2020-03-09T15:22:29.733Z</updated>
    
    <content type="html"><![CDATA[<p>有幸参加了 <code>51CTO</code> 的技术峰会，一天满满的干货，感觉收益颇多。于是将重点内容整理总结，分享给大家。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/title.png" alt="PPT"><br>分享标题为<strong>《破局：技术视野与规划》</strong>，主要围绕峰会内容展开，中间夹杂一些个人见解与思考。</p><div class="alert warning"><p>下文多图预警，建议小伙伴们 Wi-Fi 阅读。</p></div><h4 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/contents.png" alt="目录"></p><p>我们将从以下四方面来展开说明：<br>1.<code>2019 CTO</code> 发展报告<br>2.技术团队模型<br>3.技术视野<br>4.技能发展与规划</p><h4 id="二、2019-CTO-发展报告-2019-CTO-Development-Report"><a href="#二、2019-CTO-发展报告-2019-CTO-Development-Report" class="headerlink" title="二、2019 CTO 发展报告 - 2019 CTO Development Report"></a>二、2019 CTO 发展报告 - 2019 CTO Development Report</h4><p>峰会开场就拿出了一份调查报告，主要围绕四方面：<br>1.<strong>宏观环境</strong><br>2017-2019 年，下行经济环境市场缺口在收缩。向「公司管理驱动」和「科技创新驱动」转变。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/macro.png" alt="宏观经济"></p><p>从图中我们可以看出来，下行经济环境下市场缺口正在收缩。难道 <code>CTO</code> 要面临失业吗？不着急，我们接着往下看。</p><p>2.<strong>机遇与挑战</strong><br>以「业务为中心」的延伸，向上是对商业战略的思考，向下是对技术管理、技术交付的落实。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/opportunities.png" alt="机遇与挑战"></p><p>3.<strong>胜任力</strong><br>既懂得战略、又懂得组织管理、又懂得企业内部运营机制的技术负责人。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/capability.png" alt="胜任力"></p><p>我们可以看出：对 <code>CTO</code> 的胜任力要求，越来越趋向于一个既懂得战略、又懂得组织管理、又懂得企业内部运营机制的技术负责人。</p><div class="alert info"><p>所以，并不是需求变少，而是对高精尖人才的要求越来越高。</p></div><p>4.<strong>投资人视角</strong><br>产业革命造就了帝国的崛起，前三次工业革命大家耳熟能详，那么第四次工业革命到底是什么？希望我们中有人可以来定义第四次工业革命～<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/investor.png" alt="投资人视角"></p><p>下图列举了一些未来 10 年投资的一些方向，抓住机会，理财从现在开始。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/investor2.png" alt="投资领域"></p><h4 id="三、技术团队模型-Technical-team-model"><a href="#三、技术团队模型-Technical-team-model" class="headerlink" title="三、技术团队模型 - Technical team model"></a>三、技术团队模型 - Technical team model</h4><p>本节，我们将从技术团队模型来说：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team.png" alt="技术团队"></p><div class="alert info"><p>内容来自 4 位 CTO 的总结，我们集百家之长。</p></div><p>1.<strong>技术团队 <code>ROI</code>：领导的角度</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team-roi.png" alt="领导的角度"></p><p>不管问题如何回答，我们只有一个核心观点：<strong>对于公司来说，所有的事情都是赚钱相关的</strong>。</p><p>2.<strong>技术团队 <code>ROI</code>：下属的角度</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team2.png" alt="下属的角度"></p><p>下属想法很淳朴，甚至很无辜。</p><p>3.<strong>技术团队 <code>ROI</code></strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team3.png" alt="技术团队 ROI"></p><p>4.<strong>BSC 模型</strong><br>总结来说就是：以前瞻性和战略性为基础的平衡计分卡。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team4.png" alt="BSC 模型"></p><p>我们简单补充一下：<br>平衡计分卡(<code>The Balanced ScoreCard</code>，简称 <code>BSC</code>），就是根据企业组织的战略要求而精心设计的指标体系。平衡计分卡是一种绩效管理的工具。</p><p>它将企业战略目标逐层分解转化为各种具体的相互平衡的绩效考核指标体系，并对这些指标的实现状况进行不同时段的考核，从而为企业战略目标的完成建立起可靠的执行基础。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/team5.png" alt="BSC 模型"></p><p>平衡计分卡中有一些条目是很难解释清楚或者是衡量出来的。财务指标当然不是问题，而非财务指标往往很难去建立起来。确定绩效的衡量指标往往比想象的更难。</p><p>我们来概括一下重点：</p><ul><li>全局战略思维(像 CEO 一样思考)</li><li>持续提升技术驱动业务创新与增长，赋能企业可持续发展</li><li>善用管理、效能与技术工具</li></ul><p>5.<strong>大型科技团队的管理</strong><br><div class="alert success"><p>大型科技团队中最重要的五部分：使命和定位，绩效管理，团队文化，技术决策，执行力。</p></div></p><p>这里收集了大型科技公司的组织架构，很有意思：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/management.png" alt="大型科技团队的管理"></p><p>大概解释一下：</p><ul><li>亚马逊等级森严且有序；</li><li>谷歌结构清晰，产品和部门之间却相互交错且混乱；</li><li><code>Facebook</code> 架构分散，就像一张散开的网络；</li><li>微软内部各自占山为王，军阀作风深入骨髓；</li><li>苹果一个人说了算，而那个人路人皆知；</li><li>庞大的甲骨文，臃肿的法务部显然要比工程部门更加重要；</li></ul><p>这里推荐一本书，《信任五层波浪》：自我信任，关系信任，组织信任，市场信任，社会信任。</p><p>6.<strong><code>ToB</code> 形态下的技术挑战</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/2b.png" alt="ToB"></p><p>双活架构体系：<br>两个数据中心是对等的、不分主从、并可同时部署业务，可极大的提高资源的利用率和系统的工作效率、性能，双活是觉得备用数据中心只做备份太浪费了，所以让主备两个数据中心都同时承担用户的业务，此时，主备两个数据中心互为备份，并且进行实时备份。</p><p>一般来说，主数据中心的负载可能会多一些，比如分担 60~70% 的业务，备数据中心只分担 40%~30% 的业务。</p><h4 id="四、技术视野-Technical-perspective"><a href="#四、技术视野-Technical-perspective" class="headerlink" title="四、技术视野 - Technical perspective"></a>四、技术视野 - Technical perspective</h4><p>关于技术视野，峰会上提到了几个概念，下面我们来逐一解释。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/perspective.png" alt="技术视野"></p><p>1.<strong><code>5G</code> 时代</strong><br><code>5G</code> 时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构 <code>Monolithic</code> 变成微服务架构<code>Microservices</code>，相当于一个全能型变成N个专能型。</p><div class="alert success"><p>每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p></div><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/5g.png" alt="5G"></p><p><code>5G</code> 的特点概括来说：高数据速率、减少延迟、节省能源、降低成本、提高系统容量和大规模设备连接。</p><p>2.<strong>工程效能</strong><br>很多大厂都专门设立了这个部门，主要职责包括：需求治理、质量分析，量化管理，代码构建、代码搜索，开发测试、自动化、发布、舆情监控等。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/effective.png" alt="工程效能"></p><p>3.<strong>红蓝军对抗</strong><br>类似于军事领域的红蓝军对抗，网络安全中，红蓝军对抗则是一方扮演黑客「蓝军」，一方扮演防御者「红军」。红蓝军对抗的目的就是用来评估企业安全性，有助于找出企业安全中最脆弱的环节，提升企业安全能力的建设。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/confrontation.png" alt="红蓝军对抗"></p><p>4.<strong>数字化转型</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/digital.png" alt="数字化转型"></p><p>这里不得不说说什么是「数字领导力」，在我们正在经历的这场数字革命中，透明化、网络化、公开化和分享成为领导力文化的核心。</p><p>数字经济时代，数字化领导力是企业战略地使用数字资产达成商业目的的能力。对企业而言，清晰的数字化战略和强有力的数字化领导者将对该目标的实现起到关键作用。</p><h4 id="五、技能发展与规划-Skill-development-and-planning"><a href="#五、技能发展与规划-Skill-development-and-planning" class="headerlink" title="五、技能发展与规划 - Skill development and planning"></a>五、技能发展与规划 - Skill development and planning</h4><p>1.<strong>进化路径</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/plan.png" alt="进化路径"></p><p>2.<strong>具备能力</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/ability.png" alt="数字化转型"></p><p>3.<strong>提升途径</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/break/ascent.png" alt="数字化转型"></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>好了，以上就是我分享的主要内容，感兴趣的童鞋欢迎深入交流。如果你需要 <code>PPT</code> ，可以去这里<a href="https://pan.baidu.com/s/1nNha7JtZCOo1GfxuOx_aeg" target="_blank" rel="noopener">下载</a>（提取码: <code>i6ud</code>）。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸参加了 &lt;code&gt;51CTO&lt;/code&gt; 的技术峰会，一天满满的干货，感觉收益颇多。于是将重点内容整理总结，分享给大家。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="技术视野" scheme="http://jartto.wang/tags/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/"/>
    
      <category term="规划" scheme="http://jartto.wang/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>极简弹幕方案</title>
    <link href="http://jartto.wang/2020/02/16/web-barrager/"/>
    <id>http://jartto.wang/2020/02/16/web-barrager/</id>
    <published>2020-02-16T15:58:47.000Z</published>
    <updated>2020-02-22T14:05:12.809Z</updated>
    
    <content type="html"><![CDATA[<p>重大的活动现场一般离不开 <code>PPT</code> 演示，可是如何有效和现场互动呢？这时候弹幕必不可少，静态的 <code>PPT</code> 就略显乏力。有没有一种好的方案可以二者兼得呢？<br><a id="more"></a><br><div class="alert info"><p>如何才能使 <code>PPT</code> 具有交互性，这是一个值得思考的问题！</p></div></p><p>可能很多童鞋想到了，如果使用「网页 <code>PPT</code>」 ，岂不是完美解决了这个问题。本节我们就来提供一种思路，用「<code>PPT</code> + 发射器 + <code>Socket</code>」 实现「极简弹幕方案」。</p><p><strong>关于「网页 <code>PPT</code>」，可以查看我之前的文章「<a href="http://jartto.wang/2019/04/15/amusing-ppt/">酷炫的 <code>HTML5</code> 网页 <code>PPT</code></a>」一探究竟。</strong></p><h4 id="一、效果演示"><a href="#一、效果演示" class="headerlink" title="一、效果演示"></a>一、效果演示</h4><p>我们先通过一个简单的视屏演示一下效果：</p><video src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/barrager/demo.mp4" controls="controls" width="100%" height>您的浏览器不支持播放该视频！</video><p>相关代码：<a href="#">Demo 地址</a></p><h4 id="二、方案概括"><a href="#二、方案概括" class="headerlink" title="二、方案概括"></a>二、方案概括</h4><div class="alert info"><p>看完上面的演示，是不是迫不及待想知道答案，下面我们来逐步拆分。</p></div><p>先来看看代码结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── mobile</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── public</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── yarn.lock</span><br><span class="line">├── package.json</span><br><span class="line">├── ppt</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── extras</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   └── temp</span><br><span class="line">├── server</span><br><span class="line">│   ├── app.js</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package-lock.json</span><br><span class="line">│   └── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>我们主要关注以下三个目录：</p></div><p>1.<code>ppt</code><br>使用 <code>impressjs</code> 构建的项目，<code>PPT</code> 演讲「主屏」，主要演示内容区域，同时接收「服务端」推送弹幕信息。</p><p>2.<code>mobile</code><br>移动端，下文称作「发射器」，主要用作现场用户互动向主屏发送弹幕消息。通过 <code>Create React App</code> 生成，技术栈是：<code>React + Antd</code>。</p><p>3.<code>server</code><br>服务端，主要接受用户弹幕，同时广报到主屏，使用 <code>Socket</code> 实现。</p><div class="alert success"><p>启动方式：</p></div><p>1.进入 server 目录，启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></p><p>此时会启动一个本机 IP 地址的服务。</p><p>2.进入 ppt 目录，使用 http-server 启动站点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server</span><br></pre></td></tr></table></figure></p><p>注意：接口地址需要替换成本机 IP 地址。</p><p>3.进入 mobile 目录，启动发射器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure></p><p>注意：请求接口需要使用本机 IP 地址。</p><p><a href="https://github.com/chenfengyanyu/barrager-ppt-demo" target="_blank" rel="noopener">Demo</a> 比较简单，主要展示主流程，如果细节过程有问题，欢迎一起探讨。</p><h4 id="三、主屏细节（核心代码）"><a href="#三、主屏细节（核心代码）" class="headerlink" title="三、主屏细节（核心代码）"></a>三、主屏细节（核心代码）</h4><p>主屏是主要演示版面，我们需要像下面这样作出 <code>PPT</code>，这里我们做了三个页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span> <span class="attr">class</span>=<span class="string">"jartto"</span> <span class="attr">data-transition-duration</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cover"</span> <span class="attr">class</span>=<span class="string">"step slide title"</span> <span class="attr">data-x</span>=<span class="string">"1000"</span> <span class="attr">data-y</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"temp/img/qrcode.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"award"</span> <span class="attr">class</span>=<span class="string">"step slide"</span> <span class="attr">data-x</span>=<span class="string">"2000"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请开始你的表演～<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"change"</span> <span class="attr">class</span>=<span class="string">"step slide"</span> <span class="attr">data-x</span>=<span class="string">"2000"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span> <span class="attr">data-scale</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>切换 PPT<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"thank"</span> <span class="attr">class</span>=<span class="string">"step slide"</span>  <span class="attr">data-rel-x</span>=<span class="string">"0"</span> <span class="attr">data-rel-y</span>=<span class="string">"3000"</span> <span class="attr">data-rotate</span>=<span class="string">"90"</span> <span class="attr">data-scale</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/thanks.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><div class="alert warning"><p>每个 div 就是一页 ppt，里面可以随意排版，data-x 控制位置，data-scale 控制缩放，data-rotate 控制旋转。</p></div><p>更多 <code>API</code> 文档，请参考如下文档：<br>1.<a href="http://jartto.wang/2019/04/15/amusing-ppt/">酷炫的 <code>HTML5</code> 网页 <code>PPT</code></a><br>2.<a href="https://github.com/impress/impress.js" target="_blank" rel="noopener">文档地址</a></p><h4 id="四、实现弹幕"><a href="#四、实现弹幕" class="headerlink" title="四、实现弹幕"></a>四、实现弹幕</h4><p>为了更好的理解弹幕，我们来实现一个简版：<br>1.定义弹幕结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto_demo"</span>&gt;</span>我是弹幕<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.定义移动动画<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> barrager&#123;</span><br><span class="line">   <span class="selector-tag">from</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translateX</span>(0);</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">to</span>&#123;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translate3d</span>(-100%, 0, 0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>注意，使用 translate3d 可以开启 GPU 硬件加速，会比 translateX 更流畅一些。</p></div><p>关于硬件加速，可以关注我之前写的一篇文章：<a href="http://jartto.wang/2017/09/29/expand-on-performance-composite/">详谈层合成（composite）</a></p><p>3.使用动画<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jartto_demo</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">animation</span>: barrager <span class="number">5s</span> linear <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，我们通过三步实现了一个简单的弹幕动画。那么问题来了，弹幕都是随机位置，随机速度，随机颜色出现在屏幕上的，这个该如何实现呢？</p><p>4.随机弹幕出现位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> window_height = $(<span class="built_in">window</span>).height() - <span class="number">150</span>;</span><br><span class="line">bottom = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * window_height + <span class="number">40</span>);</span><br><span class="line">code = code.replace(<span class="string">"   bottom:&#123;bottom&#125;, //距离底部高度,单位px,默认随机 \n"</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><p>5.随机弹幕颜色<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">2</span> &lt;&lt; <span class="number">23</span>)).toString(<span class="number">16</span>)&#125;</span>`</span>; </span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// #6e8360</span></span><br></pre></td></tr></table></figure></p><div class="alert info"><p>好了，大功告成，我们顺手加上 Socket 事件监听。</p></div><p>6.事件监听<br>为了拿到用户发送过来的弹幕，我们需要做一个事件监听（接收服务端数据）：<br>首先，引入 <code>socket.io.js</code> 文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://&#123;jartto.ip&#125;/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'http://&#123;jartto.ip&#125;'</span>);</span><br><span class="line">socket.on(<span class="string">'server-push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'news message &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>, data.message);</span><br><span class="line">    run(data.message); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们监听到 <code>server-push</code> 事件的时候，<code>run</code> 函数就会初始化弹幕方法，随机生成一条弹幕，在屏幕滑过。</p><h4 id="五、发射器细节（核心代码）"><a href="#五、发射器细节（核心代码）" class="headerlink" title="五、发射器细节（核心代码）"></a>五、发射器细节（核心代码）</h4><p>发射器就非常简单了，我们使用 <code>Create React App</code> 初始化项目，在 <code>src/app.js</code> 中写入一个表单(这里以 <code>React</code> 为例，<code>Vue</code> 也是大同小异）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"app-box"</span>&gt;</span><br><span class="line">    &lt;div className=<span class="string">"form-box"</span>&gt;</span><br><span class="line">        &lt;Form.Item &#123;...formItemLayout&#125; label=<span class="string">""</span>&gt;</span><br><span class="line">        &#123;getFieldDecorator(<span class="string">'msg'</span>, &#123;</span><br><span class="line">            rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                required: <span class="literal">true</span>,</span><br><span class="line">                message: <span class="string">'请输入内容'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;)(<span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">"large"</span> <span class="attr">placeholder</span>=<span class="string">"发送消息，嗨起来～"</span> /&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line">        &lt;Form.Item &#123;...formTailLayout&#125; &gt;</span><br><span class="line">        &lt;Button className="btns"  shape="round" icon="close" size="large" onClick=&#123;this.cancle&#125;&gt;取消&lt;/Button&gt;</span><br><span class="line">        &lt;Button   type="primary" shape="round" icon="check" size="large" onClick=&#123;this.check&#125;&gt;发送&lt;/Button&gt;</span><br><span class="line">        &lt;/Form.Item&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>用户在输入框输入消息，向我们的服务器发送请求，很简单，就不赘述了。效果图可以参考下面：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/barrager/show.png" alt="Demo 效果图"></p><div class="alert warning"><p>请注意，此处为了演示效果，我将三端同框了。</p></div><h4 id="六、服务端细节（核心代码）"><a href="#六、服务端细节（核心代码）" class="headerlink" title="六、服务端细节（核心代码）"></a>六、服务端细节（核心代码）</h4><p>服务端比较简单，使用 <code>Express</code> 初始化一个 <code>Node</code> 项目，向 <code>app.js</code> 写入如下内容：<br>1.启动 <code>Socket</code> 服务：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">  bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>),</span><br><span class="line">  socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>),</span><br><span class="line">  fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">4000</span>;</span><br><span class="line"><span class="keyword">const</span> io = socket(app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`start on port <span class="subst">$&#123;PORT&#125;</span>`</span>)));</span><br></pre></td></tr></table></figure></p><p>2.监听 <code>Socket</code> 连接，接收用户发送数据，将数据写入本地 <code>JSON</code> 文件，并广播到 <code>server-push</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, sockets =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功！'</span>);</span><br><span class="line">  app.post(<span class="string">'/api/send'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(req.body);</span></span><br><span class="line">    <span class="keyword">let</span> info = <span class="built_in">JSON</span>.stringify(req.body.msg);</span><br><span class="line"></span><br><span class="line">    fs.writeFile(<span class="string">'./data/jartto.json'</span>, <span class="string">`<span class="subst">$&#123;info&#125;</span>,\n`</span>,</span><br><span class="line">    &#123;<span class="attr">flag</span>:<span class="string">'a'</span>,<span class="attr">encoding</span>:<span class="string">'utf-8'</span>,<span class="attr">mode</span>:<span class="string">'0666'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入失败'</span>);</span><br><span class="line">        res.status(<span class="number">500</span>).send(<span class="string">'Error'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sockets.broadcast.emit(<span class="string">'server-push'</span>, &#123; <span class="attr">message</span>: req.body.msg &#125;);</span><br><span class="line">        res.status(<span class="number">200</span>).send(<span class="string">'Done'</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">     &#125;) </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  sockets.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User Disconnected'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>3.当然，我们也可以存入数据库做持久化，以下演示存入 <code>MySQL</code> 核心代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, sockets =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功！'</span>);</span><br><span class="line">  app.post(<span class="string">'/api/send'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;ua, msg&#125; = req.body.msg;</span><br><span class="line">    req.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, cnt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> query = cnt.add(<span class="string">'INSERT INTO (ua, msg)'</span>, &#123;ua, msg&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"Error inserting : %s "</span>,err );</span><br><span class="line">          <span class="keyword">return</span> next(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sockets.broadcast.emit(<span class="string">'server-push'</span>, &#123; <span class="attr">message</span>: req.body.msg &#125;);</span><br><span class="line">        res.status(<span class="number">200</span>).send(<span class="string">'Done'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  sockets.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User Disconnected'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>4.启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></p><p>我们的服务端就启动起来了，访问地址是你的主机 <code>IP</code> 和 <code>4000</code> 端口。</p><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><p><a href="http://jartto.wang/2020/02/16/web-barrager/">本文</a>我们从零到一搭建了一个完整的弹幕方案，涉及到三部分：主屏，发射器和服务端，旨在为小伙伴们提供一套极简的设计思路。通过 <code>Demo</code> 我们可以简单的串联一个全栈项目，做更多有趣的事情。</p><p>文章最后，打个小广告吧。如果你想搭上在线教育的快车，快速成长，不妨加入我们。一起成长，一起学习，一起挑战更多有趣的事情，「跟谁学-高途课堂」欢迎你，请将简历私我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重大的活动现场一般离不开 &lt;code&gt;PPT&lt;/code&gt; 演示，可是如何有效和现场互动呢？这时候弹幕必不可少，静态的 &lt;code&gt;PPT&lt;/code&gt; 就略显乏力。有没有一种好的方案可以二者兼得呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="barrager" scheme="http://jartto.wang/tags/barrager/"/>
    
  </entry>
  
  <entry>
    <title>GitBook 和它有趣的插件</title>
    <link href="http://jartto.wang/2020/02/02/about-gitbook/"/>
    <id>http://jartto.wang/2020/02/02/about-gitbook/</id>
    <published>2020-02-02T07:20:03.000Z</published>
    <updated>2020-02-02T12:45:20.209Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多童鞋在日常开发中都会有「说明文档」、「学习笔记」和「个人博客」的需求，那么最经济简洁的方式莫过于 <code>GitBook</code> 方案了，<code>10</code> 分钟学习，永久使用。<br><a id="more"></a><br>本文将简单介绍 <code>GitBook</code> 的使用方式以及最佳插件搭配方案，快来运行一个与众不同而且免费托管的个人站点吧！</p><h4 id="一、安装与使用"><a href="#一、安装与使用" class="headerlink" title="一、安装与使用"></a>一、安装与使用</h4><p>1.<strong>安装 <code>GitBook</code> 插件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure></p><p>2.<strong>查看安装版本</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V</span><br></pre></td></tr></table></figure></p><p>控制台会输出如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jartto</span></span><br><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></p><p>3.<strong>初始化</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立项目：</span></span><br><span class="line">mkdir jartto-gitbook-demo</span><br><span class="line"><span class="comment"># 进入目录：</span></span><br><span class="line"><span class="built_in">cd</span> jartto-gitbook-demo</span><br><span class="line"><span class="comment"># 初始化：</span></span><br><span class="line">gitbook init</span><br></pre></td></tr></table></figure></p><p>此时，<code>jartto-gitbook-demo</code> 目录下会自动生成如下文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">└── SUMMARY.md</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure></p><p>4.<strong>启动</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure></p><p>5.<strong>访问站点</strong>：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo.png" alt="网站预览"></p><div class="alert success"><p>恭喜你，到这一步我们已经完成了基本版本。</p></div><p>更详细的操作，请查看如下文档：</p><ul><li><a href="https://www.gitbook.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">Github 地址</a></li><li><a href="https://docs.gitbook.com/resources/gitbook-legacy/v2-differences#plugins" target="_blank" rel="noopener">帮助文档</a></li></ul><h4 id="二、重点说明"><a href="#二、重点说明" class="headerlink" title="二、重点说明"></a>二、重点说明</h4><p>1.<strong>目录结构</strong><br>当我们运行 <code>gitbook serve</code> 后，<code>jartto-gitbook-demo</code> 目录下会生成一个 <code>_book</code> 文件夹：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── SUMMARY.md</span><br><span class="line">└── _book</span><br><span class="line">    ├── gitbook</span><br><span class="line">    ├── index.html</span><br><span class="line">    └── search_index.json</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure></p><p>2.<strong>关于 <code>README.md</code></strong><br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Introduction</span></span><br></pre></td></tr></table></figure></p><p>说明文档，大家应该都不陌生，就不赘述了。</p><p>3.<strong>关于 <code>SUMMARY.md</code></strong><br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Summary</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Introduction</span>](<span class="link">README.md</span>)</span><br></pre></td></tr></table></figure></p><p><code>SUMMARY.md</code> 其实就是书的章节目录，我们不妨稍作修改：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Jartto-GitBook-Demo</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">一、概要</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="code">    * [1.示例](README.md)</span></span><br><span class="line"><span class="code">    * [2.说明](README.md)</span></span><br><span class="line"><span class="code">    * [3.文档](README.md)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">二、高级</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="code">    * [1.配置](README.md)</span></span><br><span class="line"><span class="code">    * [2.插件](README.md)</span></span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo0.png" alt="演示目录"></p><h4 id="三、补充文档"><a href="#三、补充文档" class="headerlink" title="三、补充文档"></a>三、补充文档</h4><p>当然，<code>GitBook</code> 的远比我们想象的强大，我们还可以通过 <code>gitbook help</code> 来查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">build [book] [output]       build a book</span><br><span class="line">        --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line">        --format                Format to build to (Default is website; Values are website, json, ebook)</span><br><span class="line">        --[no-]timing           Print timing debug information (Default is <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">serve [book] [output]       serve the book as a website <span class="keyword">for</span> testing</span><br><span class="line">    --port                  Port <span class="keyword">for</span> server to listen on (Default is 4000)</span><br><span class="line">    --lrport                Port <span class="keyword">for</span> livereload server to listen on (Default is 35729)</span><br><span class="line">    --[no-]watch            Enable file watcher and live reloading (Default is <span class="literal">true</span>)</span><br><span class="line">    --[no-]live             Enable live reloading (Default is <span class="literal">true</span>)</span><br><span class="line">    --[no-]open             Enable opening book <span class="keyword">in</span> browser (Default is <span class="literal">false</span>)</span><br><span class="line">    --browser               Specify browser <span class="keyword">for</span> opening book (Default is )</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line">    --format                Format to build to (Default is website; Values are website, json, ebook)</span><br><span class="line"></span><br><span class="line">install [book]              install all plugins dependencies</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">parse [book]                parse and <span class="built_in">print</span> debug information about a book</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">init [book]                 setup and create files <span class="keyword">for</span> chapters</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">pdf [book] [output]         build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">epub [book] [output]        build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br><span class="line"></span><br><span class="line">mobi [book] [output]        build a book into an ebook file</span><br><span class="line">    --<span class="built_in">log</span>                   Minimum <span class="built_in">log</span> level to display (Default is info; Values are debug, info, warn, error, disabled)</span><br></pre></td></tr></table></figure></p><h4 id="四、有趣插件"><a href="#四、有趣插件" class="headerlink" title="四、有趣插件"></a>四、有趣插件</h4><p>了解上面的操作，使用 <code>GitBook</code> 已经没有任何障碍了。</p><div class="alert info"><p>如果你还想做一些个性化的操作，不妨继续深入。</p></div><p>要安装插架，需要我们有配置文件 <code>book.json</code>，我们可以在根目录下创建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch book.json</span><br></pre></td></tr></table></figure></p><p>写入基本配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Jartto-GitBook-Demo"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Jartto-GitBook-Demo"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"sphard"</span>,</span><br><span class="line">    <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">    <span class="attr">"root"</span>: <span class="string">"."</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"donate"</span>,</span><br><span class="line">        <span class="string">"github-buttons@2.1.0"</span>,</span><br><span class="line">        <span class="string">"edit-link"</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"donate"</span>: &#123;</span><br><span class="line">            <span class="attr">"wechat"</span>: <span class="string">"http://jartto.wang/images/wechatpay.jpg"</span>,</span><br><span class="line">            <span class="attr">"alipay"</span>: <span class="string">"http://jartto.wang/images/alipay.jpg"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"button"</span>: <span class="string">"打赏"</span>,</span><br><span class="line">            <span class="attr">"alipayText"</span>: <span class="string">"支付宝打赏"</span>,</span><br><span class="line">            <span class="attr">"wechatText"</span>: <span class="string">"微信打赏"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"github-buttons"</span>: &#123;</span><br><span class="line">            <span class="attr">"repo"</span>: <span class="string">"jartto/gitbook"</span>,</span><br><span class="line">            <span class="attr">"types"</span>: [</span><br><span class="line">                <span class="string">"star"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"size"</span>: <span class="string">"small"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"edit-link"</span>: &#123;</span><br><span class="line">            <span class="attr">"base"</span>: <span class="string">"https://github.com/jartto/gitbook/master"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Edit This Page"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插件安装通用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-plugin-[插件名]</span><br></pre></td></tr></table></figure></p><p>例如：我们要安装 <code>flexible-alerts</code> 信息框插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-plugin-flexible-alerts</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/plugin.png" alt="信息框插件"></p><p>还有很多可用插件，具体如下：</p><ol><li>信息框(<code>flexible-alerts</code>)</li><li>阅读统计（<code>pageview-count</code>）</li><li>侧边栏宽度可调节（<code>splitter</code>）</li><li>页脚版权（<code>page-copyright</code>）</li><li>打赏功能（<code>donate</code>）</li><li>分享当前页面（<code>sharing-plus</code>）</li><li>修改标题栏图标（<code>custom-favicon</code>）</li><li>复选框（<code>todo</code>）</li><li>显示图片名称（<code>image-captions</code>）</li><li>目录折叠（<code>toggle-chapters</code>）</li><li>分章节展示（<code>multipart</code>）</li><li>插入 <code>Logo</code>（<code>insert-logo</code>）</li><li><code>Google</code> 分析（<code>ga</code>）</li><li>返回顶部（<code>back-to-top-button</code>）</li><li>代码添加行号和复制按钮（<code>code</code>）</li><li>高级搜索，支持中文（<code>search-pro</code>）</li><li>添加 <code>Github</code> 图标（<code>github</code>）<br>…</li></ol><p>需要注意的是：<br><code>GitBook</code> 默认带有 <code>5</code> 个插件：</p><ul><li><code>highlight</code></li><li><code>search</code></li><li><code>sharing</code></li><li><code>fontsettings</code></li><li><code>livereload</code></li></ul><p>如果要去除自带的插件，可以在插件名称前面加 <code>-</code>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;:[</span><br><span class="line">    &quot;-search&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>小技巧：<code>NPM</code> 中搜索关键字 <a href="https://www.npmjs.com/search?q=gitbook-plugin" target="_blank" rel="noopener"><code>GitBook-Plugin</code></a>，发现更多插件。</p><h4 id="五、效果展示"><a href="#五、效果展示" class="headerlink" title="五、效果展示"></a>五、效果展示</h4><p>1.<code>GitBook</code> 扩展：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/gitbook1.png" alt="扩展 GitBook"></p><p>2.示例一：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo1.png" alt="示例一"></p><p>3.示例二：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo2.png" alt="示例二"></p><p>4.示例三：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/gitbook/demo3.png" alt="示例三"></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p><a href="http://jartto.wang/2020/02/02/about-gitbook/">上文</a>介绍了 <code>GitBook</code> 的基本使用和一些实用插件，构建在线文档变得轻而易举。加上 <code>Github</code> 免费的托管平台，我们就可以干更多有趣的事情了。快输出你的 <code>HTML</code>、<code>PDF</code>、<code>eBook</code> 技术文档吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多童鞋在日常开发中都会有「说明文档」、「学习笔记」和「个人博客」的需求，那么最经济简洁的方式莫过于 &lt;code&gt;GitBook&lt;/code&gt; 方案了，&lt;code&gt;10&lt;/code&gt; 分钟学习，永久使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="plugin" scheme="http://jartto.wang/tags/plugin/"/>
    
      <category term="gitbook" scheme="http://jartto.wang/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>系统负载看不懂？</title>
    <link href="http://jartto.wang/2020/01/20/system-load/"/>
    <id>http://jartto.wang/2020/01/20/system-load/</id>
    <published>2020-01-20T02:54:40.000Z</published>
    <updated>2020-01-20T08:43:27.278Z</updated>
    
    <content type="html"><![CDATA[<p>Web 开发会经历「开发-上线-部署」三个过程，部署之后站点的运行状态如何却鲜有关注。如果我们要估算网站能承受多大的并发，你可能需要真正了解系统负载。<br><a id="more"></a></p><h4 id="一、先看场景"><a href="#一、先看场景" class="headerlink" title="一、先看场景"></a>一、先看场景</h4><p>1.服务器状态（<code>Linux</code> 服务器通过 <code>Top</code> 命令查看）<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/linux/system-load.png" alt="服务器状态"></p><p>2.数据监控<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/linux/load-avg.png" alt="平均负载"></p><p>上面是两个典型应用场景，我们可以直接在服务器查看系统负载。当然，也可以获取数据本地可视化显示。听起来不错，可是问题来了：</p><p>Q1：<code>load average</code>: 0.03, 0.12, 0.07 是什么？<br>Q2：为什么同时监控 1 分钟，5 分钟，15 分钟？</p><p>如果你对此有疑问，不妨继续阅读。</p><h4 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h4><div class="alert info"><p>为了便于理解，我们从「一个比喻」，「两个概念」和「三个边界」来说明。</p></div><p>1.<strong>一个比喻</strong><br>我们可以把 <code>CPU</code> 比喻成一条马路，进程任务就是马路上飞驰的汽车，<code>Load</code> 则表示马路的拥挤程度。</p><p>2.<strong>两个概念</strong><br>系统负载（System Load）：<br>系统 <code>CPU</code> 繁忙程度的度量，即有多少进程在等待被 <code>CPU</code> 调度（进程等待队列的长度）。</p><p>平均负载（Load Average）：<br>一段时间内系统的平均负载，这个一段时间一般取 1 分钟、5 分钟、15 分钟。</p><p>3.<strong>三个边界</strong><br>Load = 0，路上一辆车也没有；<br>Load = 0.7，一大半路上有车；<br>Load = 1，所有路段都有车，基本饱和状态，但是道路仍然能够通行；</p><p>阮一峰老师<a href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">理解 Linux 系统负荷</a>中举的这个例子很形象：</p><ul><li>系统负荷为 1.7，意味着车辆太多了，桥已经被占满了（100%），后面等着上桥的车辆为路面车辆的 70%。</li><li>系统负荷 2.0，意味着等待上桥的车辆与桥面的车辆一样多；</li><li>系统负荷 3.0，意味着等待上桥的车辆是桥面车辆的 2 倍。</li></ul><p>总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。</p><div class="alert success"><p>道路的通行能力，就是 <code>CPU</code> 的最大工作量；道路上的车辆，就是一个个等待 <code>CPU</code> 处理的进程（<code>Process</code>）。</p></div><h4 id="三、多核负载如何计算？"><a href="#三、多核负载如何计算？" class="headerlink" title="三、多核负载如何计算？"></a>三、多核负载如何计算？</h4><p>上文我们不管是路还是桥的例子，都是默认电脑只有一个 <code>CPU</code>，那如果多 <code>CPU</code>，情况又是如何呢？</p><div class="alert success"><p>很简单，<code>2</code> 个 <code>CPU</code>，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍。</p></div><p><code>2</code> 个 <code>CPU</code> 表明系统负载可以达到 <code>2.0</code>，此时每个 <code>CPU</code> 都达到 <code>100%</code> 的工作量。如果你的服务器是 <code>4</code> 核 <code>CPU</code>，那么系统负载极限就是 <code>4.0</code>。</p><h4 id="四、答题时间"><a href="#四、答题时间" class="headerlink" title="四、答题时间"></a>四、答题时间</h4><p>到这里，相信我们的 <code>Q1</code> 问题已经解决了。我们重点来看 <code>Q2</code>：为什么同时监控 <code>1</code> 分钟，<code>5</code> 分钟，<code>15</code> 分钟？</p><p><a href="https://www.w3cschool.cn/architectroad/architectroad-loadaverage.html" target="_blank" rel="noopener">一分钟理解负载 LoadAverage </a> 中有很好的解释：</p><ul><li>Load &lt; 0.7时：系统很闲，马路上没什么车，要考虑多部署一些服务</li><li>0.7 &lt; Load &lt; 1时：系统状态不错，马路可以轻松应对</li><li>Load == 1时：系统马上要处理不多来了，赶紧找一下原因</li><li>Load &gt; 5时：马路已经非常繁忙了，进入马路的每辆汽车都要无法很快的运行</li></ul><p>那么如果按照 1 分钟来评估系统负载，会被系统短暂的抖动所影响。</p><div class="alert success"><p>所以 1 分钟更多是作为一个参考度量，综合 5 分钟和 10 分钟使监控指标更加准确。</p></div><p>1 分钟 Load &gt; 5，5 分钟 Load &lt; 1，15 分钟 Load &lt; 1<br>短期内繁忙，中长期空闲，初步判断是一个「抖动」或者是「拥塞前兆」</p><p>1 分钟 Load &gt; 5，5 分钟 Load &gt; 1，15 分钟 Load &lt; 1<br>短期内繁忙，中期内紧张，很可能是一个「拥塞的开始」</p><p>1 分钟 Load &gt; 5，5 分钟 Load &gt; 5，15 分钟 Load &gt; 5<br>短中长期都繁忙，系统「正在拥塞」</p><p>1 分钟 Load &lt; 1，5 分钟 Load &gt; 1，15 分钟 Load &gt; 5：<br>短期内空闲，中长期繁忙，不用紧张，系统「拥塞正在好转」</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 开发会经历「开发-上线-部署」三个过程，部署之后站点的运行状态如何却鲜有关注。如果我们要估算网站能承受多大的并发，你可能需要真正了解系统负载。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="linux" scheme="http://jartto.wang/tags/linux/"/>
    
      <category term="load" scheme="http://jartto.wang/tags/load/"/>
    
      <category term="system" scheme="http://jartto.wang/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>人工智能时代，Web 前端能做什么？</title>
    <link href="http://jartto.wang/2020/01/01/web-ai/"/>
    <id>http://jartto.wang/2020/01/01/web-ai/</id>
    <published>2020-01-01T14:07:24.000Z</published>
    <updated>2020-01-05T15:42:42.529Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个项目，通过爬虫去抓取页面快照，然后对页面兼容性进行全面测试。但是遇到一个问题，抓取到海量页面之后，难道还要人工去分析吗？<br><a id="more"></a><br>类似的场景并不会少，是否可以让机器去帮我们实现，最终输出一个可靠报告？答案是肯定的，快照生成后，我们可以对大量快照进行分析，结合 OpenCV 跨平台计算机视觉库，实现图像处理和计算机视觉方面的数据分析，最终输出结果。</p><div class="alert success"><p>我们总会找到一些合适的场景用机器来代替人，而 AI 正是这个支点。</p></div><p>AI 如果是这个时代的契机，那么作为 Web 前端，在这人工智能时代，我们能做什么？</p><h4 id="一、什么是人工智能？"><a href="#一、什么是人工智能？" class="headerlink" title="一、什么是人工智能？"></a>一、什么是人工智能？</h4><p>人工智能（Artificial Intelligence），英文缩写为 AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p><p>1.计算机科学<br>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。</p><p>2.智慧「容器」<br>人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的「容器」。</p><p>3.信息加工<br>人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>4.研究目标<br>人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，总的说来，人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。</p><h4 id="二、有哪些场景会涉及到-AI？"><a href="#二、有哪些场景会涉及到-AI？" class="headerlink" title="二、有哪些场景会涉及到 AI？"></a>二、有哪些场景会涉及到 AI？</h4><p>如果要列举一下有哪些场景会用到 AI，我想可能不仅仅是如下这些：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/ai.png" alt="ai"></p><p>机器视觉，指纹识别，人脸识别，人脸对比，手势检测，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程，物体检测，视频跟踪等。</p><div class="alert info"><p>人工智能就其本质而言，是对人的思维的信息过程的模拟。</p></div><p>对于人的思维模拟可以从两条道路进行，<br>1.结构模拟，仿照人脑的结构机制，制造出「类人脑」的机器；<br>2.是功能模拟，暂时撇开人脑的内部结构，而从其功能过程进行模拟。<br>现代电子计算机的产生便是对人脑思维功能的模拟，是对人脑思维的信息过程的模拟。</p><h4 id="三、弱人工智能，强人工智能"><a href="#三、弱人工智能，强人工智能" class="headerlink" title="三、弱人工智能，强人工智能"></a>三、弱人工智能，强人工智能</h4><p>弱人工智能如今不断地迅猛发展，尤其是 2008 年经济危机后，美日欧希望借机器人等实现再工业化，工业机器人以比以往任何时候更快的速度发展，更加带动了弱人工智能和相关领域产业的不断突破，很多必须用人来做的工作如今已经能用机器人实现。</p><div class="alert danger"><p>强人工智能则暂时处于瓶颈，还需要科学家们和人类的努力。</p></div><p>人工智能是依赖机器学习的，<strong>数据和算法是机器学习的核心</strong>，而数据更为重要。按照解决问题的能力，我们可以把人工智能，分成两类：</p><ul><li>强人工智能：拥有自我意识，具备解决通用问题的能力</li><li>弱人工智能：没有自我意识，具备解决特定问题的能力</li></ul><p>目前，我们能看到的人工智能，几乎都是弱人工智能，在解决特定问题的能力上，超越了人类。</p><h4 id="四、AI-如何影响前端"><a href="#四、AI-如何影响前端" class="headerlink" title="四、AI 如何影响前端"></a>四、AI 如何影响前端</h4><p>1.数据可视化，依赖 <code>D3.js</code>，<code>ECharts</code>，<code>WebGL</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/kael.png" alt="kael"></p><p>2.模型可视化<br>用可视化的手段去解释模型，辅助算法同学调参。最简单的一个应用前端同学肯定非常熟悉，我们来看下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/dev.png" alt="chrome-dev"></p><p>是的，曲线函数和曲率我们很难记住，但是有相应的工具，会让一些<strong>数据和计算变得简单易懂</strong>。</p><p>3.相关技术<br>提到人工智能，和前端密切相关的几个 <code>JS</code> 类库有：</p><ul><li>tensorflow.js<br>基于 <code>tensorflow.js Node</code> 的 <code>tvnet</code> 算法，可以提取视频中的稠密光流。</li><li>deeplearning.js</li><li>kera.js</li></ul><p>高性能计算：</p><ul><li>asm.js</li><li>WebAssembly</li><li>GPU</li><li>Opencv，前端做 CV 算法，物体跟踪、图像处理、特征检测等等</li></ul><p>大家可能发现一个问题，一般的 <code>tensorflow</code> 模型动辄几百兆，在前端怎么跑呢？这就不得不提到 <code>MobileNet</code>，这是针对于移动端模型提出的神经网络架构，能极大地减少模型参数量，同理也能用到浏览器端上。</p><p>更多细节可以查看该文章：<a href="https://www.jianshu.com/p/e5f997713a4b" target="_blank" rel="noopener">前端与人工智能</a>，介绍非常到位。</p><h4 id="五、如何做？"><a href="#五、如何做？" class="headerlink" title="五、如何做？"></a>五、如何做？</h4><p>既然前端和人工智能有如此多的交集，那么我们该从何做起呢？不要着急，我们先来看一个完整的人工智能项目包含哪些内容。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/aiweb.png" alt="aiweb"></p><p>上图中，可以看到一个完整的人工智能项目是由：算法，数据，工程三部分构成。</p><p>工程部分我们可以理解为「大前端」，主要包含 5 部分：</p><ol><li>人机交互</li><li>数据可视化</li><li>产品 Web</li><li>算法执行</li><li>模型训练</li></ol><h4 id="六、简单应用"><a href="#六、简单应用" class="headerlink" title="六、简单应用"></a>六、简单应用</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/face.png" alt="pic"><br>1.<code>Tranck.js</code><br>就是纯浏览器的图像算法库，通过 <code>JS</code> 计算来执行算法逻辑</p><p>2.<code>regl-cnn</code><br>浏览器端的数字识别类库，与 <code>track.js</code> 不同的是，它利用浏览器的 <code>WebGL</code> 才操作 <code>GPU</code>，实现了 <code>CNN</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/cnn.gif" alt="cnn"></p><p>3.<code>ConvNetJS</code><br>浏览器端做深度学习算法训练的工具，<a href="https://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="noopener">官网地址</a></p><p>4.<code>Amazon Rekognition</code><br>基于同样由 <code>Amazon</code> 计算机视觉科学家开发的成熟且高度可扩展的深度学习技术，每天能够分析数十亿张 <code>Prime Photos</code> 图像。</p><p>5.对比学习：<code>Keras</code> 搭建 <code>CNN</code>，<code>RNN</code> 等常用神经网络</p><p>6.机器学习：<a href="https://github.com/wepe/MachineLearning" target="_blank" rel="noopener">MachineLearning</a></p><p>更多内容可以查看：<br>1.<a href="http://www.bslxx.com/m/view.php?aid=1922" target="_blank" rel="noopener">浏览器里运行的人工智能</a><br>2.<a href="https://yq.aliyun.com/articles/153198?t=t1" target="_blank" rel="noopener">前端在人工智能时代能做些什么</a></p><h4 id="七、深度学习"><a href="#七、深度学习" class="headerlink" title="七、深度学习"></a>七、深度学习</h4><p>深度学习，是英文 <code>Deep Learning</code> 的直译。它是实现机器学习的其中一种方式。机器学习还包含其它实现方案。</p><p>深度学习里，用到了人工神经网络，这是一个用计算机模拟大脑神经元运作模式的算法。同时，这个人工神经网络的隐藏层数量还必须足够多，才能构成深度神经网络。然后喂之以大量的训练数据，就是深度学习了。</p><p>换一个角度，如果隐藏层数量不多，而是每个隐藏层里包含的神经元数量很多，在形态上，它就是一个往宽度发展的神经网络结构。这时，可能就叫广度学习了。</p><div class="alert success"><p>目前，深度学习还是主流，它的训练效率，优于广度学习。</p></div><p>我们可以体验腾讯的一个深度学习案例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ai/ml.png" alt="pic"></p><p>更多有趣应用：<br>1.<a href="https://www.jianshu.com/p/1b33e432ba0e" target="_blank" rel="noopener"><code>TensorFlowJS</code> 学习</a><br>2.如何利用 <code>TensorFlow.js</code> 部署简单的 <a href="https://baijiahao.baidu.com/s?id=1606694239390920783&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener"><code>AI</code> 版「你画我猜」图像识别应用</a></p><h4 id="八、明确几个概念"><a href="#八、明确几个概念" class="headerlink" title="八、明确几个概念"></a>八、明确几个概念</h4><p>机器学习对我们来说确实陌生，所以一定要从明确一些常用的概念，这样才能提升学习的兴趣。我们来说一些可能会涉及到的内容（我也是正在摸索，目前就知道这些，逃～）</p><p>1.<strong>精确率</strong><br>是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。</p><p>2.<strong>召回率</strong><br>是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了</p><p>3.<strong>监督学习</strong><br>监督学习涉及到标注数据，计算机可以使用所提供的数据来识别新的样本。<br>监督学习的两种主要类型是分类和回归。在分类中，训练的机器将把一组数据分成特定的类。</p><p>4.<strong>无监督学习</strong><br>在无监督学习中，数据是未标注的。由于现实中，大多数的数据都是未标注的，因此这些算法特别有用。<br>无监督学习分为聚类和降维。</p><p>5.<strong>强化学习</strong><br>强化学习使用机器的历史和经验来做出决策。强化学习的经典应用是游戏。与监督和无监督学习相反，强化学习不注重提供「正确」的答案或输出。</p><h4 id="九、机器学习算法有哪些？"><a href="#九、机器学习算法有哪些？" class="headerlink" title="九、机器学习算法有哪些？"></a>九、机器学习算法有哪些？</h4><p>提到机器学习，大家肯定都会自然联想到需要很强的<strong>算法功底</strong>。没错，确实如此，所以我们需要对算法有一些了解。</p><p>那么<a href="https://www.cnblogs.com/xiyushimei/p/7874019.html" target="_blank" rel="noopener">机器学习</a>主要涉及到哪几类算法呢，我们来看看：</p><ul><li>模式识别</li><li>计算机视觉</li><li>数据挖掘</li><li>统计学习</li><li>语音识别</li><li>自然语言处理</li></ul><h4 id="九、机器学习涉及学科"><a href="#九、机器学习涉及学科" class="headerlink" title="九、机器学习涉及学科"></a>九、机器学习涉及学科</h4><div class="alert info"><p>主要围绕在这几方面：线性代数、微积分、概率和统计。</p></div><p>线性代数概念Top 3：</p><ol><li>矩阵运算</li><li>特征值/特征向量</li><li>向量空间和范数</li></ol><p>微积分概念Top 3：</p><ol><li>偏导数</li><li>向量值函数</li><li>方向梯度</li></ol><p>统计概念Top 3：</p><ol><li>贝叶斯定理</li><li>组合学</li><li>抽样方法</li></ol><h4 id="十、计算机视觉"><a href="#十、计算机视觉" class="headerlink" title="十、计算机视觉"></a>十、计算机视觉</h4><p><code>OpenCV</code> 是一个基于 <code>BSD</code> 许可（开源）发行的跨平台计算机视觉库，可以运行在 <code>Linux</code>、<code>Windows</code>、<code>Android</code> 和 <code>Mac OS</code> 操作系统上。</p><p>它轻量级而且高效——由一系列 <code>C</code> 函数和少量 <code>C++</code> 类构成，同时提供了 <code>Python</code>、<code>Ruby</code>、<code>MATLAB</code> 等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。</p><p>应用领域：<br>1、人机互动<br>2、物体识别<br>3、图像分割<br>4、人脸识别<br>5、动作识别<br>6、运动跟踪<br>7、机器人<br>8、运动分析<br>9、机器视觉<br>10、结构分析<br>11、汽车安全驾驶</p><p><code>OpenCV</code> 的应用领域非常广泛，包括图像拼接、图像降噪、产品质检、人机交互、人脸识别、动作识别、动作跟踪、无人驾驶等。</p><p><code>OpenCV</code> 还提供了机器学习模块，你可以使用正态贝叶斯、K最近邻、支持向量机、决策树、随机森林、人工神经网络等机器学习算法。</p><p>这里推荐几个相关学习网站：<br>1.<a href="https://opencv.org" target="_blank" rel="noopener">官网</a><br>2.<a href="http://c.biancheng.net/opencv/" target="_blank" rel="noopener">OpenCV教程</a><br>3.<a href="https://www.cnblogs.com/wangyaning/p/7854046.html" target="_blank" rel="noopener">图像对比</a></p><h4 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h4><p><code>AI</code> 涉及到很多的领域，并不是我们三言两语就能够说的明白。要真正的应用起来，还有很多的路要走。我相信，随着技术的发展，更多的场景将接入 <code>AI</code>，而 <code>Web</code> 则是其中的一个重要环节。加上 <code>Web</code> 跨平台特性，以及「算法-数据-工程」的驱动，未来在该领域一定会大放异彩。</p><p>很喜欢这句话：AI makes life better. FE makes AI better.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个项目，通过爬虫去抓取页面快照，然后对页面兼容性进行全面测试。但是遇到一个问题，抓取到海量页面之后，难道还要人工去分析吗？&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="ai" scheme="http://jartto.wang/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>CSS 渲染原理以及优化策略</title>
    <link href="http://jartto.wang/2019/10/23/css-theory-and-optimization/"/>
    <id>http://jartto.wang/2019/10/23/css-theory-and-optimization/</id>
    <published>2019-10-23T13:04:53.000Z</published>
    <updated>2019-11-07T08:24:53.762Z</updated>
    
    <content type="html"><![CDATA[<p>提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。<br><a id="more"></a><br>我们先来看看这张排行榜：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/rank.png" alt="Rank"></p><div class="alert info"><p>既然 CSS 这么重要，那么我们花点时间来研究相关原理也就物有所值了。</p></div><p>本节我们就来说说 CSS <strong>渲染以及优化</strong>相关的内容，主要围绕以下几点，由浅入深，了解来龙去脉：</p><p>1.浏览器构成<br>2.渲染引擎<br>3.CSS 特性<br>4.CSS 语法解析过程<br>5.CSS 选择器执行顺序<br>6.高效的 ComputedStyle<br>7.CSS 书写顺序对性能有影响吗<br>8.优化策略</p><h4 id="一、浏览器构成"><a href="#一、浏览器构成" class="headerlink" title="一、浏览器构成"></a>一、浏览器构成</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/browser.png" alt="Browser"></p><ul><li><p>User Interface：<br>用户界面，包括浏览器中可见的地址输入框、浏览器前进返回按钮、书签，历史记录等用户可操作的功能选项。</p></li><li><p>Browser engine：<br>浏览器引擎，可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据，是浏览器各个部分之间相互通信的核心。</p></li><li><p>Rendering engine：<br>渲染引擎，解析 DOM 文档和 CSS 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。</p></li><li><p>Networking：<br>网络功能模块，是浏览器开启网络线程发送请求以及下载资源的模块。</p></li><li><p>JavaScript Interpreter：<br>JS 引擎，解释和执行 JS 脚本部分，例如 V8 引擎。</p></li><li><p>UI Backend：<br>UI 后端则是用于绘制基本的浏览器窗口内控件，比如组合选择框、按钮、输入框等。</p></li><li><p>Data Persistence：<br>数据持久化存储，涉及 Cookie、LocalStorage 等一些客户端存储技术，可以通过浏览器引擎提供的 API 进行调用。</p></li></ul><!-- ![Render](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render.png) --><h4 id="二、渲染引擎"><a href="#二、渲染引擎" class="headerlink" title="二、渲染引擎"></a>二、渲染引擎</h4><p>渲染引擎，解析 <code>DOM</code> 文档和 <code>CSS</code> 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render2.png" alt="Render2"></p><p>上图中，我们需要关注两条主线：<br>其一，<code>HTML Parser</code> 生成的 <code>DOM</code> 树；<br>其二，<code>CSS Parser</code> 生成的 <code>Style Rules</code> ；</p><p>在这之后，<code>DOM</code> 树与 <code>Style Rules</code> 会生成一个新的对象，也就是我们常说的 <code>Render Tree</code> 渲染树，结合 <code>Layout</code> 绘制在屏幕上，从而展现出来。</p><h4 id="三、CSS-特性"><a href="#三、CSS-特性" class="headerlink" title="三、CSS 特性"></a>三、CSS 特性</h4><p>1.<strong>优先级</strong>：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/specificity1.png" alt="specificity1"><br>!important &gt; 行内样式（权重1000） &gt; ID 选择器（权重 100） &gt; 类选择器（权重 10） &gt; 标签（权重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><p>示例代码一：<a href="https://jsfiddle.net/a5xtdoq7/1/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/1/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>: yellow;&#125;</span><br></pre></td></tr></table></figure></p><p>猜一猜，文本会显示什么颜色？当你知道 「<code>ID</code> 选择器 &gt; 类选择器 」的时候，答案不言自明。</p><p>升级一下：<a href="https://jsfiddle.net/a5xtdoq7/3/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/3/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>: blue;&#125;</span><br></pre></td></tr></table></figure></p><p>这里就考查到了规则「类选择器 &gt; 继承」，<code>ID</code> 对文本来说是继承过来的属性，所以优先级不如直接作用在元素上面的类选择器。</p><p>2.<strong>继承性</strong></p><ul><li>继承得到的样式的优先级是最低的，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值；</li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级；</li></ul><p>有哪些属性是可以<a href="https://m.html.cn/qa/css3/12784.html" target="_blank" rel="noopener">继承</a>的呢，我们简单分一下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.font-family,font-size,font-weight 等 f 开头的 CSS 样式；</span><br><span class="line">2.text-align,text-indent 等 t 开头的样式；</span><br><span class="line">3.color；</span><br></pre></td></tr></table></figure></p><p>详细的规则，请看下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/inherent.png" alt="inherent"></p><p>示例代码二：<a href="https://jsfiddle.net/a5xtdoq7/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则定义如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red<span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-tag">ol</span> &#123; <span class="attribute">color </span>: green; &#125;</span><br></pre></td></tr></table></figure></p><p>增加了 <code>!important</code> ，猜一猜，文本显示什么颜色？</p><p>3.<strong>层叠性</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/specificity2.png" alt="specificity2"><br>层叠就是浏览器对多个样式来源进行叠加，最终确定结果的过程。<code>CSS</code> 之所以有「层叠」的概念，是因为有多个样式来源。</p><p><code>CSS</code> 层叠性是指 <code>CSS</code> 样式在针对同一元素配置同一属性时，<strong>依据层叠规则（权重）来处理冲突</strong>，选择应用权重高的 <code>CSS</code> 选择器所指定的属性，一般也被描述为权重高的覆盖权重低的，因此也称作层叠。</p><p>示例代码三：<a href="https://jsfiddle.net/a5xtdoq7/2/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/2/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"two one"</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;<span class="attribute">color</span>: blue;&#125;</span><br></pre></td></tr></table></figure></p><p>如果两个类选择器同时作用呢，究竟以谁为准？这里我们要考虑样式表中两个类选择器的先后顺序，后面的会覆盖前面的，所以文本当然显示蓝色了。</p><p>升级代码：<a href="https://jsfiddle.net/a5xtdoq7/6/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/6/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Jartto's blog<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: yellow; &#125;</span><br></pre></td></tr></table></figure></p><p>这个比较直接，算一下权重，谁大听谁的。</p><p>继续升级：<a href="https://jsfiddle.net/a5xtdoq7/7/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/7/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> <span class="selector-class">.two</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-id">#box3</span> &#123; <span class="attribute">color </span>: yellow; &#125;</span><br><span class="line"><span class="selector-id">#box1</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: blue; &#125;</span><br></pre></td></tr></table></figure></p><p>权重：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 2 1</span><br><span class="line">0 1 0 1</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure></p><p>验证一下：<a href="https://jsfiddle.net/a5xtdoq7/9/" target="_blank" rel="noopener">https://jsfiddle.net/a5xtdoq7/9/</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box3"</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span> Jartto's blog <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> <span class="selector-class">.two</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: red; &#125;</span><br><span class="line"><span class="selector-id">#box1</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color </span>: blue; &#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-class">.three</span> &#123; <span class="attribute">color </span>: green; &#125;</span><br></pre></td></tr></table></figure></p><p>权重：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 2 1</span><br><span class="line">0 1 0 1</span><br><span class="line">0 0 1 1</span><br></pre></td></tr></table></figure></p><p>如果你对上面这些问题都了如指掌，那么恭喜你，基础部分顺利过关，可以继续升级了！</p><h4 id="四、CSS-语法解析过程"><a href="#四、CSS-语法解析过程" class="headerlink" title="四、CSS 语法解析过程"></a>四、CSS 语法解析过程</h4><p>1.我们来把 <code>CSS</code> 拎出来看一下，<code>HTML Parser</code> 会生成 <code>DOM</code> 树，而 <code>CSS Parser</code> 会将解析结果附加到 <code>DOM</code> 树上，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/render3.png" alt="render3"></p><p>2.<code>CSS</code> 有自己的规则，一般如下：<br><code>WebKit</code> 使用 <code>Flex</code> 和 <code>Bison</code> 解析器生成器，通过 <code>CSS</code> 语法文件自动创建解析器。<code>Bison</code> 会创建自下而上的移位归约解析器。<code>Firefox</code> 使用的是人工编写的自上而下的解析器。</p><p>这两种解析器都会将 <code>CSS</code> 文件解析成 <code>StyleSheet</code> 对象，且每个对象都包含 <code>CSS</code> 规则。<code>CSS</code> 规则对象则包含选择器和声明对象，以及其他与 <code>CSS</code> 语法对应的对象。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/css-rule.jpg" alt="css-rule"></p><p>3.<code>CSS</code> 解析过程会按照 <code>Rule</code>，<code>Declaration</code> 来操作：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/test_CSSOM.png" alt="CSSOM"></p><p>4.那么他是如何解析的呢，我们不妨打印一下 <code>CSS Rules</code>：<br>控制台输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].cssRules</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/rule2.png" alt="rule2"></p><p>打印出来的结果大致分为几类：</p><ul><li>cssText：存储当前节点规则字符串</li><li>parentRule：父节点的规则</li><li>parentStyleSheet：包含 cssRules，ownerNode，rules 规则</li><li>…</li></ul><div class="alert danger"><p>规则貌似有点看不懂，不用着急，我们接着往下看。</p></div><p>5.CSS 解析和 Webkit 有什么关系？<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/webkit2.png" alt="webkit2"><br><div class="alert info"><p>CSS 依赖 WebCore 来解析，而 WebCore 又是 Webkit 非常重要的一个模块。</p></div></p><p>要了解 <code>WebCore</code> 是如何解析的，我们需要查看<a href="https://github.com/WebKit/webkit/tree/master/Source/WebCore/css" target="_blank" rel="noopener">相关源码</a>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CSSRule* CSSParser::createStyleRule(CSSSelector* selector)  </span><br><span class="line">&#123;  </span><br><span class="line">    CSSStyleRule* rule = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (selector) &#123;  </span><br><span class="line">        rule = <span class="keyword">new</span> CSSStyleRule(styleElement);  </span><br><span class="line">        m_parsedStyleObjects.append(rule);  </span><br><span class="line">        rule-&gt;setSelector(sinkFloatingSelector(selector));  </span><br><span class="line">        rule-&gt;setDeclaration(<span class="keyword">new</span> CSSMutableStyleDeclaration(rule, parsedProperties, numParsedProperties));  </span><br><span class="line">    &#125;  </span><br><span class="line">    clearProperties();  </span><br><span class="line">    <span class="keyword">return</span> rule;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从该函数的实现可以很清楚的看到，解析器达到某条件需要创建一个 <code>CSSStyleRule</code> 的时候将调用该函数，该函数的功能是创建一个 <code>CSSStyleRule</code> ，并将其添加已解析的样式对象列表 <code>m_parsedStyleObjects</code> 中去，这里的对象就是指的 <code>Rule</code> 。</p><div class="alert warning"><p>注意：源码是为了参考理解，不需要逐行阅读！</p></div><p><code>Webkit</code> 使用了自动代码生成工具生成了相应的代码，也就是说词法分析和语法分析这部分代码是自动生成的，而 <code>Webkit</code> 中实现的 <code>CallBack</code> 函数就是在 <code>CSSParser</code> 中。</p><p>这时候就不得不提到 <code>AST</code> 了，我们继续剖析。</p><p>补充阅读：<a href="https://webkit.org/status/#?search=css" target="_blank" rel="noopener">Webkit 对 CSS 支持</a></p><p>6.<strong>关于 AST</strong><br>如果对 <code>AST</code> 还不了解，请移步<a href="http://jartto.wang/2018/11/17/about-ast/"><code>AST</code> 抽象语法树</a>。这里我们不做过多解释，主要围绕如何解析这一过程展开，先来看一张 <code>Babel</code> 转换过程图：</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/ast1.png" alt="ast1"></p><p>我们来举一个简单的例子，声明一个箭头函数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jarttoTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<a href="https://astexplorer.net/" target="_blank" rel="noopener">在线编译</a>，生成如下结果：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/css/ast2.png" alt="ast2"></p><p>从<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上图</a>我们可以看出：我们的箭头函数被解析成了一段标准代码，包含了类型，起始位置，结束位置，变量声明的类型，变量名，函数名，箭头函数表达式等等。</p><p>标准的解析代码，我们可以对其进行一些加工和处理，之后通过相应 <code>API</code> 输出。很多场景都会用到这个过程，如：</p><ul><li>JS 反编译，语法解析</li><li>Babel 编译 ES6 语法</li><li>代码高亮</li><li>关键字匹配</li><li>作用域判断</li><li>代码压缩</li><li>…</li></ul><p>场景千千万，但是都离不开一个过程，那就是：<br><div class="alert info"><p>AST 转换过程：解析 - 转换 - 生成</p></div></p><p>到这里，<code>CSS</code> 如何解析的来龙去脉我们已经非常清楚了，可以回到<a href="#">文章</a>开头的那个流程图了，相信你一定会有另一翻感悟。</p><h4 id="五、CSS-选择器执行顺序"><a href="#五、CSS-选择器执行顺序" class="headerlink" title="五、CSS 选择器执行顺序"></a>五、CSS 选择器执行顺序</h4><p>渲染引擎解析 <code>CSS</code> 选择器时是从右往左解析，这是为什么呢？举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.jartto</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.yellow</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们按照「从左到右」的方式进行分析：<br>1.先找到所有 <code>div</code> 节点；<br>2.在 <code>div</code> 节点内找到所有的子 <code>div</code> ,并且是 <code>class = “jartto”</code>；<br>3.然后再依次匹配 <code>p span.yellow</code> 等情况；<br>4.遇到不匹配的情况，就必须回溯到一开始搜索的 <code>div</code> 或者 <code>p</code> 节点，然后去搜索下个节点，重复这样的过程。</p><div class="alert warning"><p>有没有觉得很低效，那么问题出在哪里？</p></div><p>这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在<strong>回溯匹配不符合规则的节点</strong>。</p><p>我们不妨换个思路，还以上面的示例为准：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.jartto</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.yellow</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们按照「从右向左」的方式进行分析：<br>1.首先就查找到 <code>class=“yellow”</code> 的 <code>span</code> 元素；<br>2.接着检测父节点是否为 <code>p</code> 元素，如果不是则进入同级其他节点的遍历，如果是则继续匹配父节点满足 <code>class=“jartto”</code> 的 <code>div</code> 容器；<br>3.这样就又减少了集合的元素，只有符合当前的子规则才会匹配再上一条子规则。</p><p>综上所述，我们可以得出结论：<br><div class="alert success"><p>浏览器 <code>CSS</code> 匹配核心算法的规则是以从右向左方式匹配节点的。</p></div></p><p>样做是为了减少无效匹配次数，从而匹配快、性能更优。所以，我们在书写 <code>CSS Selector</code> 时，从右向左的 <code>Selector Term</code> 匹配节点越少越好。</p><p>不同 <code>CSS</code> 解析器对 <code>CSS Rules</code> 解析速度差异也很大，感兴趣的童鞋可以看看：<a href="http://test.veryos.com/selector/slickspeed/index.html" target="_blank" rel="noopener">CSS 解析引擎</a>，这里不再赘述。</p><h4 id="六、高效的-ComputedStyle"><a href="#六、高效的-ComputedStyle" class="headerlink" title="六、高效的 ComputedStyle"></a>六、高效的 ComputedStyle</h4><p>浏览器还有一个非常棒的策略，在特定情况下，浏览器会共享 <code>Computed Style</code>，网页中能共享的标签非常多，所以能极大的提升执行效率！</p><div class="alert success"><p>如果能共享，那就不需要执行匹配算法了，执行效率自然非常高。</p></div><p>如果两个或多个 <code>Element</code> 的 <code>ComputedStyle</code> 不通过计算可以确认他们相等，那么这些<code>ComputedStyle</code> 相等的 <code>Elements</code> 只会计算一次样式，其余的仅仅共享该 <code>ComputedStyle</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如何高效共享 <code>Computed Style</code> ？<br>1.<code>TagName</code> 和 <code>Class</code> 属性必须一样；<br>2.不能有 <code>Style</code> 属性。哪怕 <code>Style</code> 属性相等，他们也不共享；<br>3.不能使用 <code>Sibling selector</code>，譬如: <code>first-child</code>, <code>:last-selector</code>, <code>+ selector</code><br>4.<code>mappedAttribute</code> 必须相等；</p><p>为了更好的说明，我们再举两个例子：</p><p>不能共享，<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上述</a>规则2：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>jartto's<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以共享，<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">上述</a>规则4：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"middle"</span>&gt;</span>jartto's<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"middle"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>到这里，相信你对 <code>ComputedStyle</code> 有了更多的认识，代码也就更加精炼和高效了。</p><h4 id="七、CSS-书写顺序对性能有影响吗？"><a href="#七、CSS-书写顺序对性能有影响吗？" class="headerlink" title="七、CSS 书写顺序对性能有影响吗？"></a>七、CSS 书写顺序对性能有影响吗？</h4><p>书写顺序会对 <code>CSS</code> 性能有影响吗，这是个值得思考的问题。</p><p>需要注意的是：浏览器并不是一获取到 <code>CSS</code> 样式就立马开始解析，而是根据 <code>CSS</code> 样式的书写顺序将之按照 <code>DOM</code> 树的结构分布渲染样式，然后开始遍历每个树结点的 <code>CSS</code> 样式进行解析，此时的 <code>CSS</code> 样式的遍历顺序完全是按照之前的书写顺序。</p><div class="alert info"><p>在解析过程中，一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染。</p></div><p>我们来看看下面这个代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width: 150px;</span><br><span class="line">height: 150px;</span><br><span class="line">font-size: 24px;</span><br><span class="line">position: absolute;</span><br></pre></td></tr></table></figure></p><p>当浏览器解析到 <code>position</code> 的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染。</p><p>渲染引擎首先解除该元素在文档中所占位置，这就导致了该元素的占位情况发生了变化，其他元素可能会受到它回流的影响而重新排位。</p><p>我们对代码进行调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 150px;</span><br><span class="line">height: 150px;</span><br><span class="line">font-size: 24px;</span><br></pre></td></tr></table></figure></p><p>这样就能让渲染引擎更高效的工作，可是问题来了：<br><div class="alert warning"><p>在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？</p></div></p><p>这里有一个规范，建议顺序大致如下：<br>1.定位属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position  display  float  left  top  right  bottom   overflow  clear   z-index</span><br></pre></td></tr></table></figure></p><p>2.自身属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width  height  padding  border  margin   background</span><br></pre></td></tr></table></figure></p><p>3.文字样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family   font-size   font-style   font-weight   font-varient   color</span><br></pre></td></tr></table></figure></p><p>4.文本属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow</span><br></pre></td></tr></table></figure></p><p>5.CSS3中新增属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content   box-shadow   border-radius  transform</span><br></pre></td></tr></table></figure></p><p>当然，我们需要知道这个规则就够了，剩下的可以交给一些<strong>插件</strong>去做，譬如：<a href="https://github.com/CSSLint/csslint" target="_blank" rel="noopener">CSSLint</a>。能用代码实现的，千万不要去浪费人力。</p><h4 id="八、优化策略"><a href="#八、优化策略" class="headerlink" title="八、优化策略"></a>八、优化策略</h4><p>我们从浏览器构成，聊到了渲染引擎，再到 <code>CSS</code> 的解析原理，最后到执行顺序，做了一系列的探索。期望大家能从 <code>CSS</code> 的渲染原理中了解整个过程，从而写出更高效的代码。</p><p>1.使用 <code>id selector</code> 非常的高效。在使用 <code>id selector</code> 的时候需要注意一点：因为 <code>id</code> 是唯一的，所以不需要既指定 <code>id</code> 又指定 <code>tagName</code>：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#id1</span> &#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-id">#id1</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>2.避免深层次的 <code>node</code> ，譬如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red;&#125; </span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-tag">p-class</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>3.不要使用 <code>attribute selector</code>，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：<code>p[id=&quot;id1&quot;]</code>。这样将 <code>id selector</code> 退化成 <code>attribute selector</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bad  */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[id="jartto"]</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="blog"]</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="comment">/* Good  */</span></span><br><span class="line"><span class="selector-id">#jartto</span>&#123;<span class="attribute">color</span>:red;&#125;  </span><br><span class="line"><span class="selector-class">.blog</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以参考如下 <a href="http://nec.netease.com/standard/css-sort.html" target="_blank" rel="noopener">Css 规范</a>。</p><p>5.遵守 <a href="https://github.com/CSSLint/csslint" target="_blank" rel="noopener">CSSLint</a> 规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">font-faces        　　　　  　　　不能使用超过5个web字体</span><br><span class="line">import        　　　　　　　 　　  禁止使用@import</span><br><span class="line">regex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器</span><br><span class="line">universal-selector    　　 　　  禁止使用通用选择器*</span><br><span class="line">unqualified-attributes    　　　禁止使用不规范的属性选择器</span><br><span class="line">zero-units            　　 　　　0后面不要加单位</span><br><span class="line">overqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器</span><br><span class="line">shorthand        　　　　　　　　 简写样式属性</span><br><span class="line">duplicate-background-images    相同的url在样式表中不超过一次</span><br></pre></td></tr></table></figure></p><p>6.减少 <code>CSS</code> 文档体积</p><ul><li>移除空的 CSS 规则（Remove empty rules）</li><li>值为 0 不需要单位</li><li>使用缩写</li><li>属性值为浮动小数 0.**，可以省略小数点之前的0；</li><li>不给 h1-h6 元素定义过多的样式</li></ul><p>7.<code>CSS Will Change</code><br><code>WillChange</code> 属性，允许作者提前告知浏览器的默认样式，使用一个专用的属性来通知浏览器留意接下来的变化，从而优化和分配内存。</p><p>8.不要使用 <code>@import</code><br>使用 <code>@import</code> 引入 <code>CSS</code> 会影响浏览器的并行下载。使用 <code>@import</code> 引用的 <code>CSS</code> 文件只有在引用它的那个 <code>CSS</code> 文件被下载、解析之后，浏览器才会知道还有另外一个 <code>CSS</code> 需要下载，这时才去下载，然后下载后开始解析、构建 <code>Render Tree</code> 等一系列操作。</p><p>多个 <code>@import</code> 会导致下载顺序紊乱。在 <code>IE</code> 中，<code>@import</code> 会引发资源文件的下载顺序被打乱，即排列在 <code>@import</code> 后面的 <code>JS</code> 文件先于 <code>@import</code> 下载，并且打乱甚至破坏 <code>@import</code> 自身的并行下载。</p><p>9.避免过分重排（Reflow）<br>浏览器重新计算布局位置与大小。<br>常见的重排元素;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">width </span><br><span class="line">height </span><br><span class="line">padding </span><br><span class="line">margin </span><br><span class="line">display </span><br><span class="line">border-width </span><br><span class="line">border </span><br><span class="line">top </span><br><span class="line">position </span><br><span class="line">font-size </span><br><span class="line">float </span><br><span class="line">text-align </span><br><span class="line">overflow-y </span><br><span class="line">font-weight </span><br><span class="line">overflow </span><br><span class="line">left </span><br><span class="line">font-family </span><br><span class="line">line-height </span><br><span class="line">vertical-align </span><br><span class="line">right </span><br><span class="line">clear </span><br><span class="line">white-space </span><br><span class="line">bottom </span><br><span class="line">min-height</span><br></pre></td></tr></table></figure></p><p>10.高效利用 <code>computedStyle</code> </p><ul><li>公共类</li><li>慎用 ChildSelector</li><li>尽可能共享</li></ul><p>更多请查看上文：<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">高效的 ComputedStyle</a></p><p>11.减少昂贵属性：<br>当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写 <code>CSS</code> 时，我们应该尽量减少使用昂贵属性，如：</p><ul><li>box-shadow</li><li>border-radius</li><li>filter</li><li>:nth-child</li></ul><p>12.依赖继承。如果某些属性可以继承，那么自然没有必要在写一遍。</p><p>13.遵守 <code>CSS</code> 顺序规则</p><p>上面就是对<a href="http://jartto.wang/2019/10/23/css-theory-and-optimization/">本文</a>的一个总结，你了解 <code>CSS</code> 具体的实现原理，晓得规避错误书写方式，知道为什么这么优化，这就够了。</p><p>性能优化，进无止境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="优化" scheme="http://jartto.wang/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="css" scheme="http://jartto.wang/tags/css/"/>
    
      <category term="optimazation" scheme="http://jartto.wang/tags/optimazation/"/>
    
      <category term="原理" scheme="http://jartto.wang/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>网站优化，这些工具你一定用得着</title>
    <link href="http://jartto.wang/2019/09/08/web-optimization-tools/"/>
    <id>http://jartto.wang/2019/09/08/web-optimization-tools/</id>
    <published>2019-09-08T10:52:36.000Z</published>
    <updated>2019-09-10T08:14:33.202Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。在「<a href="http://jartto.wang/2019/02/16/web-optimization/">网站优化实战</a>」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！<br><a id="more"></a></p><h4 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h4><div class="alert success"><p>关于优化工具，我们主要从两方面说起：「性能评估工具」和「优化工具」。</p></div><p>1.性能评估工具</p><ul><li>Lighthouse</li><li>PageSpeed</li><li>YSlow</li></ul><p>2.优化工具我们主要依赖「Chrome DevTools」，大致如下：</p><ul><li>Network</li><li>Performance</li><li>Show Third Party Badges</li><li>Block Request URL</li><li>Coverage</li><li>DOM</li><li>Rendering</li><li>Layer</li></ul><h4 id="二、Lighthouse"><a href="#二、Lighthouse" class="headerlink" title="二、Lighthouse"></a>二、Lighthouse</h4><p>1.<code>Lighthouse</code> 安装<br><code>Chrome Setting</code> - 更多工具 - 扩展程序 - 打开 <code>Chrome</code> 网上应用店 - <code>Lighthouse</code></p><p>2.插件 - 生成报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/lighthouse.png" alt="lighthouse"></p><div class="alert success"><p>报告是我们的一个重要参考指标，这是网站评估的通用方法。</p></div><p>当然，网站也会有不同的类别，<strong>关注指标</strong>也不尽相同，后续我们会继续探讨「如何制定合理的网站优化性能指标」。</p><p>3.优化建议<br><code>Lighthouse</code> 比较人性化的点在于他既提出了问题，同时也提出了解决建议。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/performance.png" alt="performance"></p><h4 id="三、PageSpeed"><a href="#三、PageSpeed" class="headerlink" title="三、PageSpeed"></a>三、PageSpeed</h4><p>1.使用 <code>PageSpeed</code><br>我们可以在「Chrome DevTools」菜单栏中找到并打开：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagespeed.png" alt="pagespeed"></p><p>2.分析报告<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/pagescore.png" alt="pagescore"></p><h4 id="四、Chrome-DevTools-Network"><a href="#四、Chrome-DevTools-Network" class="headerlink" title="四、Chrome DevTools - Network"></a>四、Chrome DevTools - Network</h4><p>1.关于 <code>Network</code> 我们重点关注标注的 3 处<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network.png" alt="network"></p><p>2.<code>Timing</code> 也是优化不可缺少的工具：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/network1.png" alt="network1"></p><p>补充说明一下：<br><code>TTFB</code>：等待初始响应所用的时间，也称为第一字节的时间，这是我们判断服务器以及网络状况的重要指标。</p><div class="alert info"><p>此时间将捕捉到服务器往返的延迟时间，以及等待服务器传送响应所用的时间。</p></div><h4 id="五、Chrome-DevTools-Performance"><a href="#五、Chrome-DevTools-Performance" class="headerlink" title="五、Chrome DevTools - Performance"></a>五、Chrome DevTools - Performance</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf.png" alt="perf"></p><p>2.版面主要由 4 部分构成</p><ul><li>控制面板：录制，清除，配置记录期间需要捕获的信息</li><li><code>Overview</code>：页面性能的高级汇总，以及页面加载情况</li><li>火焰图：<code>CPU</code> 堆叠追踪的可视化</li><li>总览：饼图记录各部分耗时情况</li></ul><p>3.Overview 详解</p><ul><li><p>FPS<br>每秒帧数。绿色竖线越高，<code>FPS</code> 越高。 <code>FPS</code> 图表上的红色块表示长时间帧，很可能会出现卡顿。</p></li><li><p>CPU<br><code>CPU</code> 资源。此面积图指示消耗 <code>CPU</code> 资源的事件类型。</p></li><li><p>NET<br>每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。<br>每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。<br>深色部分表示传输时间（下载第一个和最后一个字节之间的时间）。</p></li></ul><div class="alert danger"><p>需要特别注意，<code>Performance</code> 工具中的每一种颜色其实都有自己的含义。</p></div><ul><li>HTML 文件为蓝色。</li><li>脚本为黄色。</li><li>样式表为紫色。</li><li>媒体文件为绿色。</li><li>其他资源为灰色。</li></ul><p>小技巧：<br><div class="alert info"><p>使用无痕模式，减少 Chrome 扩展程序会给应用的干扰。</p></div></p><p>4.火焰图</p><ul><li><p>Network<br><code>Network</code> 这里我们可以看出来，我们资源加载的一个顺序情况。什么时间加载了什么资源，通过这些，我们更直观的知道资源是否并行加载。</p></li><li><p>Frames<br><a href="http://jartto.wang/2019/09/08/web-optimization-tools/">上文</a>提及到的页面帧情况。</p></li><li><p>Interactions</p></li><li><p>Timings 中如下 5 个指标是我们优化的方向      </p><ul><li>First Paint</li><li>DOMContentLoaded Event</li><li>Onload Event</li><li>First Contentful Paint</li><li>First Meaningful Paint</li></ul></li><li><p>Main：展示了主线程运行状况。<br><code>X</code> 轴代表着时间，每个长条代表着一个 <code>event</code>。长条越长就代表这个 <code>event</code> 花费的时间越长。<br><code>Y</code> 轴代表了调用栈 <code>call stack</code> 。</p></li></ul><p>在栈里，上面的 <code>event</code> 调用了下面的 <code>event</code>。</p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf1.png" alt="perf1"></p><p>注意红色警告：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf2.png" alt="perf2"></p><ul><li>JS Heap<br><code>JavaScript</code> 运行过程中的大部分数据都保存在堆 <code>Heap</code> 中，所以 <code>JavaScript</code> 性能分析另一个比较重要的方面是<strong>内存</strong>，也就是<strong>堆的分析</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf3.png" alt="perf3"></p><ul><li>打开 Performance 监视器</li></ul><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/perf4.png" alt="perf4"></p><h4 id="六、Chrome-DevTools-Show-Third-Party-Badges"><a href="#六、Chrome-DevTools-Show-Third-Party-Badges" class="headerlink" title="六、Chrome DevTools - Show Third Party Badges"></a>六、Chrome DevTools - Show Third Party Badges</h4><p>很多情况下，并不是我们网站本身的问题，有可能你使用的三方资源拖累了站点性能。所以，我们需要使用 <code>Show Third Party Badges</code> 来进行排查。</p><p>1.测试站点：<a href="https://techcrunch.com/" target="_blank" rel="noopener">https://techcrunch.com/</a></p><p>2.打开控制面板：<code>Command + Shift + P</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge.png" alt="badge"></p><p>3.打开 <code>Network</code>，注意资源前面的<strong>彩色标志</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/badge1.png" alt="badge1"></p><div class="alert success"><p>三方资源都被标记出来了，移除或者替换那些影响性能的东西。</p></div><h4 id="七、Chrome-DevTools-Block-Request-URL"><a href="#七、Chrome-DevTools-Block-Request-URL" class="headerlink" title="七、Chrome DevTools - Block Request URL"></a>七、Chrome DevTools - Block Request URL</h4><p>对于项目中不确定是否有用的资源，我们可以使用 <code>Block Request URL</code> 来排除。</p><p>1.选中资源 - 右键 - <code>Block Request URL</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/block.png" alt="block"></p><div class="alert info"><p>阻止某些资源加载，<strong>控制变量法</strong>来排查页面性能问题。</p></div><h4 id="八、Chrome-DevTools-Coverage"><a href="#八、Chrome-DevTools-Coverage" class="headerlink" title="八、Chrome DevTools - Coverage"></a>八、Chrome DevTools - Coverage</h4><p>1.打开控制面板：<code>Command + Shift + P</code></p><p>2.输入：<code>Show Coverage</code><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/corvage.png" alt="corvage"></p><p>3.找到相应的文件，可以看到文件左侧已经标<strong>记出了部分代码的使用情况</strong><br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/coverage.png" alt="coverage"></p><p>解决思路也很简单：<br>尽可能去通过 <code>Webpack</code> 来<a href="http://jartto.wang/2019/02/16/web-optimization/">拆包</a>，控制大小在 <code>40KB</code> 以下，移除那些未使用代码。</p><h4 id="九、Chrome-DevTools-DOM"><a href="#九、Chrome-DevTools-DOM" class="headerlink" title="九、Chrome DevTools - DOM"></a>九、Chrome DevTools - DOM</h4><p>我们经常提到要优化 <code>Dom</code>，那么节点控制在什么范围才合理呢？</p><ul><li>总共少于 1500 个节点</li><li>最大深度为 32 个节点</li><li>不要存在子节点超过 60 个节点的父节点</li></ul><p>查看所有 <code>DOM</code> 节点数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>).length</span><br></pre></td></tr></table></figure></p><p>查看子元素个数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'body &gt; *'</span>).length</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>通常，只在需要时查找创建 DOM 节点的方法，并在不再需要时<strong>销毁</strong>它们。</p></div><h4 id="十、Chrome-DevTools-Rendering"><a href="#十、Chrome-DevTools-Rendering" class="headerlink" title="十、Chrome DevTools - Rendering"></a>十、Chrome DevTools - Rendering</h4><p>关于重渲对页面的影响，我们就不多说了。那么如何知道<strong>页面的渲染</strong>过程呢？我们可以通过 <code>Rendering</code> 来可视化查看。</p><p>1.打开 Rendering 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.png" alt="render"></p><p>2.刷新页面<br><div class="alert warning"><p>绿色区域越重，说明重复渲染的次数越多，通过优化 DOM 来减少无效渲染。</p></div></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/render.gif" alt="render"></p><h4 id="十一、Chrome-DevTools-Layer"><a href="#十一、Chrome-DevTools-Layer" class="headerlink" title="十一、Chrome DevTools - Layer"></a>十一、Chrome DevTools - Layer</h4><p>你可能会很好奇，为什么要查看图层？<br><div class="alert info"><p>这是因为，我们经常会在不知不觉的情况下搞乱了图层关系，或者增加了不合适的图层。</p></div></p><p>1.打开控制面板：<code>Command + Shift + P</code><br>2.选择 <code>Layer</code> 选项<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/optimization-tools/layer.png" alt="layer"></p><p>是不是图层问题就清清楚楚的摆在眼前了～</p><h4 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h4><p>通过优化工具，我们可以轻而易举的对网站进行定位分析。之后就可以快速展开优化，让网站高性能的运转起来。优化，也不过如此。</p><p>后续我们会深入了解一些优化相关的原理细节，如果你有优化相关的问题，欢迎一起探讨，一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。在「&lt;a href=&quot;http://jartto.wang/2019/02/16/web-optimization/&quot;&gt;网站优化实战&lt;/a&gt;」中我们提到了一些优化的相关经验，并没有对优化工具展开讨论，这节就让我们一起上手实践吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="web" scheme="http://jartto.wang/tags/web/"/>
    
      <category term="optimization" scheme="http://jartto.wang/tags/optimization/"/>
    
      <category term="tools" scheme="http://jartto.wang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何减少开发中的 Bug？</title>
    <link href="http://jartto.wang/2019/08/24/how-to-decrease-bugs/"/>
    <id>http://jartto.wang/2019/08/24/how-to-decrease-bugs/</id>
    <published>2019-08-24T03:35:27.000Z</published>
    <updated>2019-08-24T06:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。<br><a id="more"></a></p><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>爱因斯坦曾经说过：「如果给我一个小时解答一道决定我生死的问题，我会花55分钟来弄清楚这道题到底是在问什么。一旦清楚了它在问什么，剩下的5分钟足够解答这个问题。」</p><p>虽然我们软件开发过程不会面临生死的抉择，但是却直接影响着用户的<strong>使用感受</strong>，决定着产品的走向。所以程序员如何减少开发中的 Bug，既反映了<strong>代码质量</strong>，也反映了个<strong>人综合能力</strong>。</p><p>那么我们该如何有效的减少开发中的 Bug 呢？</p><div class="alert info"><p>我觉得应该从两方面说起：业务层和代码层。</p></div><h4 id="二、业务层"><a href="#二、业务层" class="headerlink" title="二、业务层"></a>二、业务层</h4><p>软件开发过程我们就不细说了，直接来看最重要的几个节点：</p><p>1.需求讨论阶段<br>一定要明确需求，<strong>测试，开发，产品三方务必达成一致</strong>。前期如果存在没有明确的问题，那么后期就会造成无效返工和不必要的争执，这在日常开发尤为常见。</p><div class="alert success"><p>所以，软件开发前期，我们都会进行「评审，反讲，评估」三个阶段。</p></div><p>2.开发完成阶段<br>开发完成后，程序员首先要完成「自测」，也就是软件开发中的「冒烟测试」，确保主流程无误。否则，在开发工程师提交代码后，测试工程师步履维艰，无法有效开展测试，会造成极大的资源浪费。</p><p>更规范的流程需要测试工程师在需求明确之后写出「测试用例」，开发工程师在完成开发后，自行对照「测试用例」完成初步验证，之后就可以代码提测了。</p><p>这么做的好处就是既保证了「高质量的代码交付」，同时减少了测试工程师的工作量，我们何乐而不为呢？</p><p>3.提测<br>自测和提测有什么区别呢，从软件开发过程来看，其实开发工程师和测试工程师其实完成了不同阶段的测试：</p><p>开发工程师「白盒测试」：<br>是指实际运行被测程序，<strong>通过程序的源代码进行测试而不使用用户界面</strong>。这种类型的测试需要从代码句法发现内部代码在算法、溢出、路径和条件等方面的缺点或者错误，进而加以修正。<br><div class="alert info"><p>白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。</p></div></p><p>测试工程师实际进行的是「黑盒测试」。那么什么是「黑盒测试」呢？<br>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，<strong>在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试</strong>。</p><p>它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。<strong>黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试</strong>。</p><div class="alert warning"><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。</p></div><p>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误。</p><ul><li>功能不正确或遗漏；</li><li>界面错误；</li><li>输入和输出错误；</li><li>数据库访问错误；</li><li>性能错误；</li><li>初始化和终止错误等；</li></ul><p>更多细节请查看文章：<a href="https://baike.baidu.com/item/黑盒测试/934030?fr=aladdin" target="_blank" rel="noopener">黑盒测试</a></p><h4 id="三、代码层"><a href="#三、代码层" class="headerlink" title="三、代码层"></a>三、代码层</h4><p>代码层面，我们需要从以下几方面来说起：</p><p>1.<strong>Eslint 规避低级语法问题</strong><br>这个显而易见，编写代码过程发现问题，避免因为简单语法，如：漏写了逗号，变量名写错，大小写问题等</p><p>2.<strong>边界处理</strong><br>做好容错，必要的判空，还有就是代码边界问题。多想一想如果数组不存在，我们如何处理？如果数组越界，我们如何修复？如果数据缺失，我们如何使页面不崩溃？</p><p>3.<strong>单元测试</strong><br>如果时间允许，我们可以做好单元测试，每次编译代码，或者提测前启动脚本，确定测试脚本都覆盖到了核心代码，尽可能减少代码出错率。</p><p>4.<strong>积累</strong><br>为什么说要积累，其实道理很简单。随着开发经验的增长，你可能会碰到很多问题，那么如果细心积累，其实很多错误在不知不觉中就被处理了。反之，你会不断的掉入同一个坑里，在进坑与出坑中迷失自我。那么我们如何积累呢？</p><p><strong>首先</strong>，碰到自己不会的问题，如果第一时间没有解决，通过查找或者请教别人解决了，那么一定要用小本本记下来，最好使用云笔记。好处不言自明。</p><p><strong>其次</strong>，要积累自己的函数库，我们经常用到的一些方法，不妨自己做一个封装，不断沉淀。也许有一天，你会发现，自己不知不知觉中写出了一个 Lodash 函数库。</p><p><strong>最后</strong>，你可以积累优秀的代码片段，嗯，「我们不生产代码，只是优秀代码的搬运工」。</p><p>5.学习<br>一句话，没有什么比学习优秀开源代码更有趣的事情了。<strong>阅读优秀源码，学习作者思想，站在巨人肩膀上，你才能走的更远！</strong></p><div class="alert success"><p>做好上面这些，相信你一定会是一位出色的工程师。</p></div><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>对于这类开放问题仁者见仁，智者见智，我相信每个人都会有自己的看法，也会有自己一套独特的方法。<strong>不管黑猫白猫，能抓住老鼠的就是好猫</strong>。对于程序员来说，能减少 Bug 的方法就是好方法。</p><div class="alert info"><p>程序员群体流传一句话：不写代码就有没有 Bug。</p></div><p>我们不能因为怕犯错误而减少写代码，更应该知难而上，越挫越勇。要知道日常开发中 「Bug 是不可避免的，只能减少」。</p><p>当然，这不应该成为我们写出 Bug 推脱的理由。不断超越，方是永恒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周会上大家抛出了一个问题，程序员如何减少开发中的 Bug？很有意思的一个话题，本篇文章我们来进行探讨与总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="bug" scheme="http://jartto.wang/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>使用 Electron5.0 构建你的 React 项目</title>
    <link href="http://jartto.wang/2019/07/13/use-electron-5/"/>
    <id>http://jartto.wang/2019/07/13/use-electron-5/</id>
    <published>2019-07-13T05:51:17.000Z</published>
    <updated>2019-07-30T05:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要使用 Electron 来构建 React 项目，突然发现之前的 <a href="https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start" target="_blank" rel="noopener">Demo</a> 已经不能正常运行了，有些感概技术发展的迅猛。<br><a id="more"></a><br>如果你还不了解 <code>Electron</code>，可以看我之前的文章：<a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a>，理论知识没有变。如果你想了解 <code>Electron5.0</code> 版本如何构建 <code>React</code> 项目，不妨继续看本文。</p><div class="alert danger"><p>需要注意：网上流传的 1.0 版本的项目应该已经启动不了了。</p></div><h4 id="一、为什么要写此文"><a href="#一、为什么要写此文" class="headerlink" title="一、为什么要写此文"></a>一、为什么要写此文</h4><p>之前研究的时候，<code>Electron</code> 还是 <code>1.0</code> 版本，因此写了一系列的文章。</p><ul><li><a href="http://jartto.wang/2018/01/03/first-exploration-electron/">初探 Electron - 理论篇</a></li><li><a href="http://jartto.wang/2018/01/04/first-exploration-electron-2/">初探 Electron - 升华篇</a></li><li><a href="http://jartto.wang/2018/01/14/first-exploration-electron-3/">初探 Electron - 实践篇1</a></li><li><a href="http://jartto.wang/2018/01/21/first-exploration-electron-4/">初探 Electron - 实践篇2</a></li></ul><p>经过本次尝试，发现 <code>5.0</code> 版本有了更多的变化，所以不想误人子弟，索性更新此系列文章。</p><div class="alert info"><p>这次起手，我们就来构建一个 React 项目。</p></div><h4 id="二、创建-React-项目"><a href="#二、创建-React-项目" class="headerlink" title="二、创建 React 项目"></a>二、创建 React 项目</h4><p>1.首先，全局安装 <code>cli</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global create-react-app</span><br></pre></td></tr></table></figure></p><p>2.创建项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app electron5-react-demo</span><br></pre></td></tr></table></figure></p><p>3.启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> electron5-react-demo &amp;&amp; yarn start</span><br></pre></td></tr></table></figure></p><p>4.访问 <code>http://localhost:3000/</code> 如果看到如下页面，说明你的 <code>React</code> 项目已经成功启动了。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/react.png" alt="react"></p><h4 id="三、集成-Electron-环境"><a href="#三、集成-Electron-环境" class="headerlink" title="三、集成 Electron 环境"></a>三、集成 Electron 环境</h4><p>1.首先需要安装 <code>Electron</code> 和 <code>Electron-builder</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add electron electron-builder --dev</span><br></pre></td></tr></table></figure></p><p>2.增加相应开发工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add wait-on concurrently --dev</span><br><span class="line">yarn add cross-env electron-is-dev</span><br></pre></td></tr></table></figure></p><p>3.项目根目录下新建文件：<code>electron.js</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch public/electron.js</span><br></pre></td></tr></table></figure></p><p>此时项目目录如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│   ├── electron.js</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.js</span><br><span class="line">│   ├── App.test.js</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   └── serviceWorker.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><p>4.修改代码，可以去<a href="https://github.com/electron/electron-quick-start/blob/master/main.js" target="_blank" rel="noopener">官网</a>上拷贝一份内容，写入 <code>electron.js</code>，具体如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules to control application life and create native browser window</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">+ <span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      preload: path.join(__dirname, <span class="string">'preload.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+  mainWindow.loadURL(</span><br><span class="line">+  isDev</span><br><span class="line">+  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">+  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">+  );</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  <span class="comment">// mainWindow.webContents.openDevTools()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">    <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) app.quit()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On macOS it's common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this file you can include the rest of your app's specific main process</span></span><br><span class="line"><span class="comment">// code. You can also put them in separate files and require them here.</span></span><br></pre></td></tr></table></figure></p><p>注意我们做了两处修改（加号位置）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入环境变量：</span></span><br><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">'electron-is-dev'</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置启动文件</span></span><br><span class="line">mainWindow.loadURL(</span><br><span class="line">  isDev</span><br><span class="line">  ? <span class="string">'http://localhost:3000'</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"../build/index.html"</span>)&#125;</span>`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>5.修改 <code>package.json</code> 文件，总共两处：<br>其一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"electron5-react-demo"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">+    <span class="string">"main"</span>: <span class="string">"public/electron.js"</span>,</span><br><span class="line">+    <span class="string">"homepage"</span>: <span class="string">"./"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其二，修改启动项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"react-start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line"><span class="string">"react-build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line"><span class="string">"electron-start"</span>: <span class="string">"electron ."</span>,</span><br><span class="line"><span class="string">"electron-build"</span>: <span class="string">"electron-builder"</span>,</span><br><span class="line"><span class="string">"release"</span>: <span class="string">"yarn react-build &amp;&amp; electron-builder --publish=always"</span>,</span><br><span class="line"><span class="string">"build"</span>: <span class="string">"yarn react-build &amp;&amp; yarn electron-build"</span>,</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"concurrently \"cross-env BROWSER=none yarn react-start\" \"wait-on http://localhost:3000 &amp;&amp; electron .\""</span></span><br><span class="line"><span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line"><span class="string">"eject"</span>: <span class="string">"react-scripts eject"</span>,</span><br></pre></td></tr></table></figure></p><h4 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>看到如下界面，恭喜你，已经成功启动了：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/electron.png" alt="Electron"></p><div class="alert info"><p>试着修改一下吧，热修改也已经生效了。</p></div><h4 id="五、构建"><a href="#五、构建" class="headerlink" title="五、构建"></a>五、构建</h4><p>如果你想构建，可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>需要注意：构建会同时构建 React 和 Electron 两个项目。</p></div><p>构建完成后，项目目录中会出现一个 <code>dist</code> 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── builder-effective-config.yaml</span><br><span class="line">├── electron5-react-demo-0.1.0-mac.zip</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg</span><br><span class="line">├── electron5-react-demo-0.1.0.dmg.blockmap</span><br><span class="line">├── latest-mac.yml</span><br><span class="line">└── mac</span><br><span class="line">    └── electron5-react-demo.app</span><br></pre></td></tr></table></figure></p><p>目录中的 <code>dmg</code> 就是 <code>Mac</code> 上面的安装程序，双击安装：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/electron/dmg.png" alt="dmg"></p><p>安装之后去运行吧，到这里，我们已经完成了整个项目。</p><h4 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h4><ul><li><a href="https://electronjs.org/docs?q=react" target="_blank" rel="noopener">Electron 文档</a></li><li><a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">API</a></li><li><a href="https://medium.com/@impaachu/how-to-build-a-react-based-electron-app-d0f27413f17f" target="_blank" rel="noopener">How to build a React based Electron app</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要使用 Electron 来构建 React 项目，突然发现之前的 &lt;a href=&quot;https://github.com/chenfengyanyu/my-web-accumulation/tree/master/electron-quick-start&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt; 已经不能正常运行了，有些感概技术发展的迅猛。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="electron" scheme="http://jartto.wang/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>Git 代码统计</title>
    <link href="http://jartto.wang/2019/07/09/git-stats/"/>
    <id>http://jartto.wang/2019/07/09/git-stats/</id>
    <published>2019-07-09T07:09:34.000Z</published>
    <updated>2019-07-09T08:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。<br><a id="more"></a></p><h4 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h4><p>目前大部分的项目可能都会用到 <code>Git</code> 来做代码管理，那么我们在不断的修改项目的过程中，可能会关注如下几个问题：</p><p>1.每个参与者贡献代码量，按劳分配某些资源🙈；<br>2.参与者的代码增删量，提交次数等；<br>3.统计活跃度；</p><div class="alert info"><p>那么，如何来对代码量做统计呢？</p></div><h4 id="二、常规操作"><a href="#二、常规操作" class="headerlink" title="二、常规操作"></a>二、常规操作</h4><p>一般情况，我们可以直接通过 <code>Git log</code> 来统计，如：</p><p>1.统计个人代码量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;jartto&quot; --pretty=tformat: --numstat | awk &apos;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&apos; -</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/code.png" alt="code"></p><p>2.贡献值统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort -u | wc -l</span><br></pre></td></tr></table></figure></p><p>3.查看排名前 5 的贡献者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&apos;%aN&apos; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure></p><div class="alert success"><p>更多 <code>log</code> 操作可以请移步：<a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a>。</p></div><p>这时候，你可能在想：有没有省时省力的方式呢，顺便帮我生成报告。答案是肯定的，是时候请出我们的 <code>git_stats</code> 了。</p><h4 id="三、使用-git-stats"><a href="#三、使用-git-stats" class="headerlink" title="三、使用 git_stats"></a>三、使用 git_stats</h4><p>1.首先，我们需要全局安装 <code>git_stats</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install git_stats</span><br></pre></td></tr></table></figure></p><p>2.接下来，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git_stats generate</span><br></pre></td></tr></table></figure></p><p>3.打开 <code>git_stats</code> 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> git_stats &amp;&amp; open index.html</span><br></pre></td></tr></table></figure></p><h4 id="四、演示"><a href="#四、演示" class="headerlink" title="四、演示"></a>四、演示</h4><p>1.概览<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/gitstats.png" alt="generate"></p><p>2.<code>Dashboard</code> 可视化<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git/activity.png" alt="activity"></p><p>如果你对 <code>git_stats</code> 生成的一大堆文件不满意，我们还有一种方式可以「无侵入」，同时显得更加「高冷」。</p><h4 id="五、补充：cloc"><a href="#五、补充：cloc" class="headerlink" title="五、补充：cloc"></a>五、补充：<code>cloc</code></h4><div class="alert info"><p>cloc 最优秀的地方就是「简洁粗暴」，我们来尝试一下。</p></div><p>1.尝试一下 <code>cloc</code>，首先，全局安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cloc</span><br></pre></td></tr></table></figure></p><p>2.简单用例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cloc [options] &lt;file(s)/dir(s)/git <span class="built_in">hash</span>(es)&gt;</span><br><span class="line">    Count physical lines of <span class="built_in">source</span> code and comments <span class="keyword">in</span> the given files</span><br><span class="line">    (may be archives such as compressed tarballs or zip files) and/or</span><br><span class="line">    recursively below the given directories or git commit hashes.</span><br><span class="line">    Example:    cloc src/ include/ main.c</span><br><span class="line"></span><br><span class="line">cloc [options] --diff &lt;set1&gt;  &lt;set2&gt;</span><br><span class="line">    Compute differences of physical lines of <span class="built_in">source</span> code and comments</span><br><span class="line">    between any pairwise combination of directory names, archive</span><br><span class="line">    files or git commit hashes.</span><br><span class="line">    Example:    cloc --diff Python-3.5.tar.xz python-3.6/</span><br></pre></td></tr></table></figure></p><p>3.使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: cloc [options] &lt;file(s)/dir(s)/git hash(es)&gt; | &lt;set 1&gt; &lt;set 2&gt; | &lt;report files&gt;</span><br></pre></td></tr></table></figure></p><p>进入项目，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc .</span><br></pre></td></tr></table></figure></p><p>稍等片刻，就会有一个输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">JavaScript                       10319         172724         254924         951843</span><br><span class="line">HTML                               679         120179           3665         224595</span><br><span class="line">JSON                              1714            256              0         182127</span><br><span class="line">Markdown                          1400          63461              2         171768</span><br><span class="line">C++                                 69           3538           3197          20331</span><br><span class="line">Python                              51           4292           7801          19137</span><br><span class="line">C/C++ Header                       117           3628           2033          18942</span><br><span class="line">CSS                                113           2011            823          16594</span><br><span class="line">XML                                 32           4427           1300          11277</span><br><span class="line">Sass                                65            282            414           4255</span><br><span class="line">Stylus                              60            539            593           3215</span><br><span class="line">YAML                               189            324            413           3039</span><br><span class="line">D                                   57              0              0           3003</span><br><span class="line">EJS                                113             43              8           2160</span><br><span class="line">reStructuredText                    18            681             51           2122</span><br><span class="line">Bourne Shell                        20            394            398           1875</span><br><span class="line">SVG                                  5              0              1           1646</span><br><span class="line">LESS                                13             26             33           1343</span><br><span class="line">make                                42            378            245           1310</span><br><span class="line">TypeScript                          17            276            584           1161</span><br><span class="line">Perl                                 1             87            170            582</span><br><span class="line">DTD                                  1            179            177            514</span><br><span class="line">m4                                   2             40              2            266</span><br><span class="line">Lisp                                 3             42             38            264</span><br><span class="line">Bourne Again Shell                   8             43             24            161</span><br><span class="line">C                                    4             40             37            149</span><br><span class="line">Ruby                                 6             24              5            140</span><br><span class="line">JSON5                                2              0              0            123</span><br><span class="line">CoffeeScript                         3             18             28             99</span><br><span class="line">Handlebars                           4             18              0             96</span><br><span class="line">Smarty                               6             17             30             91</span><br><span class="line">Windows Resource File                1              1              1             33</span><br><span class="line">DOS Batch                            5              2              0             16</span><br><span class="line">IDL                                  1              1              0             11</span><br><span class="line">zsh                                  1              4             13              7</span><br><span class="line">-----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>4.更多的使用命令，可以查看帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc --help</span><br></pre></td></tr></table></figure></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>上文介绍了三种 <code>Git</code> 代码统计方式：</p><p>1.通过 <code>Git log</code> 统计，稍微会麻烦一些，需要有一些 <code>awk</code> 知识的储备；<br>2.使用插件 <code>git_stats</code> 来生成可视化报告，对用户友好。美中不足就是会在当前项目增加很多 <code>html</code> 统计可视化文件；<br>3.命令行工具 <code>cloc</code>，简单易用，无侵入，使用门槛低；</p><div class="alert success"><p>综上所述，我们可以按照自己的使用场景来灵活的选用不同方式。</p></div><h4 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h4><ul><li><a href="https://segmentfault.com/a/1190000008542123" target="_blank" rel="noopener">Git 代码统计</a></li><li><a href="https://www.zhihu.com/question/22004842/answer/177254508" target="_blank" rel="noopener">有哪些比较好用的代码量统计工具？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们维护一个开源项目的时候，你肯定想知道哪些人比较活跃，哪些人贡献比较多。这时候就需要一个简单易用的工具，下面我来介绍几款。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="git" scheme="http://jartto.wang/tags/git/"/>
    
      <category term="stats" scheme="http://jartto.wang/tags/stats/"/>
    
      <category term="git_stats" scheme="http://jartto.wang/tags/git-stats/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 之跨域通讯（postMessage）</title>
    <link href="http://jartto.wang/2019/06/11/post-message/"/>
    <id>http://jartto.wang/2019/06/11/post-message/</id>
    <published>2019-06-11T08:31:21.000Z</published>
    <updated>2019-07-09T08:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况下，我们受到浏览器的安全策略限制。如何能规避此限制，并且能安全的使用跨域通讯，这就不得不介绍一下 postMessage 了。<br><a id="more"></a></p><h4 id="一、关于-postMessage"><a href="#一、关于-postMessage" class="headerlink" title="一、关于 postMessage"></a>一、关于 postMessage</h4><div class="alert success"><p>window.postMessage() 方法可以安全地实现跨源通信。</p></div><p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 <code>https</code>），端口号（<code>443</code> 为 <code>https</code> 的默认值），以及主机 (两个页面的模数 <code>Document.domain</code> 设置为相同的值) 时，这两个脚本才能相互通信。</p><p><code>window.postMessage()</code> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p><h4 id="二、理解过程"><a href="#二、理解过程" class="headerlink" title="二、理解过程"></a>二、理解过程</h4><p><code>window.postMessage()</code> 方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个  <code>MessageEvent</code> 消息。 该 <code>MessageEvent</code> 消息有四个属性： </p><p>1.<code>message</code> 属性表示该 <code>message</code> 的类型；<br>2.<code>data</code> 属性为 <code>window.postMessage</code> 的第一个参数；<br>3.<code>origin</code> 属性表示调用 <code>window.postMessage()</code> 方法时调用页面的当前状态；<br>4.<code>source</code> 属性记录调用 <code>window.postMessage()</code> 方法的窗口信息。</p><p>关于更多细节，我们可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener"> MDN 文档</a>，这里就不赘述了。</p><h4 id="三、兼容性"><a href="#三、兼容性" class="headerlink" title="三、兼容性"></a>三、兼容性</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/postmsg/use.png" alt="caniuse"></p><p>通过上面的图片，我们可以看出来，几乎所有的浏览器都支持了 <code>postMessage</code>，所以放心大胆的去使用吧。</p><h4 id="四、用法简介"><a href="#四、用法简介" class="headerlink" title="四、用法简介"></a>四、用法简介</h4><p>基本用例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure></p><p>1.<code>otherWindow</code><br>其他窗口的一个引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性、执行 <code>window.open</code> 返回的窗口对象、或者是命名过或数值索引的 <code>window.frames</code>。</p><p>2.<code>message</code><br>将要发送到其他 <code>window</code> 的数据。它将会被结构化克隆算法序列化。</p><div class="alert info"><p>这意味着我们可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</p></div><p>3.<code>targetOrigin</code><br>通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 「*」（表示无限制）或者一个 <code>URI</code>。</p><p>在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 <code>targetOrigin</code> 提供的值，那么消息就不会被发送；</p><p>只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口。</p><p>我们举个例子，当用 <code>postMessage</code> 传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的 <code>origin</code> 属性完全一致，来防止密码被恶意的第三方截获。</p><p>如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的 <code>targetOrigin</code>，而不是 <code>*</code>。</p><div class="alert danger"><p>需要注意：不提供确切的目标将导致数据泄露到恶意站点。</p></div><p>4.<code>transfer</code><br>是一串和 <code>message</code> 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p><h4 id="五、事件监听"><a href="#五、事件监听" class="headerlink" title="五、事件监听"></a>五、事件监听</h4><p>我们来看下面这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// For Chrome, the origin property is in the event.originalEvent</span></span><br><span class="line">  <span class="comment">// object. </span></span><br><span class="line">  <span class="comment">// 这里不准确，chrome没有这个属性</span></span><br><span class="line">  <span class="comment">// var origin = event.origin || event.originalEvent.origin; </span></span><br><span class="line">  <span class="keyword">var</span> origin = event.origin</span><br><span class="line">  <span class="keyword">if</span> (origin !== <span class="string">"http://jartto.wang:8080"</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.<code>data</code><br>从其他 <code>window</code> 中传递过来的对象。</p><p>2.<code>origin</code><br>调用 <code>postMessage</code>  时消息发送方窗口的 <code>origin</code> . 这个字符串由 协议、<code>://</code>、域名、<code>: 端口号</code> 拼接而成。</p><p>例如 <code>https://jartto.wang (隐含端口 443)</code>、<code>http://jartto.net(隐含端口 80)</code>、<code>http://jartto.com:8080</code>。请注意，这个 <code>origin</code> 不能保证是该窗口的当前或未来 <code>origin</code> ，因为<code>postMessage</code> 被调用后可能被导航到不同的位置。</p><p>3.<code>source</code><br>对发送消息的窗口对象的引用， 我们可以使用此来在具有不同 <code>origin</code> 的两个窗口之间建立双向通信。</p><h4 id="六、简单应用"><a href="#六、简单应用" class="headerlink" title="六、简单应用"></a>六、简单应用</h4><p>1.监听 <code>message</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get it !!!'</span>,event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.发送数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(&#123;</span><br><span class="line">    name: <span class="string">'Jartto'</span>,</span><br><span class="line">    say: <span class="string">'hello~'</span>,</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多情况下，我们受到浏览器的安全策略限制。如何能规避此限制，并且能安全的使用跨域通讯，这就不得不介绍一下 postMessage 了。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="HTML5" scheme="http://jartto.wang/tags/HTML5/"/>
    
      <category term="postMessage" scheme="http://jartto.wang/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>进阶 PM2</title>
    <link href="http://jartto.wang/2019/05/24/pm2-cluster/"/>
    <id>http://jartto.wang/2019/05/24/pm2-cluster/</id>
    <published>2019-05-24T11:55:22.000Z</published>
    <updated>2019-07-09T03:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>PM2 大大简化了 Node 任务操作，除了简单的应用外，我们还可以做一些有趣的事情。本节我们来探讨一下 PM2 的平滑启动以及数据监控。<br><a id="more"></a><br>如果你还不了解 <code>PM2</code>，可以先看看<a href="http://jartto.wang/2016/06/27/first-experience-of-pm2/">PM2 初体验</a>，或者查看<a href="https://www.jianshu.com/p/f640450bd120" target="_blank" rel="noopener">PM2 用法简介</a>。</p><h4 id="一、PM2-两种启动方式"><a href="#一、PM2-两种启动方式" class="headerlink" title="一、PM2 两种启动方式"></a>一、<code>PM2</code> 两种启动方式</h4><p>1.<code>cluster_mode</code>：用 <code>cluster</code> 来做负载均衡，我们不需要做任何代码的改动。<br>2.<code>fork_mode</code>：用 <code>fork</code> 模式启动（默认），这可以允许我们通过改变 <code>exec_interpreter</code> 参数，启动 <code>php</code> 或者 <code>python</code> 服务。      </p><div class="alert success"><p>Node.js 给我们提供了 cluster 模块，它可以生成多个工作线程来共享同一个 TCP 连接。</p></div><h4 id="二、实时扩展集群"><a href="#二、实时扩展集群" class="headerlink" title="二、实时扩展集群"></a>二、实时扩展集群</h4><p>任何时候，如果我们需要增加工作线程的数量，可以通过 <code>pm2 scale &lt;app name&gt; &lt;n&gt;</code> 来对集群进行扩展。参数 <code>&lt;n&gt;</code> 指定工作线程的数量，被用来增加或减少集群数。</p><div class="alert info"><p>补充：可以通过 pm2 scale app +3 的方式来指定要增加多少工作线程。</p></div><p><code>PM2</code> 的 <code>reload &lt;app name&gt;</code> 功能将依次重启所有的工作线程。每一个线程会等待在新的线程创建之后才会被终止掉，因此，当你在产品环境部署新的代码时，<code>Server</code> 会不间断地一直保持运行。</p><h4 id="三、平滑重启"><a href="#三、平滑重启" class="headerlink" title="三、平滑重启"></a>三、平滑重启</h4><p>1.fork 模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"apps"</span> : [&#123;</span><br><span class="line">     <span class="string">"name"</span>         : <span class="string">"pc"</span>,</span><br><span class="line">     <span class="string">"script"</span>       : <span class="string">"jartto-server.js"</span>,</span><br><span class="line">     <span class="string">"kill_timeout"</span> : <span class="number">3000</span>,</span><br><span class="line">     <span class="string">"instances"</span>: <span class="number">2</span>,</span><br><span class="line">     <span class="string">"log_date_format"</span>: <span class="string">"YY-MM-DD HH:mm:ss Z"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> httpServer = server.listen(port, error =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">       <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">   process.send(<span class="string">'ready'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(<span class="string">'SIGINT'</span>, () =&gt; &#123;</span><br><span class="line">   httpServer.close(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">       process.exit(error ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.<code>cluster</code><br>在集群模式下，有一个默认系统可在应用程序接受连接时将每个集群设置为就绪。还有一个超时，默认为 <code>3000</code> 毫秒，我们可以使用 <code>ecosystem</code> 文件中的 <code>listen_timeout</code> 属性进行设置。</p><p>生成 <code>ecosystem.config.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 ecosystem</span><br></pre></td></tr></table></figure></p><p>输出日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[PM2] Spawning PM2 daemon with pm2_home=/Users/jartto/.pm2</span><br><span class="line">[PM2] PM2 Successfully daemonized</span><br><span class="line">File /Users/jartto/Documents/project/ecosystem.config.js generated</span><br></pre></td></tr></table></figure></p><p>简单示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;&#125;, &#123;&#125;], <span class="comment">// 存放每一个进程的配置信息</span></span><br><span class="line">  deploy: &#123;&#125; <span class="comment">// 包含部署配置的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，就可以通过 <code>startOrRestart</code> 来启动了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "cross-env PATH_TYPE=test pm2 startOrRestart ecosystem.config.js --only jartto-test --env test",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 <code>apps</code> 和 <code>deploy</code> 下面我们来细致聊一聊。</p><h4 id="四、apps-部分"><a href="#四、apps-部分" class="headerlink" title="四、apps 部分"></a>四、<code>apps</code> 部分</h4><p>上面 <code>ecosystem.config.js</code> 会生成一个简单的模版，为了更好的掌握，我们来看看更全的一些配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    apps : [&#123;</span><br><span class="line">        name: <span class="string">'Jartto-test'</span>, <span class="comment">// 进程名称</span></span><br><span class="line">        script: <span class="string">'./node_modules/nuxt-start/bin/nuxt-start.js'</span>, <span class="comment">// 启动脚本地址</span></span><br><span class="line">        args: <span class="string">'-p 8888 -H 0.0.0.0'</span>, <span class="comment">// 启动的配置</span></span><br><span class="line">        cwd: </span><br><span class="line">        instances: <span class="number">4</span>,</span><br><span class="line">        autorestart: <span class="literal">true</span>,</span><br><span class="line">        watch: <span class="literal">false</span>,</span><br><span class="line">        max_restarts: <span class="number">5</span>,</span><br><span class="line">        max_memory_restart: <span class="string">'1G'</span>,</span><br><span class="line">        env: &#123;</span><br><span class="line">            NODE_ENV: <span class="string">'development'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        env_production: &#123;</span><br><span class="line">            NODE_ENV: <span class="string">'production'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    deploy : &#123;</span><br><span class="line">        production : &#123;</span><br><span class="line">            user : <span class="string">'node'</span>,</span><br><span class="line">            host : <span class="string">'212.83.163.1'</span>,</span><br><span class="line">            ref : <span class="string">'origin/master'</span>,</span><br><span class="line">            repo : <span class="string">'git@github.com:repo.git'</span>,</span><br><span class="line">            path : <span class="string">'/var/www/production'</span>,</span><br><span class="line">            post-deploy : <span class="string">'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参数意义：</p><ul><li>apps：json 结构，apps 是一个数组，每一个数组成员就是对应一个pm2中运行的应用</li><li>name：应用程序的名称</li><li>cwd：应用程序所在的目录</li><li>script：应用程序的脚本路径</li><li>exec_interpreter：应用程序的脚本类型，这里使用的 shell，默认是 nodejs</li><li>min_uptime：最小运行时间，这里设置的是 60s 即如果应用程序在 60s 内退出，pm2 会认为程序异常退出，此时触发重启 max_restarts 设置数量</li><li>max_restarts：设置应用程序异常退出重启的次数，默认 15 次（从0开始计数）</li><li>exec_mode：应用程序启动模式，这里设置的是 cluster_mode（集群），默认是 fork</li><li>error_file：自定义应用程序的错误日志文件</li><li>out_file：自定义应用程序日志文件</li><li>pid_file：自定义应用程序的 pid 文件</li><li>watch：是否启用监控模式，默认是 false。如果设置成 true，当应用程序变动时，pm2 会自动重载。这里也可以设置你要监控的文件。</li></ul><h4 id="五、deploy-部分"><a href="#五、deploy-部分" class="headerlink" title="五、deploy 部分"></a>五、<code>deploy</code> 部分</h4><p>1.生成公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id jartto@server.com</span><br></pre></td></tr></table></figure></p><p>补充说明一下：<br><code>ssh-copy-id</code> 命令可以把本地主机的公钥复制到远程主机的 <code>authorized_keys</code> 文件上，实现免密码登陆。</p><p>2.配置 <code>ecosystem</code> 文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">    name: <span class="string">"app"</span>,</span><br><span class="line">    script: <span class="string">"app.js"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  deploy: &#123;</span><br><span class="line">    <span class="comment">// "production" is the environment name</span></span><br><span class="line">    production: &#123;</span><br><span class="line">      <span class="comment">// SSH key path, default to $HOME/.ssh</span></span><br><span class="line">      key: <span class="string">"/path/to/some.pem"</span>,</span><br><span class="line">      <span class="comment">// SSH user</span></span><br><span class="line">      user: <span class="string">"Jartto"</span>,</span><br><span class="line">      <span class="comment">// SSH host</span></span><br><span class="line">      host: [<span class="string">"192.168.0.13"</span>],</span><br><span class="line">      <span class="comment">// SSH options with no command-line flag, see 'man ssh'</span></span><br><span class="line">      <span class="comment">// can be either a single string or an array of strings</span></span><br><span class="line">      ssh_options: <span class="string">"StrictHostKeyChecking=no"</span>,</span><br><span class="line">      <span class="comment">// GIT remote/branch</span></span><br><span class="line">      ref: <span class="string">"origin/master"</span>,</span><br><span class="line">      <span class="comment">// GIT remote</span></span><br><span class="line">      repo: <span class="string">"git@github.com:jartto/repository.git"</span>,</span><br><span class="line">      <span class="comment">// path in the server</span></span><br><span class="line">      path: <span class="string">"/var/www/jartto-repository"</span>,</span><br><span class="line">      <span class="comment">// Pre-setup command or path to a script on your local machine</span></span><br><span class="line">      <span class="string">'pre-setup'</span>: <span class="string">"apt-get install git ; ls -la"</span>,</span><br><span class="line">      <span class="comment">// Post-setup commands or path to a script on the host machine</span></span><br><span class="line">      <span class="comment">// eg: placing configurations in the shared dir etc</span></span><br><span class="line">      <span class="string">'post-setup'</span>: <span class="string">"ls -la"</span>,</span><br><span class="line">      <span class="comment">// pre-deploy action</span></span><br><span class="line">      <span class="string">'pre-deploy-local'</span>: <span class="string">"echo 'This is a local executed command'"</span>,</span><br><span class="line">      <span class="comment">// post-deploy action</span></span><br><span class="line">      <span class="string">'post-deploy'</span>: <span class="string">"npm install"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令很简单，都有注释，这里就不赘述了。</p><p>3.是时候启动了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup deployment at remote location</span></span><br><span class="line">pm2 deploy production setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update remote version</span></span><br><span class="line">pm2 deploy production update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Revert to -1 deployment</span></span><br><span class="line">pm2 deploy production revert 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute a command on remote servers</span></span><br><span class="line">pm2 deploy production <span class="built_in">exec</span> <span class="string">"pm2 reload all"</span></span><br></pre></td></tr></table></figure></p><p>更多配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; &lt;command&gt;</span><br><span class="line">  Commands:</span><br><span class="line">    setup                run remote setup commands</span><br><span class="line">    update               update deploy to the latest release</span><br><span class="line">    revert [n]           revert to [n]th last deployment or 1</span><br><span class="line">    curr[ent]            output current release commit</span><br><span class="line">    prev[ious]           output previous release commit</span><br><span class="line">    exec|run &lt;cmd&gt;       execute the given &lt;cmd&gt;</span><br><span class="line">    list                 list previous deploy commits</span><br><span class="line">    [ref]                deploy to [ref], the &quot;ref&quot; setting, or latest tag</span><br></pre></td></tr></table></figure></p><p>了解更多，请参考<a href="https://pm2.io/doc/en/runtime/guide/easy-deploy-with-ssh/#force-deployment" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="六、环境变量"><a href="#六、环境变量" class="headerlink" title="六、环境变量"></a>六、环境变量</h4><p><code>pm2</code> 通过在配置文件中通过 <code>env_xx</code> 来声明不同环境的配置，然后在启动应用时，通过 <code>--env</code> 参数指定运行的环境。一个简单的示例可能如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://www.jartto.wang/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;env_dev&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://dev.jartto.wang/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;env_test&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://test.jartto.wang/&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="七、负载均衡"><a href="#七、负载均衡" class="headerlink" title="七、负载均衡"></a>七、负载均衡</h4><p><code>PM2</code> 提供了强大的负载能力，我们可以通过如下命令来开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js -i 3 # 开启三个进程</span><br><span class="line">pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程</span><br></pre></td></tr></table></figure></p><h4 id="八、数据监控"><a href="#八、数据监控" class="headerlink" title="八、数据监控"></a>八、数据监控</h4><p><code>PM2</code> 提供了一个数据监控命令：<code>pm2 monit</code>，执行命令后，大概界面如下：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/monit.png" alt="monit"></p><p>看起来不错，可惜并不实用。大家可能发现了，在实际场景下，我们线上环境会有 <code>N</code> 台服务器，你会一台台上去看监控数据吗？</p><div class="alert info"><p>显然，我们碰到了另一种场景，那么如何才能统一监控呢？</p></div><p>不要着急，<code>PM2</code> 为我们提供了另外一种方式，通过在 <code>Server</code> 端运行命令：<code>pm2 web</code>，我们可以在该机器启动一个监听服务：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/pm2web.png" alt="web"></p><p>之后，你可以通过 <code>主机 IP:9615</code> 来获取数据，如下图：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/api.png" alt="api"></p><div class="alert info"><p>获取数据可以通过客户端轮询，或者是服务端 Socket 推送，It’s up to you!</p></div><p>最后，我们来看看数据格式：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/data.png" alt="data"></p><p>有了数据，那么可视化岂不是小菜一碟，我们就可以在本地实时监控如下数据：<br>1.服务器内存情况；<br>2.<code>CPU</code> 使用情况；<br>3.各个站点服务情况，是否正常运转，是否报错，是否频繁重启等；<br>4.服务器平均负载；<br>…</p><h4 id="九、重置状态"><a href="#九、重置状态" class="headerlink" title="九、重置状态"></a>九、重置状态</h4><p>既然通过 <code>PM2</code> 来监控数据了，那么我们肯定希望每次的数据是准确的，所以这时候就可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 reset jartto-test</span><br></pre></td></tr></table></figure></p><p>来重置服务状态。</p><h4 id="十、最终效果"><a href="#十、最终效果" class="headerlink" title="十、最终效果"></a>十、最终效果</h4><p>有了数据，可视化就非常容易了，我们来看一个简单的示例：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/pm2/show.png" alt="show"></p><p>当然，你可以做的更好，快发挥你创造性，做一些有趣的事情吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PM2 大大简化了 Node 任务操作，除了简单的应用外，我们还可以做一些有趣的事情。本节我们来探讨一下 PM2 的平滑启动以及数据监控。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="pm2" scheme="http://jartto.wang/tags/pm2/"/>
    
      <category term="cluster" scheme="http://jartto.wang/tags/cluster/"/>
    
      <category term="fork" scheme="http://jartto.wang/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>Nuxtjs 2.0 升级爬坑</title>
    <link href="http://jartto.wang/2019/04/23/update-nuxt2-0/"/>
    <id>http://jartto.wang/2019/04/23/update-nuxt2-0/</id>
    <published>2019-04-23T11:58:32.000Z</published>
    <updated>2019-04-23T13:18:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我在升级 Nuxt2.0 的过程，遇到了很多问题，逐一查找解决，废了不少时间。回头想想，真希望在升级的时候看到这样一篇文章，让我少走一些弯路。<br><a id="more"></a><br><div class="alert success"><p>这篇文章的意义也在于此，希望对大家能有所帮助。</p></div></p><h4 id="一、为什么要从-Nuxt1-0-升级到-Nuxt2-0？"><a href="#一、为什么要从-Nuxt1-0-升级到-Nuxt2-0？" class="headerlink" title="一、为什么要从 Nuxt1.0 升级到 Nuxt2.0？"></a>一、为什么要从 <code>Nuxt1.0</code> 升级到 <code>Nuxt2.0</code>？</h4><p>我们来看看 <code>Nuxt2.0</code> 有哪些<a href="https://www.cnblogs.com/zhuanzhuanfe/p/9101932.html" target="_blank" rel="noopener">更新</a>：</p><p>1.支持 <code>webpack4</code><br><code>webpack4</code> 有很多优化的提升，升级后就可以嗨皮的使用了。</p><p>2.弃掉了 <code>venders</code><br>我们以前一直使用 <code>vendors chunk</code>，这次发布后，我们不再使用 <code>CommonsChunkPlugin</code>，所以不必明确指定 <code>vendors</code>。</p><p><code>Nuxt</code> 自动添加了核心的 <code>packages</code> (包括 <code>vue</code>, <code>vue-router</code>, <code>babel-runtime</code>…)到 <code>Cache Group</code>中。</p><div class="alert info"><p>这使得 <code>webpack</code> 可以用最合理的方式拆分你的代码。</p></div><p>3.<code>chunk splitting</code> 的完全控制<br>尽管 <code>nuxt</code> 试图提供最有效的分割，但现在可以使用 <code>build.splitChunks</code> 选项完全控制它，并且可以选择禁用每个路由的异步块。</p><p>4.<code>Vue Loader 15 and mini-css-extract-plugin</code><br><code>Vue-Loader 15</code> 进行了完全的重写，它使用了一种完全不同的新架构，能够将 <code>webpack</code> 配置中定义的任何规则应用于 <code>*.vue</code> 文件内。</p><p>对于 <code>CSS</code> 抽取，使用一个新的插件 <code>mini-css-extract-plugin</code>，它支持 <code>CSS</code> 和 <code>SourceMaps</code>（<code>CSS splitting</code>）的按需加载，并构建在新的 <code>webpack v4</code> 特性（<code>module types</code>）上。</p><p>5.<code>nuxt es modules</code><br>我们可以在 <code>nuxt.config.js</code> 中使用 <code>import</code>, <code>export</code>, 服务器 <code>middleware</code>, <code>modules</code> 。</p><p>6.<code>CLI</code> 改善<br><code>nuxt2.0</code> 自动检测配置项和测试环境，并将切换到一个称为 <code>minimalCLI</code> 的特殊模式，其中包含更少的详细消息。</p><h4 id="二、升级-2-0"><a href="#二、升级-2-0" class="headerlink" title="二、升级 2.0"></a>二、升级 2.0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nuxt@latest</span><br></pre></td></tr></table></figure><h4 id="三、记得重新安装一下依赖"><a href="#三、记得重新安装一下依赖" class="headerlink" title="三、记得重新安装一下依赖"></a>三、记得重新安装一下依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><h4 id="四、升级问题"><a href="#四、升级问题" class="headerlink" title="四、升级问题"></a>四、升级问题</h4><p>问题一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module build failed: TypeError: Cannot read property &apos;eslint&apos; of undefined</span><br></pre></td></tr></table></figure></p><p>碰到这个问题，是因为 <code>isClient</code> 新版本已经移除了，我们试着<a href="https://github.com/nuxt/nuxt.js/issues/3216" target="_blank" rel="noopener">理解一下</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isClient was removed in nuxt-edge, it should be replaced by process.client in your nuxt.config.js as below.</span><br></pre></td></tr></table></figure></p><p><code>Nuxtjs1.0</code> 我们是这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extend(config, &#123; isDev, isClient &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDev &amp;&amp; isClient) &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">        enforce: <span class="string">"pre"</span>,</span><br><span class="line">        test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">        loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以应该修改成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extend (config, &#123; isDev &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDev &amp;&amp; process.client) &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">          enforce: <span class="string">'pre'</span>,</span><br><span class="line">          test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">          loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">          exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="alert info"><p>注意 isClient 和 process.client！</p></div><p>问题二：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ERROR  Failed to compile with 1 errors</span><br><span class="line">error  <span class="keyword">in</span> ./.nuxt/router.js</span><br><span class="line"></span><br><span class="line">Module parse failed: Unexpected token (24:8)</span><br><span class="line">You may need an appropriate loader to handle this file <span class="built_in">type</span>.</span><br><span class="line">|</span><br><span class="line">| var _5f05608f = <span class="keyword">function</span> <span class="function"><span class="title">_5f05608f</span></span>() &#123;</span><br><span class="line">&gt;     <span class="built_in">return</span> import(<span class="string">'../pages/account/index.vue'</span> /* webpackChunkName: <span class="string">"pages/account/index"</span> */).<span class="keyword">then</span>(<span class="keyword">function</span> (m) &#123;</span><br><span class="line">|         <span class="built_in">return</span> m.default || m;</span><br><span class="line">|     &#125;);</span><br><span class="line"></span><br><span class="line">@ ./.nuxt/index.js 334:14-36</span><br><span class="line">@ ./.nuxt/client.js</span><br><span class="line">@ multi webpack-hot-middleware/client?name=client&amp;reload=<span class="literal">true</span>&amp;timeout=30000&amp;path=/__webpack_hmr ./.nuxt/client.js</span><br></pre></td></tr></table></figure></p><p>碰到这个问题，应该是某些包不兼容，所以可以先清除 <code>node_modules</code>，重新安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules/</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><p>问题三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Plugin/Preset files are not allowed to export objects, only functions</span><br></pre></td></tr></table></figure></p><p>这个问题是因为 <code>Babel7</code> 的更新，所以我们需要<a href="https://stackoverflow.com/questions/47830273/babel-plugin-preset-files-are-not-allowed-to-export-objects-only-functions" target="_blank" rel="noopener">更新配置文件</a>：</p><p>首先修改 <code>package.json</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "@babel/core": "^7.1.6",</span><br><span class="line">    "@babel/preset-env": "^7.1.6",</span><br><span class="line">    "@babel/preset-react": "^7.0.0",</span><br><span class="line">    "babel-loader": "^8.0.4",</span><br><span class="line">    "webpack": "^4.25.1",</span><br><span class="line">    "webpack-cli": "^3.1.2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着更改 <code>nuxt.config.js</code>，如果使用了动态导入，需要注意<a href="https://github.com/styleguidist/react-styleguidist/issues/987" target="_blank" rel="noopener">如下配置</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">presets: [<span class="string">'@babel/env'</span>, <span class="string">'@babel/react'</span>],</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="string">'@babel/plugin-syntax-dynamic-import'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>问题四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This dependency was not found: vant/lib/vant-css/index.css in ./plugins/vant.js</span><br><span class="line">import &apos;vant/lib/vant-css/index.css&apos;;</span><br></pre></td></tr></table></figure></p><p>我们发现升级后，第三方 <code>UI</code> 库的样式找不到了，通过查找，发现是文件<a href="https://youzan.github.io/vant/#/zh-CN/quickstart" target="_blank" rel="noopener">引用路径</a>发生了变化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue’;</span></span><br><span class="line"><span class="string">import Vant from '</span>vant’;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.css’;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Vue.use(Vant);</span></span><br></pre></td></tr></table></figure></p><p>问题五：静态资源加载异常<br><div class="alert warning"><p>这个异常很明显，图片全部访问不了了，所以一定要注意看看 <code>Nuxt2.0</code> 做了<a href="https://zh.nuxtjs.org/guide/assets/" target="_blank" rel="noopener">哪些更改</a>。</p></div></p><p>请注意: 从 <code>Nuxt2.0</code> 开始，<code>~/alias</code> 将无法在 <code>CSS</code> 文件中正确解析。你必须在 <code>url CSS</code> 引用中使用 <code>~assets</code>（没有斜杠）或 <code>@</code> 别名，即 <code>background:url(&quot;~assets/banner.svg&quot;)</code></p><p>问题六：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN  Using an Array as build.postcss will be deprecated in Nuxt 3. Please switch to the object declaration</span><br></pre></td></tr></table></figure></p><div class="alert danger"><p>意思很明了，postcss 以后需要用<a href="https://zh.nuxtjs.org/faq/postcss-plugins/" target="_blank" rel="noopener">对象声明</a>，不再支持数组方式。</p></div><p>我们将：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postcss: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"postcss-px2rem-exclude"</span>)(&#123;</span><br><span class="line">        remUnit: <span class="number">75</span>,</span><br><span class="line"></span><br><span class="line">        exclude: <span class="regexp">/node_modules|vant/</span></span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">        browsers: [<span class="string">'Android &gt;= 4.0'</span>, <span class="string">'iOS &gt;= 7'</span>]</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>替换成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postcss: &#123;</span><br><span class="line">    <span class="string">'postcss-px2rem-exclude'</span>: &#123;</span><br><span class="line">        emUnit: <span class="number">75</span>,</span><br><span class="line">        exclude: <span class="string">'/node_modules|vant/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'autoprefixer'</span>: &#123;</span><br><span class="line">        browsers: [<span class="string">'Android &gt;= 4.0'</span>, <span class="string">'iOS &gt;= 7’]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure></p><p>问题七：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError：regeneratorRuntime is not defined</span><br></pre></td></tr></table></figure></p><p>需要增加 babel <a href="https://github.com/nuxt/nuxt.js/issues/934" target="_blank" rel="noopener">运行时编译</a>，配置 <code>package.json</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"babel-plugin-transform-runtime": "^6.23.0",</span><br></pre></td></tr></table></figure></p><p>修改 <code>nuxt.config.js</code> 中的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="string">'@babel/plugin-syntax-dynamic-import'</span>,</span><br><span class="line">  <span class="string">'@babel/transform-runtime'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>问题八：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EACCES: permission denied, mkdir &apos;/Users/jartto/Documents/project/primary-station/node_modules/.cache’</span><br></pre></td></tr></table></figure></p><p>使用 <code>sudo</code> 启动，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm run start</span><br></pre></td></tr></table></figure></p><p>问题九：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR in Sentry CLI Plugin: Command failed: /apps/srv/instance/test-touch.gaotu100.com/node_modules/@sentry/cli/sentry-cli releases new 2.4.0</span><br><span class="line">error: An organization slug is required (provide with --org)</span><br><span class="line"></span><br><span class="line">Add --log-level=[info|debug] or export SENTRY_LOG_LEVEL=[info|debug] to see more output.</span><br><span class="line">Please attach the full debug log to all bug reports.</span><br></pre></td></tr></table></figure></p><p>这个问题类似和问题一一样，注意替换 <code>isClient</code>。</p><h4 id="五、升级前后对比"><a href="#五、升级前后对比" class="headerlink" title="五、升级前后对比"></a>五、升级前后对比</h4><p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/nuxt/diff.png" alt="diff"></p><p><a href="http://jartto.wang/2019/04/23/update-nuxt2-0/">如上</a>截图，我们只取了一部分，但是可以看到，文件被更细粒度的进行了拆分。这完全要归功于 <code>splitChunks</code>。当然，更多优化点和细节你可以慢慢来体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我在升级 Nuxt2.0 的过程，遇到了很多问题，逐一查找解决，废了不少时间。回头想想，真希望在升级的时候看到这样一篇文章，让我少走一些弯路。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="impress" scheme="http://jartto.wang/tags/impress/"/>
    
  </entry>
  
  <entry>
    <title>酷炫的 HTML5 网页 PPT</title>
    <link href="http://jartto.wang/2019/04/15/amusing-ppt/"/>
    <id>http://jartto.wang/2019/04/15/amusing-ppt/</id>
    <published>2019-04-15T12:07:39.000Z</published>
    <updated>2019-06-06T07:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般演讲、培训等场合，我们都离不开 PPT，那么如何做出一款与众不同而有充满科技感的 PPT 呢？这时候，我们可以尝试一下在线 PPT。<br><a id="more"></a></p><h4 id="一、选择在线-PPT-的几大原因"><a href="#一、选择在线-PPT-的几大原因" class="headerlink" title="一、选择在线 PPT 的几大原因"></a>一、选择在线 PPT 的几大原因</h4><p>1.省去了上传下载的麻烦；<br>2.降低了客户端对 PPT 软件的依赖；<br>3.随时更新，更灵活；<br>4.同屏播放，全场互动，增加用户体验；<br>…</p><h4 id="二、多种选择"><a href="#二、多种选择" class="headerlink" title="二、多种选择"></a>二、多种选择</h4><p>1.<code>revealjs</code><br>一个可以帮我们轻易使用 <code>HTML</code> 创建漂亮演示文稿的框架。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt1.png" alt="revealjs"></p><p>2.<code>impress</code><br>效果非常酷炫，下文将深入介绍。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt2.png" alt="impress"></p><p>3.<code>fathom.js</code><br>使用 <code>HTML</code>，<code>CSS</code>，<code>JS</code> 来实现滑动页面，体验非常接近 <code>PPT</code>。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt3.png" alt="fathom"></p><p>4.focusky<br>操作界面简洁，易上手。支持 3D 幻灯片演示特效打破常规。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt5.png" alt="focusky"></p><h4 id="三、强力推荐"><a href="#三、强力推荐" class="headerlink" title="三、强力推荐"></a>三、强力推荐</h4><p>上面介绍了很多可用的在线 <code>PPT</code> 类库，在我看来最酷炫的莫过于 <code>impress.js</code>，我们先来看一个演示：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/demo.gif" alt="impress-demo"></p><div class="alert info"><p>注意：在 Impress 中大量使用 3D 动画，可能会使页面变得卡顿。</p></div><h4 id="四、基本使用"><a href="#四、基本使用" class="headerlink" title="四、基本使用"></a>四、基本使用</h4><p>1.定义结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.每页 <code>PPT</code> 使用 <code>step</code> 类来区分<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bored"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"-1000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">q</span>&gt;</span>Aren’t you just <span class="tag">&lt;<span class="name">b</span>&gt;</span>bored<span class="tag">&lt;/<span class="name">b</span>&gt;</span> with all those slides-based presentations?<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>3.使用 <code>data-x</code>，<code>data-y</code> 完成平移操作<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bored"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"-1000"</span> <span class="attr">data-y</span>=<span class="string">"-1500"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">q</span>&gt;</span>Aren’t you just <span class="tag">&lt;<span class="name">b</span>&gt;</span>bored<span class="tag">&lt;/<span class="name">b</span>&gt;</span> with all those slides-based presentations?<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>4.缩放：<code>data-scale</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"0"</span> <span class="attr">data-y</span>=<span class="string">"0"</span> <span class="attr">data-scale</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"try"</span>&gt;</span>then you should try<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>impress.js<span class="tag">&lt;<span class="name">sup</span>&gt;</span>*<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"footnote"</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>*<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> no rhyme intended<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>5.页面旋转：<code>data-rotate</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"its"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"850"</span> <span class="attr">data-y</span>=<span class="string">"3000"</span> <span class="attr">data-rotate</span>=<span class="string">"90"</span> <span class="attr">data-scale</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      It’s a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>presentation tool<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> </span><br><span class="line">      inspired by the idea behind <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://prezi.com"</span>&gt;</span>prezi.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">      and based on the <span class="tag">&lt;<span class="name">strong</span>&gt;</span>power of CSS3 transforms and transitions<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> in modern browsers.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6.调整 <code>z</code> 方向层级 <code>data-z</code>，可以理解为离用户的远近距离<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tiny"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"2825"</span> <span class="attr">data-y</span>=<span class="string">"2325"</span> <span class="attr">data-z</span>=<span class="string">"-3000"</span> <span class="attr">data-rotate</span>=<span class="string">"300"</span> <span class="attr">data-scale</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>and <span class="tag">&lt;<span class="name">b</span>&gt;</span>tiny<span class="tag">&lt;/<span class="name">b</span>&gt;</span> ideas<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>7.使用 <code>data-rotate-x</code>, <code>data-rotate-y</code>, <code>data-rotate-z</code> 实现 <code>3D</code> 旋转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;its-in-3d&quot; class=&quot;step&quot; data-x=&quot;6200&quot; data-y=&quot;4300&quot; data-z=&quot;-100&quot; data-rotate-x=&quot;-40&quot; data-rotate-y=&quot;10&quot; data-scale=&quot;2&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;span class=&quot;have&quot;&gt;have&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;you&quot;&gt;you&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;noticed&quot;&gt;noticed&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;its&quot;&gt;it’s&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;in&quot;&gt;in&lt;/span&gt;</span><br><span class="line">      &lt;b&gt;3D&lt;sup&gt;*&lt;/sup&gt;&lt;/b&gt;?</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;span class=&quot;footnote&quot;&gt;* beat that, prezi ;)&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>此外，还有一些可用的 <code>css</code> 类，<code>js</code> 初始化方法，以及 <code>stepenter</code> 事件等，具体可以参考<a href="https://github.com/impress/impress.js/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="五、投屏互动"><a href="#五、投屏互动" class="headerlink" title="五、投屏互动"></a>五、投屏互动</h4><p>演讲者端，监听 <code>impress:stepgoto</code> 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> impressiv = <span class="function"><span class="keyword">function</span>(<span class="params">presi,session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> socket = io.connect(<span class="string">'http://jartto.wang'</span>);</span><br><span class="line">        socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">presi</span>: presi, <span class="attr">session</span>:session&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'演示结束，欢迎观看！'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'impress:stepgoto'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'slide'</span>, &#123;<span class="attr">slide</span>:event.target.id&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观众端，接收 <code>slide</code> 消息，然后自动翻页：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> impressiv = <span class="function"><span class="keyword">function</span>(<span class="params">presi</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> socket = io.connect(<span class="string">'http://jartto.wang'</span>);</span><br><span class="line">  socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">presi</span>: presi&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">'slide'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 控制用户端翻页</span></span><br><span class="line">    impress().goto(data.slide);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'演示结束，欢迎观看！'</span>);</span><br><span class="line">    <span class="comment">// io.disconnect();</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要特别注意，我们要禁止掉观众端的操作事件，否则你演讲过程就会被别人牵着鼻子走了🙈～<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'touchstart'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'click'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'keydown'</span>);</span><br><span class="line">$(<span class="built_in">document</span>).unbind(<span class="string">'keyup'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="六、可视化编辑"><a href="#六、可视化编辑" class="headerlink" title="六、可视化编辑"></a>六、可视化编辑</h4><p>如果你不喜欢写代码，我们可以选择<a href="http://qti3e.github.io/Imprezi/#/step-2" target="_blank" rel="noopener">可视化编辑器</a>。<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/ppt/ppt4.png" alt="visi"></p><h4 id="七、更多资源"><a href="#七、更多资源" class="headerlink" title="七、更多资源"></a>七、更多资源</h4><ul><li><a href="https://devzum.com/2014/11/10-best-javascript-and-html5-presentation-frameworks/" target="_blank" rel="noopener">10 Best JavaScript And HTML5 Presentation Frameworks</a></li><li><a href="https://github.com/impress/impress.js/wiki/Examples-and-demos" target="_blank" rel="noopener">impress examples-and-demos</a></li><li><a href="http://qti3e.github.io/Imprezi/#/step-2" target="_blank" rel="noopener">可视化编辑器</a></li><li><a href="https://github.com/melix/deck2pdf" target="_blank" rel="noopener">impress 导出 pdf</a></li><li><a href="https://github.com/impress/impress.js/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">impress api 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般演讲、培训等场合，我们都离不开 PPT，那么如何做出一款与众不同而有充满科技感的 PPT 呢？这时候，我们可以尝试一下在线 PPT。&lt;br&gt;
    
    </summary>
    
    
      <category term="技术博文" scheme="http://jartto.wang/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="ppt" scheme="http://jartto.wang/tags/ppt/"/>
    
      <category term="impress" scheme="http://jartto.wang/tags/impress/"/>
    
      <category term="html5" scheme="http://jartto.wang/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>如何成为合格的技术面试官？</title>
    <link href="http://jartto.wang/2019/04/07/learn-interview/"/>
    <id>http://jartto.wang/2019/04/07/learn-interview/</id>
    <published>2019-04-07T13:12:42.000Z</published>
    <updated>2019-04-15T12:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为技术面试官，<a href="http://jartto.wang/2019/01/06/f2e-interview/">面试过程</a>很少考虑候选人的感受。上来就是问，不合适就送走。虽然技术环节我很专业，但是其他细节我却知之甚少。<br><a id="more"></a><br>从来没觉得这样会有什么问题，直到有一天，我参加了一场面试官培训，才意识到自身的不足。</p><h4 id="一、明确面试的目的"><a href="#一、明确面试的目的" class="headerlink" title="一、明确面试的目的"></a>一、明确面试的目的</h4><p>作为公司的面试官，我们不是为了鄙视和炫耀技术，而是评估候选人能否担任工作。这属于团队建设核心工作，也是公司的一次品牌宣传。</p><div class="alert info"><p>你代表的不仅是个人，还有公司的形象，请尊重每一位候选人。</p></div><p>仓央嘉措曾经说过：我以为别人尊重我，是因为我很优秀。慢慢的我明白了，别人尊重我，是因为别人很优秀；优秀的人更懂得尊重别人。对人恭敬其实是在庄严你自己。</p><h4 id="二、开场过程"><a href="#二、开场过程" class="headerlink" title="二、开场过程"></a>二、开场过程</h4><p>为了体现足够的重视和面试的专业性，在开场过程，我们需要注意以下几点：<br>1.为候选人倒杯温水<br>这个我深有体会，有时候在持续多轮面试后，候选人已经嗓子冒烟了。所以，一杯水体现了公司的细节和关怀。</p><p>2.简单的寒暄缓和气氛<br>先简单的问候和寒暄，调整一下面试氛围，让候选人在舒服的气氛中开始。</p><p>3.面试官简单自我介绍<br>面试官应该做一下自我介绍，明确自己角色。阐述面试流程，告知候选人面试过程需要用电脑做记录。</p><p>4.候选人自我介绍<br>完成上面几项后，就可以从候选人自我介绍进入面试主流程了。</p><p>5.Q&amp;A<br>面试最后问问候选人，是否有什么问题想问，或者可以说说自己擅长而又没有被问到的方面。</p><p>6.致谢<br>感谢候选人能够花时间过来面试，表现出足够的重视。</p><p>7.告知等候时间/送候选人出去</p><div class="alert info"><p>让候选人更好的发挥，也为高效的面试做好铺垫。</p></div><h4 id="三、面试问题"><a href="#三、面试问题" class="headerlink" title="三、面试问题"></a>三、面试问题</h4><p>1.根据简历提前准备好，针对不同 <code>level</code> 使用不同题目；<br>2.不使用偏难怪题；<br>3.切合候选人的经验，不要依据自己熟悉的领域提问；<br>4.考察素质能力尽量使用相同的问题，以保证横向比较的公平；<br>5.问题和所面职位具有相关性；</p><h4 id="四、完整的行为示例-STAR"><a href="#四、完整的行为示例-STAR" class="headerlink" title="四、完整的行为示例 - STAR"></a>四、完整的行为示例 - STAR</h4><p>我们先来看看 <code>STAR</code> 解释：<code>Situation</code>, <code>Task</code>, <code>Action</code>, <code>Result</code>。</p><p>示例：<br>举个例子说说你擅长性能优化。</p><p>要点：<br>当时情况怎么样，需要做什么，采取了什么行动，达到了什么效果。</p><p>理念：<br>在收集 <code>STAR</code> 的时候不断提出更加深入的问题来判断其对该带我的认知程度及抗压能力。</p><h4 id="五、面试分工"><a href="#五、面试分工" class="headerlink" title="五、面试分工"></a>五、面试分工</h4><p>面试一般会分几轮，所以不同的面试官面试的重点也应该有所区别。<br>一面：基本技能（知识，专业技能）<br>二面：逻辑分析（专业技能，能力）<br>三面：综合素质（个性特征、动机、价值观）</p><p>这样的好处有两个：<br>1.在每一轮全面的面试相关领域；<br>2.避免重复的询问，导致过差的体验；</p><p>曾经有过这样的经历，在面试某大公司的过程，总共经历 4 次面试（三轮技术面，一轮 <code>HR</code> 面）。每一面都需要自我介绍，甚至还有重复的问题，整个过程体验非常差。第一、我觉得该公司并没有尊重我；第二、公司效率很低；第三、只是提自己的问题，从来不考虑候选人的感受；</p><p>所以面完之后我直接拒绝了，虽然浪费了时间，但是却让我排除了一些徒有虚名的公司。</p><div class="alert danger"><p>做好面试纪录，避免重复问题，以及避免第一印象效应。</p></div><h4 id="六、考察综合素质"><a href="#六、考察综合素质" class="headerlink" title="六、考察综合素质"></a>六、考察综合素质</h4><p>为了考察候选人的综合素质，面试过程我们其实可以从六方面去考察：<br>1.知识：<br>也就是我们常说的基本功。</p><p>2.专业技能：<br>职位相关的技术能力，这决定你是否能胜任工作。</p><p>3.能力：<br>个人能力包括：思维能力，学习能力，迁移能力，扩展能力等等。</p><p>4.个性特性：<br>正直诚实，责任心，坚韧性。</p><p>5.动机：<br>体现在成就导向，主动性。</p><p>6.价值观：<br>体现在团队合作。</p><div class="alert success"><p>从技能到性格，再到自驱以及团队合作，相信这样的人不优秀也难。</p></div><h4 id="七、评估"><a href="#七、评估" class="headerlink" title="七、评估"></a>七、评估</h4><p>1.有潜力：<br>能够在一段时间内，通过培养，胜任范围更大，难度更高的项目。</p><p>2.能干活：<br>能够胜任当前的工作，但是因某项能力（技术基础 or 某项软素质）较弱，在发展上会受到一些限制。</p><p>3.三颗完整 <a href="#"><code>STAR</code></a> 确实一项事实：<br>在收集 <code>STAR</code> 的时候不断提出更加深入的问题来判断其对该带我的认知程度及抗压能力。</p><p>优点：尽可能挖掘优点，如果有需要后面可以调整面试方向。<br>不足：基于我们职位要求。</p><p>4.预测：<br>通过其过去的行为来预测将来的行为。</p><div class="alert info"><p>做到上面这些，相信你会成为一个更有魅力的面试官。</p></div><p>不管是作为面试官还是候选人，我们都需要去了解这些流程。作为面试官，我们应该提升自身的综合素质，为公司树立较好的品牌效果。作为候选人，我们可以以此来判断该公司的靠谱程度，避免坐坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为技术面试官，&lt;a href=&quot;http://jartto.wang/2019/01/06/f2e-interview/&quot;&gt;面试过程&lt;/a&gt;很少考虑候选人的感受。上来就是问，不合适就送走。虽然技术环节我很专业，但是其他细节我却知之甚少。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试笔试" scheme="http://jartto.wang/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://jartto.wang/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="interview" scheme="http://jartto.wang/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>算法学习思路</title>
    <link href="http://jartto.wang/2019/04/07/learn-algorithm/"/>
    <id>http://jartto.wang/2019/04/07/learn-algorithm/</id>
    <published>2019-04-07T11:06:18.000Z</published>
    <updated>2019-04-07T13:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多前端童鞋对算法都有莫名的恐惧，究其原因无非两点：其一，对算法不了解；其二，没有找到实际应用场景。<br><a id="more"></a></p><h4 id="一、为什么学习算法？"><a href="#一、为什么学习算法？" class="headerlink" title="一、为什么学习算法？"></a>一、为什么学习算法？</h4><p>这是个很有意思的问题，对算法感兴趣的人，不需要问为什么，算法对他们可能是一种兴趣。曾经有位同事，他刷遍了所有算法题，只要有算法竞赛，他都会去参加。当然，也取得了不错的成绩，甚至有了自己的世界排名。</p><p>一次闲聊中，我抛出了这个问题，他笑着说：没有为什么，就是觉得好玩。我一直好奇，为什么有人会觉得算法好玩，兴趣点究竟在哪里？</p><div class="alert info"><p>其实兴趣算一部分，而另一部分则是对编程能力的提升以及思维的扩展。</p></div><p>编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论。</p><p>我们用两张趣图来看看差别：<br>1.学习算法前，你可能这样：<br><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog2.gif" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog2.gif" style="width:70%;" alt></a></div><div style="clear:both;"></div></p><p>2.学习算法后，你变的机灵了：<br><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog1.gif" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/dog1.gif" style="width:70%;" alt></a></div><div style="clear:both;"></div></p><h4 id="二、如何入门？"><a href="#二、如何入门？" class="headerlink" title="二、如何入门？"></a>二、如何入门？</h4><p>那么如何学习算法呢？这里我推荐一本书《算法图解》，超薄的小册。书中通过一些简单有趣的例子来阐述算法的应用场景。之所以选它作为入门，是因为我们可以用很短的时间去翻读。</p><p>如果你还是觉得很麻烦，不用怕，我已经帮你准备好了学习笔记：</p><ul><li><a href="http://jartto.wang/2018/11/22/algorithm1/">算法图解1 - 二分查找和大O表示法</a></li><li><a href="http://jartto.wang/2018/11/25/algorithm2/">算法图解2 - 数组和链表</a></li><li><a href="http://jartto.wang/2018/11/26/algorithm3/">算法图解3 - 递归，快排</a></li><li><a href="http://jartto.wang/2018/11/27/algorithm4/">算法图解4 - 散列表</a></li><li><a href="http://jartto.wang/2018/11/28/algorithm5/">算法图解5 - 图和广度优先搜索</a></li><li><a href="http://jartto.wang/2018/11/29/algorithm6/">算法图解6 - 狄克斯特拉算法与贪婪算法</a></li><li><a href="http://jartto.wang/2018/11/29/algorithm7/">算法图解7 - 动态规划</a></li></ul><p>书中是围绕 <code>Python</code> 来写的，为了更适合前端童鞋阅读，我已经将相关代码用 <code>JS</code> 实现了一遍。当然，还是有很多的细节，还需要深入的去理解。但是最起码，我不再惧怕算法了，反而慢慢有点喜欢了。</p><div class="alert info"><p>算法的重中之重是培养算法思维。如果你能对算法灵活运用，那么就「大成」了。</p></div><h4 id="三、后面的路怎么走？"><a href="#三、后面的路怎么走？" class="headerlink" title="三、后面的路怎么走？"></a>三、后面的路怎么走？</h4><p>入门从来都不是一件简单的事情，在我们打开这扇神秘大门之后，将会有更多的宝藏需要我们去挖掘。</p><p>想要精通算法，在第一本书读完之后，我们还有更多的目标需要去完成。这里由浅入深的列举一些算法经典书籍，供大家参考学习：</p><p>1.入门系列：<br>《算法图解》《大话数据结构》<br>2.教科书之类：<br>《数据结构与算法分析》<br>3.进阶之旅：<br>《算法导论》<br>4.针对面试准备：<br>《剑指 Offer》《编程珠玑》<br>5.扩展阅读：<br>《算法之美》《算法帝国》<br>6.实践操作：<br>《算法竞赛入门经典》《力扣题库》</p><p>算法其实有很多经典书籍，我们没有那么多的时间去逐一翻阅，但是我们可以有一条明确的学习路线。</p><div class="alert success"><p>这条学习路线就是：入门 - 进阶 - 实践 - 升华</p></div><h4 id="四、配合实践"><a href="#四、配合实践" class="headerlink" title="四、配合实践"></a>四、配合实践</h4><p>其实<a href="http://jartto.wang/2019/04/07/learn-algorithm/">上面</a>已经提到了，在我们掌握算法思维之后，最为重要的一点就是刷题。相信很多童鞋都听过 <code>LeetCode</code> ，目前题库大概有 1000＋ 题目，没事了就去刷刷。</p><div class="figure left" style="width:70%;"><a class="fancybox" href="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode.png" title data-fancybox-group="travel" target="_blank" rel="noopener"><img class="fig-img" src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode.png" style="width:70%;" alt></a></div><div style="clear:both;"></div><p>当然，刷题也可以由浅入深，先从简单的入手吧！<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/leetcode2.png" alt="leetcode"></p><h4 id="五、推荐学习"><a href="#五、推荐学习" class="headerlink" title="五、推荐学习"></a>五、推荐学习</h4><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md" target="_blank" rel="noopener">JavaScript 算法与数据结构</a><br><a href="http://algorithm-visualizer.org/#path=sorting/bucket/basic" target="_blank" rel="noopener">可视化学习算法的好工具</a><br><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">互联网公司最常见的面试算法题有哪些？</a><br><a href="https://github.com/chenfengyanyu/interview" target="_blank" rel="noopener">算法练习，和我一起来刷题吧～</a></p><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>文章陆陆续续说了这么多，大体总结如下：<br>1.算法很重要，尤其是对于前端童鞋；<br>2.算法学习最好由浅入深，先了解算法思维，再去理解实际应用；<br>3.从一本小而薄的书开启，逐步全面的掌握相关知识体系；<br>4.推荐速成路线：《算法图解》-《剑指 Offer》- LeetCode 刷题 -《算法之美》-《算法导论》；<br>5.去努力实践，刷刷题库，参加参加竞赛；</p><p>好了，就这些吧，祝大家早日搞定算法，带上算法的王冠，去领略算法之美吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多前端童鞋对算法都有莫名的恐惧，究其原因无非两点：其一，对算法不了解；其二，没有找到实际应用场景。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法实践" scheme="http://jartto.wang/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="algorithm" scheme="http://jartto.wang/tags/algorithm/"/>
    
  </entry>
  
</feed>
